{
  "language": "Solidity",
  "sources": {
    "OmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport \"@layerzerolabs/onft-evm/contracts/onft721/ONFT721.sol\";\nimport \"./interfaces/IOmniNadsMinter.sol\";\nimport \"./libs/DynamicONFT.sol\";\n\n\ncontract OmniNadsMinter is IOmniNadsMinter, ONFT721 {\n\n\n    DynamicONFT.MintInfo public mintInfo;\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\n    mapping(address => bool) private _hasMinted;\n    mapping(address => bool) private _isWhitelisted;\n    \n\n\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate,\n        uint16 _maxSupply,\n        address[] memory _whitelistedAddresses\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) {\n\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n        mintInfo._maxSupply = _maxSupply;\n        mintInfo._totalSupply = 0;\n\n        for (uint i = 0; i < _whitelistedAddresses.length; ) {\n            _isWhitelisted[_whitelistedAddresses[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    modifier isNotSmartContract() {\n        require(\n            msg.sender.code.length == 0,\n            \"Smart contract mint is not allowed!\"\n        );\n        _;\n    }\n\n    function nextPhase() external onlyOwner {\n        require(\n            mintInfo._phase != DynamicONFT.MintPhase.PUBLIC,\n            \"Already in last phase!\"\n        );\n        mintInfo._phase = DynamicONFT.MintPhase(uint8(mintInfo._phase) + 1);\n\n        if (mintInfo._phase == DynamicONFT.MintPhase.WHITELIST) {\n            emit DynamicONFT.WhitelistPhaseStarted();\n        } else {\n            emit DynamicONFT.PublicPhaseStarted();\n        }\n    }\n\n    function emergencyDisableMint() external onlyOwner {\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n    }\n\n    function addToWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = true;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function removeFromWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = false;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        _requireOwned(tokenId);\n\n        return\n            string(\n                abi.encodePacked(baseTokenURI, tokenState[tokenId],\"/omni-nad-\", tokenId, \".json\")\n            );\n    }\n\n    function _mint() internal {\n        require(\n            mintInfo._maxSupply >= mintInfo._totalSupply,\n            \"Max supply reached!\"\n        );\n        require(!_hasMinted[msg.sender], \"User already minted!\");\n\n        unchecked {\n            ++mintInfo._totalSupply;\n        }\n\n        _hasMinted[msg.sender] = true;\n        tokenState[mintInfo._totalSupply] = DynamicONFT.TokenState.MINTED;\n        \n        _mint(msg.sender, mintInfo._totalSupply);\n    }\n\n    function publicMint() external isNotSmartContract {\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.PUBLIC,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.PublicMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function whitelistMint() external isNotSmartContract {\n        require(_isWhitelisted[msg.sender], \"User is not whitelisted!\");\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.WHITELIST,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.WhitelistMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function send(\n        SendParam memory _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\n\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\n            _sendParam.tokenId,\n            tokenState[_sendParam.tokenId]\n        );\n        delete tokenState[_sendParam.tokenId];\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\n            _sendParam\n        );\n\n        msgReceipt = _lzSend(\n            _sendParam.dstEid,\n            message,\n            options,\n            _fee,\n            _refundAddress\n        );\n\n        emit ONFTSent(\n            msgReceipt.guid,\n            _sendParam.dstEid,\n            msg.sender,\n            _sendParam.tokenId\n        );\n    }\n\n    function _credit(\n        address _to,\n        uint256 _encodedTokenInfo,\n        uint32 /*_srcEid*/\n    ) internal override {\n        \n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\n            _encodedTokenInfo\n        );\n        uint8 _evolvedState = uint8(_receivedState);\n\n        if(_evolvedState < 3)\n        {\n            _evolvedState += 1;\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\n        }\n\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\n\n        _mint(_to, _tokenId);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "evm.methodIdentifiers"
        ]
      }
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "contracts\\interfaces\\IOmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\nimport { SendParam, MessagingFee, MessagingReceipt } from \"../lz/onft/interfaces/IONFT721.sol\";\r\n\r\npragma solidity ^0.8.22;\r\n\r\ninterface IOmniNadsMinter {\r\n    function whitelistMint() external;\r\n    function publicMint() external;\r\n    function emergencyDisableMint() external;\r\n    function nextPhase() external;\r\n    function addToWhitelist(address _address) external;\r\n    function removeFromWhitelist(address _address) external;\r\n}\r\n"
    },
    "contracts\\libs\\DynamicONFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.22;\r\n\r\n\r\nlibrary DynamicONFT {\r\n\r\n    enum TokenState {\r\n        NIL,\r\n        MINTED,\r\n        EVOLVED,\r\n        ULTIMATE\r\n    }\r\n\r\n    enum MintPhase {\r\n        DISABLED,\r\n        WHITELIST,\r\n        PUBLIC\r\n    }\r\n\r\n    struct MintInfo {\r\n        uint16 _maxSupply;\r\n        uint16 _totalSupply;\r\n        MintPhase _phase;\r\n    }\r\n\r\n    event WhitelistUpdated();\r\n    event WhitelistPhaseStarted();\r\n    event PublicPhaseStarted();\r\n    event WhitelistMint(uint indexed tokenId, address indexed minter);\r\n    event PublicMint(uint indexed tokenId, address indexed minter);\r\n    event TokenEvolved(uint indexed tokenId, uint8 indexed evolution);\r\n\r\n\r\n    function decodeTokenInfo(uint256 _encodedTokenInfo) pure internal returns (uint256 _tokenId, TokenState _state)\r\n    {\r\n        uint8 _cachedState = uint8(_encodedTokenInfo % 10);\r\n        if(_cachedState > 3)\r\n        {\r\n            revert(\"Invalid token state\");\r\n        }\r\n        _state = TokenState(_cachedState);\r\n        _tokenId = uint64(_encodedTokenInfo / 10);\r\n    }\r\n\r\n    function encodeTokenInfo(uint256 _tokenId, TokenState _state) pure internal returns (uint _encodedTokenInfo) \r\n    {\r\n        uint8 _cachedState = uint8(_state);\r\n        if(_cachedState > 3)\r\n        {\r\n            revert(\"Invalid token state\");\r\n        }\r\n        _encodedTokenInfo = _tokenId * 10 + _cachedState;\r\n    }\r\n\r\n\r\n}"
    },
    "contracts\\lz\\oapp\\interfaces\\IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"../../protocol/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "contracts\\lz\\oapp\\interfaces\\IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "contracts\\lz\\oapp\\interfaces\\IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "contracts\\lz\\oapp\\interfaces\\IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"../../protocol/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "contracts\\lz\\oapp\\libs\\OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "contracts\\lz\\oapp\\OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "contracts\\lz\\oapp\\OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "contracts\\lz\\oapp\\OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "contracts\\lz\\oapp\\OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"../protocol/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "contracts\\lz\\onft\\interfaces\\IONFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { MessagingFee, MessagingReceipt } from \"../../oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the ONFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination LayerZero EndpointV2 ID.\n    bytes32 to; // Recipient address.\n    uint256 tokenId;\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes onftCmd; // The ONFT command to be executed, unused in default ONFT implementations.\n}\n\n/**\n * @title IONFT\n * @dev Interface for the ONFT721 token.\n * @dev Does not inherit ERC721 to accommodate usage by OFT721Adapter.\n */\ninterface IONFT721 {\n    // Custom error messages\n    error InvalidReceiver();\n    error OnlyNFTOwner(address caller, address owner);\n\n    // Events\n    event ONFTSent(\n        bytes32 indexed guid, // GUID of the ONFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 tokenId // ONFT ID sent.\n    );\n\n    event ONFTReceived(\n        bytes32 indexed guid, // GUID of the ONFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 tokenId // ONFT ID received.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the ONFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     * @dev interfaceId: This specific interface ID is '0x94642228'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other ONFTs.\n     * @dev If a new feature is added to the ONFT cross-chain msg encoding, the version will be incremented.\n     * ie. localONFT version(x,1) CAN send messages to remoteONFT version(x,1)\n     */\n    function onftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the ONFT.\n     * @return token The address of the ERC721 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the ONFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n}\n"
    },
    "contracts\\lz\\onft\\libs\\ONFT721MsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\n/**\n * @title ONFT721MsgCodec\n * @notice Library for encoding and decoding ONFT721 LayerZero messages.\n */\nlibrary ONFT721MsgCodec {\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant TOKEN_ID_OFFSET = 64;\n\n    /**\n     * @dev Encodes an ONFT721 LayerZero message payload.\n     * @param _sendTo The recipient address.\n     * @param _tokenId The ID of the token to transfer.\n     * @param _composeMsg The composed payload.\n     * @return payload The encoded message payload.\n     * @return hasCompose A boolean indicating whether the message payload contains a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint256 _tokenId,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory payload, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        payload = hasCompose\n            ? abi.encodePacked(_sendTo, _tokenId, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _tokenId);\n    }\n\n    /**\n     * @dev Decodes sendTo from the ONFT LayerZero message.\n     * @param _msg The message.\n     * @return The recipient address in bytes32 format.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Decodes tokenId from the ONFT LayerZero message.\n     * @param _msg The message.\n     * @return The ID of the tokens to transfer.\n     */\n    function tokenId(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SEND_TO_OFFSET:TOKEN_ID_OFFSET]));\n    }\n\n    /**\n     * @dev Decodes whether there is a composed payload.\n     * @param _msg The message.\n     * @return A boolean indicating whether the message has a composed payload.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > TOKEN_ID_OFFSET;\n    }\n\n    /**\n     * @dev Decodes the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[TOKEN_ID_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "contracts\\lz\\onft\\ONFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { ONFT721Core } from \"./ONFT721Core.sol\";\n\n/**\n * @title ONFT721 Contract\n * @dev ONFT721 is an ERC-721 token that extends the functionality of the ONFT721Core contract.\n */\nabstract contract ONFT721 is ONFT721Core, ERC721 {\n    string internal baseTokenURI;\n\n    event BaseURISet(string baseURI);\n\n    /**\n     * @dev Constructor for the ONFT721 contract.\n     * @param _name The name of the ONFT.\n     * @param _symbol The symbol of the ONFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC721(_name, _symbol) ONFT721Core(_lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the address of the underlying ERC721 implementation (ie. this contract).\n     */\n    function token() external view returns (address) {\n        return address(this);\n    }\n\n    function setBaseURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n        emit BaseURISet(baseTokenURI);\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @notice Indicates whether the ONFT721 contract requires approval of the 'token()' to send.\n     * @dev In the case of ONFT where the contract IS the token, approval is NOT required.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    function _debit(address _from, uint256 _tokenId, uint32 /*_dstEid*/) internal virtual override {\n        if (_from != ERC721.ownerOf(_tokenId)) revert OnlyNFTOwner(_from, ERC721.ownerOf(_tokenId));\n        _burn(_tokenId);\n    }\n\n    function _credit(address _to, uint256 _tokenId, uint32 /*_srcEid*/) internal virtual override {\n        _mint(_to, _tokenId);\n    }\n}\n"
    },
    "contracts\\lz\\onft\\ONFT721Core.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { OApp, Origin } from \"../oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"../oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"../oapp/interfaces/IOAppMsgInspector.sol\";\nimport { OAppPreCrimeSimulator } from \"../precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IONFT721, MessagingFee, MessagingReceipt, SendParam } from \"./interfaces/IONFT721.sol\";\nimport { ONFT721MsgCodec } from \"./libs/ONFT721MsgCodec.sol\";\n\n/**\n * @title ONFT721Core\n * @dev Abstract contract for an ONFT721 token.\n */\nabstract contract ONFT721Core is IONFT721, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using ONFT721MsgCodec for bytes;\n    using ONFT721MsgCodec for bytes32;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_COMPOSE = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _lzEndpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _lzEndpoint, address _delegate) Ownable(_delegate) OApp(_lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves interfaceID and the version of the ONFT.\n     * @return interfaceId The interface ID (0x23e18da6).\n     * @return version The version.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other ONFTs.\n     * @dev If a new feature is added to the ONFT cross-chain msg encoding, the version will be incremented.\n     * @dev ie. localONFT version(x,1) CAN send messages to remoteONFT version(x,1)\n     */\n    function onftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IONFT721).interfaceId, 1);\n    }\n\n    /**\n     * @notice Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam);\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt) {\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam);\n\n        // @dev Sends the message to the LayerZero Endpoint, returning the MessagingReceipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        emit ONFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, _sendParam.tokenId);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam memory _sendParam\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        if (_sendParam.to == bytes32(0)) revert InvalidReceiver();\n        bool hasCompose;\n        (message, hasCompose) = ONFT721MsgCodec.encode(_sendParam.to, _sendParam.tokenId, _sendParam.composeMsg);\n        uint16 msgType = hasCompose ? SEND_AND_COMPOSE : SEND;\n\n        options = this.combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        address inspector = msgInspector; // caches the msgInspector to avoid potential double storage read\n        if (inspector != address(0)) IOAppMsgInspector(inspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        uint256 tokenId = _message.tokenId();\n\n        _credit(toAddress, tokenId, _origin.srcEid);\n\n        emit ONFTReceived(_guid, _origin.srcEid, toAddress, tokenId);\n    }\n\n    /*\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    function _debit(address /*_from*/, uint256 /*_tokenId*/, uint32 /*_dstEid*/) internal virtual;\n\n    function _credit(address /*_to*/, uint256 /*_tokenId*/, uint32 /*_srcEid*/) internal virtual;\n}\n"
    },
    "contracts\\lz\\precrime\\interfaces\\IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "contracts\\lz\\precrime\\interfaces\\IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "contracts\\lz\\precrime\\libs\\Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"../../protocol/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"../../protocol/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "contracts\\lz\\precrime\\OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "contracts\\lz\\precrime\\PreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { BytesLib } from \"../solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { ILayerZeroEndpointV2 } from \"../protocol/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IPreCrime, PreCrimePeer } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\nimport { InboundPacket, PacketDecoder } from \"./libs/Packet.sol\";\n\n// @dev WARNING: This preCrime contract is for testing only, it is not secure and should not be used in production.\n// @dev This is not fully implemented/audited/tested\nabstract contract PreCrime is Ownable, IPreCrime {\n    using BytesLib for bytes;\n\n    uint16 internal constant CONFIG_VERSION = 2;\n    address internal constant OFF_CHAIN_CALLER = address(0xDEAD);\n\n    address internal immutable lzEndpoint;\n    address public immutable simulator;\n    address public immutable oApp;\n\n    // preCrime config\n    uint64 public maxBatchSize;\n    PreCrimePeer[] internal preCrimePeers;\n\n    /// @dev getConfig(), simulate() and preCrime() are not view functions because it is more flexible to be able to\n    ///      update state for some complex logic. So onlyOffChain() modifier is to make sure they are only called\n    ///      by the off-chain.\n    modifier onlyOffChain() {\n        if (msg.sender != OFF_CHAIN_CALLER) revert OnlyOffChain();\n        _;\n    }\n\n    constructor(address _endpoint, address _simulator) {\n        lzEndpoint = _endpoint;\n        simulator = _simulator;\n        oApp = IOAppPreCrimeSimulator(_simulator).oApp();\n    }\n\n    function setMaxBatchSize(uint64 _maxBatchSize) external onlyOwner {\n        maxBatchSize = _maxBatchSize;\n    }\n\n    function setPreCrimePeers(PreCrimePeer[] calldata _preCrimePeers) external onlyOwner {\n        delete preCrimePeers;\n        for (uint256 i = 0; i < _preCrimePeers.length; ++i) {\n            preCrimePeers.push(_preCrimePeers[i]);\n        }\n    }\n\n    function getPreCrimePeers() external view returns (PreCrimePeer[] memory) {\n        return preCrimePeers;\n    }\n\n    function getConfig(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external onlyOffChain returns (bytes memory) {\n        bytes memory config = abi.encodePacked(CONFIG_VERSION, maxBatchSize);\n\n        // if no packets, return config with all peers\n        PreCrimePeer[] memory peers = _packets.length == 0\n            ? preCrimePeers\n            : _getPreCrimePeers(PacketDecoder.decode(_packets, _packetMsgValues));\n\n        if (peers.length > 0) {\n            uint16 size = uint16(peers.length);\n            config = abi.encodePacked(config, size);\n\n            for (uint256 i = 0; i < size; ++i) {\n                config = abi.encodePacked(config, peers[i].eid, peers[i].preCrime, peers[i].oApp);\n            }\n        }\n\n        return config;\n    }\n\n    // @dev _packetMsgValues refers to the 'lzReceive' option passed per packet\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable override onlyOffChain returns (bytes memory) {\n        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);\n        _checkPacketSizeAndOrder(packets);\n        return _simulate(packets);\n    }\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external onlyOffChain {\n        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);\n        uint32[] memory eids = new uint32[](_simulations.length);\n        bytes[] memory simulations = new bytes[](_simulations.length);\n\n        for (uint256 i = 0; i < _simulations.length; ++i) {\n            bytes calldata simulation = _simulations[i];\n            eids[i] = uint32(bytes4(simulation[0:4]));\n            simulations[i] = simulation[4:];\n        }\n        _checkResultsCompleteness(packets, eids);\n\n        _preCrime(packets, eids, simulations);\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor) {\n        return (2, 0);\n    }\n\n    function _checkResultsCompleteness(InboundPacket[] memory _packets, uint32[] memory _eids) internal {\n        // check if all peers result included\n        if (_packets.length > 0) {\n            PreCrimePeer[] memory peers = _getPreCrimePeers(_packets);\n            for (uint256 i = 0; i < peers.length; i++) {\n                uint32 expectedEid = peers[i].eid;\n                if (!_isContain(_eids, expectedEid)) revert SimulationResultNotFound(expectedEid);\n            }\n        }\n\n        // check if local result included\n        uint32 localEid = _getLocalEid();\n        if (!_isContain(_eids, localEid)) revert SimulationResultNotFound(localEid);\n    }\n\n    function _isContain(uint32[] memory _array, uint32 _item) internal pure returns (bool) {\n        for (uint256 i = 0; i < _array.length; i++) {\n            if (_array[i] == _item) return true;\n        }\n        return false;\n    }\n\n    function _checkPacketSizeAndOrder(InboundPacket[] memory _packets) internal view {\n        if (_packets.length > maxBatchSize) revert PacketOversize(maxBatchSize, _packets.length);\n\n        // check packets nonce, sequence order\n        // packets should ordered in ascending order by srcEid, sender, nonce\n        if (_packets.length > 0) {\n            uint32 srcEid;\n            bytes32 sender;\n            uint64 nonce;\n            for (uint256 i = 0; i < _packets.length; i++) {\n                InboundPacket memory packet = _packets[i];\n\n                // skip if not from trusted peer\n                if (!IOAppPreCrimeSimulator(simulator).isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n                if (\n                    packet.origin.srcEid < srcEid || (packet.origin.srcEid == srcEid && packet.origin.sender < sender)\n                ) {\n                    revert PacketUnsorted();\n                } else if (packet.origin.srcEid != srcEid || packet.origin.sender != sender) {\n                    // start from a new chain or a new source oApp\n                    srcEid = packet.origin.srcEid;\n                    sender = packet.origin.sender;\n                    nonce = _getInboundNonce(srcEid, sender);\n                }\n                // TODO ??\n                // Wont the nonce order not matter and enforced at the OApp level? the simulation will revert?\n\n                // the following packet's nonce add 1 in order\n                if (packet.origin.nonce != ++nonce) revert PacketUnsorted();\n            }\n        }\n    }\n\n    function _simulate(InboundPacket[] memory _packets) internal virtual returns (bytes memory) {\n        (bool success, bytes memory returnData) = simulator.call{ value: msg.value }(\n            abi.encodeWithSelector(IOAppPreCrimeSimulator.lzReceiveAndRevert.selector, _packets)\n        );\n\n        bytes memory result = _parseRevertResult(success, returnData);\n        return abi.encodePacked(_getLocalEid(), result); // add localEid at the first of the result\n    }\n\n    function _parseRevertResult(bool _success, bytes memory _returnData) internal pure returns (bytes memory result) {\n        // should always revert with LzReceiveRevert\n        if (_success) revert SimulationFailed(\"no revert\");\n\n        // if not expected selector, bubble up error\n        if (bytes4(_returnData) != IOAppPreCrimeSimulator.SimulationResult.selector) {\n            revert SimulationFailed(_returnData);\n        }\n\n        // Slice the sighash. Remove the selector which is the first 4 bytes\n        result = _returnData.slice(4, _returnData.length - 4);\n        result = abi.decode(result, (bytes));\n    }\n\n    // to be compatible with EndpointV1\n    function _getLocalEid() internal view virtual returns (uint32) {\n        return ILayerZeroEndpointV2(lzEndpoint).eid();\n    }\n\n    // to be compatible with EndpointV1\n    function _getInboundNonce(uint32 _srcEid, bytes32 _sender) internal view virtual returns (uint64) {\n        return ILayerZeroEndpointV2(lzEndpoint).inboundNonce(oApp, _srcEid, _sender);\n    }\n\n    // ----------------- to be implemented -----------------\n    function buildSimulationResult() external view virtual override returns (bytes memory);\n\n    function _getPreCrimePeers(InboundPacket[] memory _packets) internal virtual returns (PreCrimePeer[] memory peers);\n\n    function _preCrime(\n        InboundPacket[] memory _packets,\n        uint32[] memory _eids,\n        bytes[] memory _simulations\n    ) internal virtual;\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "contracts\\lz\\protocol\\interfaces\\ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts\\lz\\protocol\\messagelib\\libs\\AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "contracts\\lz\\protocol\\messagelib\\libs\\PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"./AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "contracts\\lz\\solidity-bytes-utils\\contracts\\BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts\\OmniNadsConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport \"./lz/onft/ONFT721.sol\";\r\nimport { SendParam, MessagingFee, MessagingReceipt } from \"./lz/onft/interfaces/IONFT721.sol\";\r\nimport \"./libs/DynamicONFT.sol\";\r\n\r\n\r\n\r\ncontract OmniNadsConsumer is ONFT721 {\r\n\r\n\r\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\r\n\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _lzEndpoint,\r\n        address _delegate\r\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) { }\r\n\r\n    \r\n\r\n    function send(\r\n        SendParam memory _sendParam,\r\n        MessagingFee calldata _fee,\r\n        address _refundAddress\r\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\r\n        \r\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\r\n\r\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\r\n            _sendParam.tokenId,\r\n            tokenState[_sendParam.tokenId]\r\n        );\r\n        delete tokenState[_sendParam.tokenId];\r\n\r\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\r\n            _sendParam\r\n        );\r\n\r\n        msgReceipt = _lzSend(\r\n            _sendParam.dstEid,\r\n            message,\r\n            options,\r\n            _fee,\r\n            _refundAddress\r\n        );\r\n\r\n        emit ONFTSent(\r\n            msgReceipt.guid,\r\n            _sendParam.dstEid,\r\n            msg.sender,\r\n            _sendParam.tokenId\r\n        );\r\n    }\r\n\r\n    function _credit(\r\n        address _to,\r\n        uint256 _encodedTokenInfo,\r\n        uint32 /*_srcEid*/\r\n    ) internal override {\r\n        \r\n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\r\n            _encodedTokenInfo\r\n        );\r\n        uint8 _evolvedState = uint8(_receivedState);\r\n\r\n        if(_evolvedState < 3)\r\n        {\r\n            _evolvedState += 1;\r\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\r\n        }\r\n\r\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\r\n\r\n        _mint(_to, _tokenId);\r\n    }\r\n\r\n}"
    },
    "contracts\\OmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport \"./lz/onft/ONFT721.sol\";\r\nimport \"./interfaces/IOmniNadsMinter.sol\";\r\nimport \"./libs/DynamicONFT.sol\";\r\n\r\n\r\ncontract OmniNadsMinter is IOmniNadsMinter, ONFT721 {\r\n\r\n\r\n    DynamicONFT.MintInfo public mintInfo;\r\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\r\n    mapping(address => bool) private _hasMinted;\r\n    mapping(address => bool) private _isWhitelisted;\r\n    \r\n\r\n\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _lzEndpoint,\r\n        address _delegate,\r\n        uint16 _maxSupply,\r\n        address[] memory _whitelistedAddresses\r\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) {\r\n\r\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\r\n        mintInfo._maxSupply = _maxSupply;\r\n        mintInfo._totalSupply = 0;\r\n\r\n        for (uint i = 0; i < _whitelistedAddresses.length; ) {\r\n            _isWhitelisted[_whitelistedAddresses[i]] = true;\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    modifier isNotSmartContract() {\r\n        require(\r\n            msg.sender.code.length == 0,\r\n            \"Smart contract mint is not allowed!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function nextPhase() external onlyOwner {\r\n        require(\r\n            mintInfo._phase != DynamicONFT.MintPhase.PUBLIC,\r\n            \"Already in last phase!\"\r\n        );\r\n        mintInfo._phase = DynamicONFT.MintPhase(uint8(mintInfo._phase) + 1);\r\n\r\n        if (mintInfo._phase == DynamicONFT.MintPhase.WHITELIST) {\r\n            emit DynamicONFT.WhitelistPhaseStarted();\r\n        } else {\r\n            emit DynamicONFT.PublicPhaseStarted();\r\n        }\r\n    }\r\n\r\n    function emergencyDisableMint() external onlyOwner {\r\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\r\n    }\r\n\r\n    function addToWhitelist(address _address) external override onlyOwner {\r\n        _isWhitelisted[_address] = true;\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    function removeFromWhitelist(address _address) external override onlyOwner {\r\n        _isWhitelisted[_address] = false;\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view override returns (string memory) {\r\n        _requireOwned(tokenId);\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(baseTokenURI, tokenState[tokenId],\"/omni-nad-\", tokenId, \".json\")\r\n            );\r\n    }\r\n\r\n    function _mint() internal {\r\n        require(\r\n            mintInfo._maxSupply >= mintInfo._totalSupply,\r\n            \"Max supply reached!\"\r\n        );\r\n        require(!_hasMinted[msg.sender], \"User already minted!\");\r\n\r\n        unchecked {\r\n            ++mintInfo._totalSupply;\r\n        }\r\n\r\n        _hasMinted[msg.sender] = true;\r\n        tokenState[mintInfo._totalSupply] = DynamicONFT.TokenState.MINTED;\r\n        \r\n        _mint(msg.sender, mintInfo._totalSupply);\r\n    }\r\n\r\n    function publicMint() external isNotSmartContract {\r\n        require(\r\n            mintInfo._phase == DynamicONFT.MintPhase.PUBLIC,\r\n            \"Not in whitelist phase!\"\r\n        );\r\n        _mint();\r\n        emit DynamicONFT.PublicMint(mintInfo._totalSupply, msg.sender);\r\n    }\r\n\r\n    function whitelistMint() external isNotSmartContract {\r\n        require(_isWhitelisted[msg.sender], \"User is not whitelisted!\");\r\n        require(\r\n            mintInfo._phase == DynamicONFT.MintPhase.WHITELIST,\r\n            \"Not in whitelist phase!\"\r\n        );\r\n        _mint();\r\n        emit DynamicONFT.WhitelistMint(mintInfo._totalSupply, msg.sender);\r\n    }\r\n\r\n    function send(\r\n        SendParam memory _sendParam,\r\n        MessagingFee calldata _fee,\r\n        address _refundAddress\r\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\r\n\r\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\r\n\r\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\r\n            _sendParam.tokenId,\r\n            tokenState[_sendParam.tokenId]\r\n        );\r\n        delete tokenState[_sendParam.tokenId];\r\n\r\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\r\n            _sendParam\r\n        );\r\n\r\n        msgReceipt = _lzSend(\r\n            _sendParam.dstEid,\r\n            message,\r\n            options,\r\n            _fee,\r\n            _refundAddress\r\n        );\r\n\r\n        emit ONFTSent(\r\n            msgReceipt.guid,\r\n            _sendParam.dstEid,\r\n            msg.sender,\r\n            _sendParam.tokenId\r\n        );\r\n    }\r\n\r\n    function _credit(\r\n        address _to,\r\n        uint256 _encodedTokenInfo,\r\n        uint32 /*_srcEid*/\r\n    ) internal override {\r\n        \r\n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\r\n            _encodedTokenInfo\r\n        );\r\n        uint8 _evolvedState = uint8(_receivedState);\r\n\r\n        if(_evolvedState < 3)\r\n        {\r\n            _evolvedState += 1;\r\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\r\n        }\r\n\r\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\r\n\r\n        _mint(_to, _tokenId);\r\n    }\r\n\r\n}"
    },
    "OmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.22;\r\n\r\nimport \"./lz/onft/ONFT721.sol\";\r\nimport \"./interfaces/IOmniNadsMinter.sol\";\r\nimport \"./libs/DynamicONFT.sol\";\r\n\r\n\r\ncontract OmniNadsMinter is IOmniNadsMinter, ONFT721 {\r\n\r\n\r\n    DynamicONFT.MintInfo public mintInfo;\r\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\r\n    mapping(address => bool) private _hasMinted;\r\n    mapping(address => bool) private _isWhitelisted;\r\n    \r\n\r\n\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _lzEndpoint,\r\n        address _delegate,\r\n        uint16 _maxSupply,\r\n        address[] memory _whitelistedAddresses\r\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) {\r\n\r\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\r\n        mintInfo._maxSupply = _maxSupply;\r\n        mintInfo._totalSupply = 0;\r\n\r\n        for (uint i = 0; i < _whitelistedAddresses.length; ) {\r\n            _isWhitelisted[_whitelistedAddresses[i]] = true;\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    modifier isNotSmartContract() {\r\n        require(\r\n            msg.sender.code.length == 0,\r\n            \"Smart contract mint is not allowed!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function nextPhase() external onlyOwner {\r\n        require(\r\n            mintInfo._phase != DynamicONFT.MintPhase.PUBLIC,\r\n            \"Already in last phase!\"\r\n        );\r\n        mintInfo._phase = DynamicONFT.MintPhase(uint8(mintInfo._phase) + 1);\r\n\r\n        if (mintInfo._phase == DynamicONFT.MintPhase.WHITELIST) {\r\n            emit DynamicONFT.WhitelistPhaseStarted();\r\n        } else {\r\n            emit DynamicONFT.PublicPhaseStarted();\r\n        }\r\n    }\r\n\r\n    function emergencyDisableMint() external onlyOwner {\r\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\r\n    }\r\n\r\n    function addToWhitelist(address _address) external override onlyOwner {\r\n        _isWhitelisted[_address] = true;\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    function removeFromWhitelist(address _address) external override onlyOwner {\r\n        _isWhitelisted[_address] = false;\r\n        emit DynamicONFT.WhitelistUpdated();\r\n    }\r\n\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view override returns (string memory) {\r\n        _requireOwned(tokenId);\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(baseTokenURI, tokenState[tokenId],\"/omni-nad-\", tokenId, \".json\")\r\n            );\r\n    }\r\n\r\n    function _mint() internal {\r\n        require(\r\n            mintInfo._maxSupply >= mintInfo._totalSupply,\r\n            \"Max supply reached!\"\r\n        );\r\n        require(!_hasMinted[msg.sender], \"User already minted!\");\r\n\r\n        unchecked {\r\n            ++mintInfo._totalSupply;\r\n        }\r\n\r\n        _hasMinted[msg.sender] = true;\r\n        tokenState[mintInfo._totalSupply] = DynamicONFT.TokenState.MINTED;\r\n        \r\n        _mint(msg.sender, mintInfo._totalSupply);\r\n    }\r\n\r\n    function publicMint() external isNotSmartContract {\r\n        require(\r\n            mintInfo._phase == DynamicONFT.MintPhase.PUBLIC,\r\n            \"Not in whitelist phase!\"\r\n        );\r\n        _mint();\r\n        emit DynamicONFT.PublicMint(mintInfo._totalSupply, msg.sender);\r\n    }\r\n\r\n    function whitelistMint() external isNotSmartContract {\r\n        require(_isWhitelisted[msg.sender], \"User is not whitelisted!\");\r\n        require(\r\n            mintInfo._phase == DynamicONFT.MintPhase.WHITELIST,\r\n            \"Not in whitelist phase!\"\r\n        );\r\n        _mint();\r\n        emit DynamicONFT.WhitelistMint(mintInfo._totalSupply, msg.sender);\r\n    }\r\n\r\n    function send(\r\n        SendParam memory _sendParam,\r\n        MessagingFee calldata _fee,\r\n        address _refundAddress\r\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\r\n\r\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\r\n\r\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\r\n            _sendParam.tokenId,\r\n            tokenState[_sendParam.tokenId]\r\n        );\r\n        delete tokenState[_sendParam.tokenId];\r\n\r\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\r\n            _sendParam\r\n        );\r\n\r\n        msgReceipt = _lzSend(\r\n            _sendParam.dstEid,\r\n            message,\r\n            options,\r\n            _fee,\r\n            _refundAddress\r\n        );\r\n\r\n        emit ONFTSent(\r\n            msgReceipt.guid,\r\n            _sendParam.dstEid,\r\n            msg.sender,\r\n            _sendParam.tokenId\r\n        );\r\n    }\r\n\r\n    function _credit(\r\n        address _to,\r\n        uint256 _encodedTokenInfo,\r\n        uint32 /*_srcEid*/\r\n    ) internal override {\r\n        \r\n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\r\n            _encodedTokenInfo\r\n        );\r\n        uint8 _evolvedState = uint8(_receivedState);\r\n\r\n        if(_evolvedState < 3)\r\n        {\r\n            _evolvedState += 1;\r\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\r\n        }\r\n\r\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\r\n\r\n        _mint(_to, _tokenId);\r\n    }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "evm.bytecode",
          "evm.bytecode.sourceMap"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {}
  }
}
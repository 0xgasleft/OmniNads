{
  "language": "Solidity",
  "sources": {
    "contracts/OmniNadsConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport \"@layerzerolabs/onft-evm/contracts/onft721/ONFT721.sol\";\nimport { SendParam, MessagingFee, MessagingReceipt } from \"@layerzerolabs/onft-evm/contracts/onft721/interfaces/IONFT721.sol\";\nimport \"./libs/DynamicONFT.sol\";\n\n\n\ncontract OmniNadsConsumer is ONFT721 {\n\n\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\n\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) { }\n\n    \n\n    function send(\n        SendParam memory _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\n        \n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\n            _sendParam.tokenId,\n            tokenState[_sendParam.tokenId]\n        );\n        delete tokenState[_sendParam.tokenId];\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\n            _sendParam\n        );\n\n        msgReceipt = _lzSend(\n            _sendParam.dstEid,\n            message,\n            options,\n            _fee,\n            _refundAddress\n        );\n\n        emit ONFTSent(\n            msgReceipt.guid,\n            _sendParam.dstEid,\n            msg.sender,\n            _sendParam.tokenId\n        );\n    }\n\n    function _credit(\n        address _to,\n        uint256 _encodedTokenInfo,\n        uint32 /*_srcEid*/\n    ) internal override {\n        \n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\n            _encodedTokenInfo\n        );\n        uint8 _evolvedState = uint8(_receivedState);\n\n        if(_evolvedState < 3)\n        {\n            _evolvedState += 1;\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\n        }\n\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\n\n        _mint(_to, _tokenId);\n    }\n\n}"
    },
    "contracts/OmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport \"@layerzerolabs/onft-evm/contracts/onft721/ONFT721.sol\";\nimport \"./interfaces/IOmniNadsMinter.sol\";\nimport \"./libs/DynamicONFT.sol\";\n\n\ncontract OmniNadsMinter is IOmniNadsMinter, ONFT721 {\n\n\n    DynamicONFT.MintInfo public mintInfo;\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\n    mapping(address => bool) private _hasMinted;\n    mapping(address => bool) private _isWhitelisted;\n    \n\n\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate,\n        uint16 _maxSupply,\n        address[] memory _whitelistedAddresses\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) {\n\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n        mintInfo._maxSupply = _maxSupply;\n        mintInfo._totalSupply = 0;\n\n        for (uint i = 0; i < _whitelistedAddresses.length; ) {\n            _isWhitelisted[_whitelistedAddresses[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    modifier isNotSmartContract() {\n        require(\n            msg.sender.code.length == 0,\n            \"Smart contract mint is not allowed!\"\n        );\n        _;\n    }\n\n    function nextPhase() external onlyOwner {\n        require(\n            mintInfo._phase != DynamicONFT.MintPhase.PUBLIC,\n            \"Already in last phase!\"\n        );\n        mintInfo._phase = DynamicONFT.MintPhase(uint8(mintInfo._phase) + 1);\n\n        if (mintInfo._phase == DynamicONFT.MintPhase.WHITELIST) {\n            emit DynamicONFT.WhitelistPhaseStarted();\n        } else {\n            emit DynamicONFT.PublicPhaseStarted();\n        }\n    }\n\n    function emergencyDisableMint() external onlyOwner {\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n    }\n\n    function addToWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = true;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function removeFromWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = false;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        _requireOwned(tokenId);\n\n        return\n            string(\n                abi.encodePacked(baseTokenURI, tokenState[tokenId],\"/omni-nad-\", tokenId, \".json\")\n            );\n    }\n\n    function _mint() internal {\n        require(\n            mintInfo._maxSupply >= mintInfo._totalSupply,\n            \"Max supply reached!\"\n        );\n        require(!_hasMinted[msg.sender], \"User already minted!\");\n\n        unchecked {\n            ++mintInfo._totalSupply;\n        }\n\n        _hasMinted[msg.sender] = true;\n        tokenState[mintInfo._totalSupply] = DynamicONFT.TokenState.MINTED;\n        \n        _mint(msg.sender, mintInfo._totalSupply);\n    }\n\n    function publicMint() external isNotSmartContract {\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.PUBLIC,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.PublicMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function whitelistMint() external isNotSmartContract {\n        require(_isWhitelisted[msg.sender], \"User is not whitelisted!\");\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.WHITELIST,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.WhitelistMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function send(\n        SendParam memory _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\n\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\n            _sendParam.tokenId,\n            tokenState[_sendParam.tokenId]\n        );\n        delete tokenState[_sendParam.tokenId];\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\n            _sendParam\n        );\n\n        msgReceipt = _lzSend(\n            _sendParam.dstEid,\n            message,\n            options,\n            _fee,\n            _refundAddress\n        );\n\n        emit ONFTSent(\n            msgReceipt.guid,\n            _sendParam.dstEid,\n            msg.sender,\n            _sendParam.tokenId\n        );\n    }\n\n    function _credit(\n        address _to,\n        uint256 _encodedTokenInfo,\n        uint32 /*_srcEid*/\n    ) internal override {\n        \n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\n            _encodedTokenInfo\n        );\n        uint8 _evolvedState = uint8(_receivedState);\n\n        if(_evolvedState < 3)\n        {\n            _evolvedState += 1;\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\n        }\n\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\n\n        _mint(_to, _tokenId);\n    }\n\n}"
    },
    "contracts/interfaces/IOmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport { SendParam, MessagingFee, MessagingReceipt } from \"@layerzerolabs/onft-evm/contracts/onft721/interfaces/IONFT721.sol\";\n\npragma solidity ^0.8.22;\n\ninterface IOmniNadsMinter {\n    function whitelistMint() external;\n    function publicMint() external;\n    function emergencyDisableMint() external;\n    function nextPhase() external;\n    function addToWhitelist(address _address) external;\n    function removeFromWhitelist(address _address) external;\n}"
    },
    "contracts/libs/DynamicONFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\n\nlibrary DynamicONFT {\n\n    enum TokenState {\n        NIL,\n        MINTED,\n        EVOLVED,\n        ULTIMATE\n    }\n\n    enum MintPhase {\n        DISABLED,\n        WHITELIST,\n        PUBLIC\n    }\n\n    struct MintInfo {\n        uint16 _maxSupply;\n        uint16 _totalSupply;\n        MintPhase _phase;\n    }\n\n    event WhitelistUpdated();\n    event WhitelistPhaseStarted();\n    event PublicPhaseStarted();\n    event WhitelistMint(uint indexed tokenId, address indexed minter);\n    event PublicMint(uint indexed tokenId, address indexed minter);\n    event TokenEvolved(uint indexed tokenId, uint8 indexed evolution);\n\n\n    function decodeTokenInfo(uint256 _encodedTokenInfo) pure internal returns (uint256 _tokenId, TokenState _state)\n    {\n        uint8 _cachedState = uint8(_encodedTokenInfo % 10);\n        if(_cachedState > 3)\n        {\n            revert(\"Invalid token state\");\n        }\n        _state = TokenState(_cachedState);\n        _tokenId = uint64(_encodedTokenInfo / 10);\n    }\n\n    function encodeTokenInfo(uint256 _tokenId, TokenState _state) pure internal returns (uint _encodedTokenInfo) \n    {\n        uint8 _cachedState = uint8(_state);\n        if(_cachedState > 3)\n        {\n            revert(\"Invalid token state\");\n        }\n        _encodedTokenInfo = _tokenId * 10 + _cachedState;\n    }\n\n\n}"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/Executor.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { IUltraLightNode301 } from \"./uln/uln301/interfaces/IUltraLightNode301.sol\";\nimport { IExecutor } from \"./interfaces/IExecutor.sol\";\nimport { IExecutorFeeLib } from \"./interfaces/IExecutorFeeLib.sol\";\nimport { WorkerUpgradeable } from \"./upgradeable/WorkerUpgradeable.sol\";\n\ninterface ILayerZeroEndpointV2 {\n    function eid() external view returns (uint32);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    function lzComposeAlert(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external;\n}\n\ncontract Executor is WorkerUpgradeable, ReentrancyGuardUpgradeable, Proxied, IExecutor {\n    using PacketV1Codec for bytes;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    // endpoint v2\n    address public endpoint;\n    uint32 public localEidV2;\n\n    // endpoint v1\n    address public receiveUln301;\n\n    function initialize(\n        address _endpoint,\n        address _receiveUln301,\n        address[] memory _messageLibs,\n        address _priceFeed,\n        address _roleAdmin,\n        address[] memory _admins\n    ) external proxied initializer {\n        __ReentrancyGuard_init();\n        __Worker_init(_messageLibs, _priceFeed, 12000, _roleAdmin, _admins);\n        endpoint = _endpoint;\n        localEidV2 = ILayerZeroEndpointV2(_endpoint).eid();\n        receiveUln301 = _receiveUln301;\n    }\n\n    function onUpgrade(address _receiveUln301) external proxied {\n        receiveUln301 = _receiveUln301;\n    }\n\n    // --- Admin ---\n    function setDstConfig(DstConfigParam[] memory _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam memory param = _params[i];\n            dstConfig[param.dstEid] = DstConfig(\n                param.lzReceiveBaseGas,\n                param.multiplierBps,\n                param.floorMarginUSD,\n                param.nativeCap,\n                param.lzComposeBaseGas\n            );\n        }\n        emit DstConfigSet(_params);\n    }\n\n    function nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        _nativeDrop(_origin, _dstEid, _oapp, _nativeDropParams, _nativeDropGasLimit);\n    }\n\n    function nativeDropAndExecute301(\n        Origin calldata _origin,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        bytes calldata _packet,\n        uint256 _gasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        _nativeDrop(_origin, _packet.dstEid(), _packet.receiverB20(), _nativeDropParams, _nativeDropGasLimit);\n        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);\n    }\n\n    function execute301(bytes calldata _packet, uint256 _gasLimit) external onlyRole(ADMIN_ROLE) nonReentrant {\n        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);\n    }\n\n    function execute302(ExecutionParams calldata _executionParams) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        try\n            ILayerZeroEndpointV2(endpoint).lzReceive{ value: msg.value, gas: _executionParams.gasLimit }(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.message,\n                _executionParams.extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.gasLimit,\n                msg.value,\n                _executionParams.message,\n                _executionParams.extraData,\n                reason\n            );\n        }\n    }\n\n    function compose302(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        uint256 _gasLimit\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        try\n            ILayerZeroEndpointV2(endpoint).lzCompose{ value: msg.value, gas: _gasLimit }(\n                _from,\n                _to,\n                _guid,\n                _index,\n                _message,\n                _extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzComposeAlert(\n                _from,\n                _to,\n                _guid,\n                _index,\n                _gasLimit,\n                msg.value,\n                _message,\n                _extraData,\n                reason\n            );\n        }\n    }\n\n    function nativeDropAndExecute302(\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        ExecutionParams calldata _executionParams\n    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {\n        uint256 spent = _nativeDrop(\n            _executionParams.origin,\n            localEidV2,\n            _executionParams.receiver,\n            _nativeDropParams,\n            _nativeDropGasLimit\n        );\n\n        uint256 value = msg.value - spent;\n        try\n            ILayerZeroEndpointV2(endpoint).lzReceive{ value: value, gas: _executionParams.gasLimit }(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.message,\n                _executionParams.extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.gasLimit,\n                value,\n                _executionParams.message,\n                _executionParams.extraData,\n                reason\n            );\n        }\n    }\n\n    // --- Message Lib ---\n    function assignJob(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _sender,\n            _calldataSize,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], _options);\n    }\n\n    // assignJob for ReadLib\n    function assignJob(\n        address _sender,\n        bytes calldata _options\n    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParamsForRead memory params = IExecutorFeeLib.FeeParamsForRead(\n            priceFeed,\n            _sender,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[localEidV2], _options);\n    }\n\n    // --- Only ACL ---\n    function getFee(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _sender,\n            _calldataSize,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);\n    }\n\n    function getFee(\n        address _sender,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) whenNotPaused returns (uint256 fee) {\n        IExecutorFeeLib.FeeParamsForRead memory params = IExecutorFeeLib.FeeParamsForRead(\n            priceFeed,\n            _sender,\n            defaultMultiplierBps\n        );\n        fee = IExecutorFeeLib(workerFeeLib).getFee(params, dstConfig[localEidV2], _options);\n    }\n\n    function _nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) internal returns (uint256 spent) {\n        bool[] memory success = new bool[](_nativeDropParams.length);\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            NativeDropParams memory param = _nativeDropParams[i];\n\n            (bool sent, ) = param.receiver.call{ value: param.amount, gas: _nativeDropGasLimit }(\"\");\n\n            success[i] = sent;\n            spent += param.amount;\n        }\n        emit NativeDropApplied(_origin, _dstEid, _oapp, _nativeDropParams, success);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/ExecutorFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroPriceFeed } from \"./interfaces/ILayerZeroPriceFeed.sol\";\nimport { IExecutor } from \"./interfaces/IExecutor.sol\";\nimport { IExecutorFeeLib } from \"./interfaces/IExecutorFeeLib.sol\";\nimport { ExecutorOptions } from \"./libs/ExecutorOptions.sol\";\n\ncontract ExecutorFeeLib is Ownable, IExecutorFeeLib {\n    using ExecutorOptions for bytes;\n\n    uint256 private immutable nativeDecimalsRate;\n    uint32 private immutable localEidV2; // endpoint-v2 only, for read call\n\n    constructor(uint32 _localEidV2, uint256 _nativeDecimalsRate) {\n        localEidV2 = _localEidV2;\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    // ================================ OnlyOwner ================================\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee) {\n        fee = getFee(_params, _dstConfig, _options);\n    }\n\n    function getFeeOnSend(\n        FeeParamsForRead calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee) {\n        fee = getFee(_params, _dstConfig, _options);\n    }\n\n    // ================================ View ================================\n    function getFee(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) public view returns (uint256 fee) {\n        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(_params.dstEid);\n\n        (uint256 totalValue, uint256 totalGas, ) = _decodeExecutorOptions(\n            false,\n            _isV1Eid(_params.dstEid),\n            _dstConfig.lzReceiveBaseGas,\n            _dstConfig.lzComposeBaseGas,\n            _dstConfig.nativeCap,\n            _options\n        );\n\n        (\n            uint256 totalGasFee,\n            uint128 priceRatio,\n            uint128 priceRatioDenominator,\n            uint128 nativePriceUSD\n        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(_params.dstEid, _params.calldataSize, totalGas);\n\n        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;\n\n        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);\n        fee += _convertAndApplyPremiumToValue(totalValue, priceRatio, priceRatioDenominator, multiplierBps);\n    }\n\n    function getFee(\n        FeeParamsForRead calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) public view returns (uint256 fee) {\n        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(localEidV2);\n\n        (uint256 totalValue, uint256 totalGas, uint32 calldataSize) = _decodeExecutorOptions(\n            true,\n            false, // endpoint v2 only\n            _dstConfig.lzReceiveBaseGas,\n            _dstConfig.lzComposeBaseGas,\n            _dstConfig.nativeCap,\n            _options\n        );\n\n        (\n            uint256 totalGasFee,\n            uint128 priceRatio,\n            uint128 priceRatioDenominator,\n            uint128 nativePriceUSD\n        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(localEidV2, calldataSize, totalGas);\n\n        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;\n\n        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);\n        fee += _convertAndApplyPremiumToValue(totalValue, priceRatio, priceRatioDenominator, multiplierBps);\n    }\n\n    // ================================ Internal ================================\n    // @dev decode executor options into dstAmount and totalGas\n    function _decodeExecutorOptions(\n        bool _isRead,\n        bool _v1Eid,\n        uint64 _lzReceiveBaseGas,\n        uint64 _lzComposeBaseGas,\n        uint128 _nativeCap,\n        bytes calldata _options\n    ) internal pure returns (uint256 totalValue, uint256 totalGas, uint32 calldataSize) {\n        ExecutorOptionsAgg memory aggOptions = _parseExecutorOptions(_options, _isRead, _v1Eid, _nativeCap);\n        totalValue = aggOptions.totalValue;\n        calldataSize = aggOptions.calldataSize;\n\n        // lz receive only called once\n        // lz compose can be called multiple times, based on unique index\n        // to simplify the quoting, we add lzComposeBaseGas for each lzComposeOption received\n        // if the same index has multiple compose options, the gas will be added multiple times\n        totalGas = _lzReceiveBaseGas + aggOptions.totalGas + _lzComposeBaseGas * aggOptions.numLzCompose;\n        if (aggOptions.ordered) {\n            totalGas = (totalGas * 102) / 100;\n        }\n    }\n\n    struct ExecutorOptionsAgg {\n        uint256 totalValue;\n        uint256 totalGas;\n        bool ordered;\n        uint32 calldataSize;\n        uint256 numLzCompose;\n    }\n\n    function _parseExecutorOptions(\n        bytes calldata _options,\n        bool _isRead,\n        bool _v1Eid,\n        uint128 _nativeCap\n    ) internal pure returns (ExecutorOptionsAgg memory options) {\n        if (_options.length == 0) {\n            revert Executor_NoOptions();\n        }\n\n        uint256 cursor = 0;\n        uint256 lzReceiveGas;\n        uint32 calldataSize;\n        while (cursor < _options.length) {\n            (uint8 optionType, bytes calldata option, uint256 newCursor) = _options.nextExecutorOption(cursor);\n            cursor = newCursor;\n\n            if (optionType == ExecutorOptions.OPTION_TYPE_LZRECEIVE) {\n                // lzRead does not support lzReceive option\n                if (_isRead) revert Executor_UnsupportedOptionType(optionType);\n                (uint128 gas, uint128 value) = ExecutorOptions.decodeLzReceiveOption(option);\n\n                // endpoint v1 does not support lzReceive with value\n                if (_v1Eid && value > 0) revert Executor_UnsupportedOptionType(optionType);\n\n                options.totalValue += value;\n                lzReceiveGas += gas;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_NATIVE_DROP) {\n                // lzRead does not support nativeDrop option\n                if (_isRead) revert Executor_UnsupportedOptionType(optionType);\n\n                (uint128 nativeDropAmount, ) = ExecutorOptions.decodeNativeDropOption(option);\n                options.totalValue += nativeDropAmount;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_LZCOMPOSE) {\n                // endpoint v1 does not support lzCompose\n                if (_v1Eid) revert Executor_UnsupportedOptionType(optionType);\n\n                (, uint128 gas, uint128 value) = ExecutorOptions.decodeLzComposeOption(option);\n                if (gas == 0) revert Executor_ZeroLzComposeGasProvided();\n\n                options.totalValue += value;\n                options.totalGas += gas;\n                options.numLzCompose++;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION) {\n                options.ordered = true;\n            } else if (optionType == ExecutorOptions.OPTION_TYPE_LZREAD) {\n                if (!_isRead) revert Executor_UnsupportedOptionType(optionType);\n\n                (uint128 gas, uint32 size, uint128 value) = ExecutorOptions.decodeLzReadOption(option);\n                options.totalValue += value;\n                lzReceiveGas += gas;\n                calldataSize += size;\n            } else {\n                revert Executor_UnsupportedOptionType(optionType);\n            }\n        }\n        if (cursor != _options.length) revert Executor_InvalidExecutorOptions(cursor);\n        if (options.totalValue > _nativeCap) revert Executor_NativeAmountExceedsCap(options.totalValue, _nativeCap);\n        if (lzReceiveGas == 0) revert Executor_ZeroLzReceiveGasProvided();\n        if (_isRead && calldataSize == 0) revert Executor_ZeroCalldataSizeProvided();\n        options.totalGas += lzReceiveGas;\n        options.calldataSize = calldataSize;\n    }\n\n    function _applyPremiumToGas(\n        uint256 _fee,\n        uint16 _multiplierBps,\n        uint128 _marginUSD,\n        uint128 _nativePriceUSD\n    ) internal view returns (uint256) {\n        uint256 feeWithMultiplier = (_fee * _multiplierBps) / 10000;\n\n        if (_nativePriceUSD == 0 || _marginUSD == 0) {\n            return feeWithMultiplier;\n        }\n        uint256 feeWithMargin = (_marginUSD * nativeDecimalsRate) / _nativePriceUSD + _fee;\n        return feeWithMargin > feeWithMultiplier ? feeWithMargin : feeWithMultiplier;\n    }\n\n    // includes value and nativeDrop\n    function _convertAndApplyPremiumToValue(\n        uint256 _value,\n        uint128 _ratio,\n        uint128 _denom,\n        uint16 _multiplierBps\n    ) internal pure returns (uint256 fee) {\n        if (_value > 0) {\n            fee = (((_value * _ratio) / _denom) * _multiplierBps) / 10000;\n        }\n    }\n\n    function _isV1Eid(uint32 _eid) internal pure virtual returns (bool) {\n        // v1 eid is < 30000\n        return _eid < 30000;\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor) {\n        return (1, 1);\n    }\n\n    // send funds here to pay for price feed directly\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/MessageLibBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\n/// @dev simply a container of endpoint address and local eid\nabstract contract MessageLibBase {\n    address internal immutable endpoint;\n    uint32 internal immutable localEid;\n\n    error LZ_MessageLib_OnlyEndpoint();\n\n    modifier onlyEndpoint() {\n        if (endpoint != msg.sender) revert LZ_MessageLib_OnlyEndpoint();\n        _;\n    }\n\n    constructor(address _endpoint, uint32 _localEid) {\n        endpoint = _endpoint;\n        localEid = _localEid;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroPriceFeed } from \"./interfaces/ILayerZeroPriceFeed.sol\";\n\nenum ModelType {\n    DEFAULT,\n    ARB_STACK,\n    OP_STACK\n}\n\nstruct SetEidToModelTypeParam {\n    uint32 dstEid;\n    ModelType modelType;\n}\n\n// PriceFeed is updated based on v1 eids\n// v2 eids will fall to the convention of v1 eid + 30,000\ncontract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {\n    uint128 internal PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address updater => bool active) public priceUpdater;\n\n    mapping(uint32 dstEid => Price) internal _defaultModelPrice;\n    ArbitrumPriceExt internal _arbitrumPriceExt;\n\n    uint128 internal _nativePriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    // for the destination endpoint id, return the fee model type\n    mapping(uint32 => ModelType) public eidToModelType;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public proxied initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e20;\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            if (!priceUpdater[msg.sender]) {\n                revert LZ_PriceFeed_OnlyPriceUpdater();\n            }\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // set the fee ModelType for the destination eid\n    function setEidToModelType(SetEidToModelTypeParam[] calldata _params) external onlyOwner {\n        for (uint i = 0; i < _params.length; i++) {\n            eidToModelType[_params[i].dstEid] = _params[i].modelType;\n        }\n    }\n\n    function setEndpoint(address _endpoint) external onlyOwner {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external onlyOwner {\n        Transfer.native(_to, _amount);\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint256 i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.eid, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt calldata _update) external onlyPriceUpdater {\n        _setPrice(_update.eid, _update.price);\n\n        uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n        uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n        _arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n        _arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        _nativePriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ External =====================================\n\n    function estimateFeeOnSend(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external payable returns (uint256, uint128, uint128, uint128) {\n        uint256 fee = getFee(_dstEid, _callDataSize, _gas);\n        if (msg.value < fee) revert LZ_PriceFeed_InsufficientFee(msg.value, fee);\n        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);\n    }\n\n    // ============================ View ==========================================\n\n    // get fee for calling estimateFeeOnSend\n    function getFee(uint32 /*_dstEid*/, uint256 /*_callDataSize*/, uint256 /*_gas*/) public pure returns (uint256) {\n        return 0;\n    }\n\n    function getPriceRatioDenominator() external view returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function nativeTokenPriceUSD() external view returns (uint128) {\n        return _nativePriceUSD;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function arbitrumPriceExt() external view returns (ArbitrumPriceExt memory) {\n        return _arbitrumPriceExt;\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function getPrice(uint32 _dstEid) external view returns (Price memory price) {\n        price = _defaultModelPrice[_dstEid];\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256, uint128, uint128, uint128) {\n        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    // NOTE: to support legacy\n    function getPrice(uint16 _dstEid) external view returns (Price memory price) {\n        price = _defaultModelPrice[_dstEid];\n    }\n\n    // NOTE: to be reverted when endpoint is in sendContext\n    // NOTE: to support legacy\n    function estimateFeeByChain(\n        uint16 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256 fee, uint128 priceRatio) {\n        // legacy if-statement uses very little gas, can keep using it until future upgrade\n        if (_dstEid == 110 || _dstEid == 10143 || _dstEid == 20143) {\n            return _estimateFeeWithArbitrumModel(_dstEid, _callDataSize, _gas);\n        } else if (_dstEid == 111 || _dstEid == 10132 || _dstEid == 20132) {\n            return _estimateFeeWithOptimismModel(_dstEid, _callDataSize, _gas);\n        }\n\n        // fee model type is configured per eid\n        ModelType _modelType = eidToModelType[_dstEid];\n        if (_modelType == ModelType.OP_STACK) {\n            return _estimateFeeWithOptimismModel(_dstEid, _callDataSize, _gas);\n        } else if (_modelType == ModelType.ARB_STACK) {\n            return _estimateFeeWithArbitrumModel(_dstEid, _callDataSize, _gas);\n        } else {\n            return _estimateFeeWithDefaultModel(_dstEid, _callDataSize, _gas);\n        }\n    }\n\n    // ============================ Internal ==========================================\n\n    function _setPrice(uint32 _dstEid, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        _defaultModelPrice[_dstEid] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    function _getL1LookupIdForOptimismModel(uint32 _l2Eid) internal view returns (uint32) {\n        uint32 l2Eid = _l2Eid % 30_000;\n        if (l2Eid == 111) {\n            return 101;\n        } else if (l2Eid == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (l2Eid == 20132) {\n            return 20121; // ethereum-goerli\n        }\n\n        if (eidToModelType[l2Eid] != ModelType.OP_STACK) revert LZ_PriceFeed_NotAnOPStack(_l2Eid);\n        if (l2Eid < 10000) {\n            return 101;\n        } else if (l2Eid < 20000) {\n            return 10161; // ethereum-sepolia\n        } else {\n            return 20121; // ethereum-goerli\n        }\n    }\n\n    function _estimateFeeWithDefaultModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        Price storage remotePrice = _defaultModelPrice[_dstEid];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint256 gasForCallData = _callDataSize * remotePrice.gasPerByte;\n        uint256 remoteFee = (gasForCallData + _gas) * remotePrice.gasPriceInUnit;\n        return ((remoteFee * remotePrice.priceRatio) / PRICE_RATIO_DENOMINATOR, remotePrice.priceRatio);\n    }\n\n    function _estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 priceUSD) {\n        uint32 dstEid = _dstEid % 30_000;\n        if (dstEid == 110 || dstEid == 10143 || dstEid == 20143) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else if (dstEid == 111 || dstEid == 10132 || dstEid == 20132) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        }\n\n        // lookup map stuff\n        ModelType _modelType = eidToModelType[dstEid];\n        if (_modelType == ModelType.OP_STACK) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        } else if (_modelType == ModelType.ARB_STACK) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else {\n            (fee, priceRatio) = _estimateFeeWithDefaultModel(dstEid, _callDataSize, _gas);\n        }\n\n        priceRatioDenominator = PRICE_RATIO_DENOMINATOR;\n        priceUSD = _nativePriceUSD;\n    }\n\n    function _estimateFeeWithOptimismModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        uint32 ethereumId = _getL1LookupIdForOptimismModel(_dstEid);\n\n        // L1 fee\n        Price storage ethereumPrice = _defaultModelPrice[ethereumId];\n        uint256 gasForL1CallData = (_callDataSize * ethereumPrice.gasPerByte) + 3188; // 2100 + 68 * 16\n        uint256 l1Fee = gasForL1CallData * ethereumPrice.gasPriceInUnit;\n\n        // L2 fee\n        Price storage optimismPrice = _defaultModelPrice[_dstEid];\n        uint256 gasForL2CallData = _callDataSize * optimismPrice.gasPerByte;\n        uint256 l2Fee = (gasForL2CallData + _gas) * optimismPrice.gasPriceInUnit;\n\n        uint256 l1FeeInSrcPrice = (l1Fee * ethereumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint256 l2FeeInSrcPrice = (l2Fee * optimismPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint256 gasFee = l1FeeInSrcPrice + l2FeeInSrcPrice;\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function _estimateFeeWithArbitrumModel(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) internal view returns (uint256 fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = _defaultModelPrice[_dstEid];\n\n        // L1 fee\n        uint256 gasForL1CallData = ((_callDataSize * ARBITRUM_COMPRESSION_PERCENT) / 100) *\n            _arbitrumPriceExt.gasPerL1CallDataByte;\n        // L2 Fee\n        uint256 gasForL2CallData = _callDataSize * arbitrumPrice.gasPerByte;\n        uint256 gasFee = (_gas + _arbitrumPriceExt.gasPerL2Tx + gasForL1CallData + gasForL2CallData) *\n            arbitrumPrice.gasPriceInUnit;\n\n        return ((gasFee * arbitrumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR, arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/ReceiveLibBaseE2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IMessageLib, MessageLibType } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { MessageLibBase } from \"./MessageLibBase.sol\";\n\n/// @dev receive-side message library base contract on endpoint v2.\n/// it does not have the complication as the one of endpoint v1, such as nonce, executor whitelist, etc.\nabstract contract ReceiveLibBaseE2 is MessageLibBase, ERC165, IMessageLib {\n    using PacketV1Codec for bytes;\n\n    constructor(address _endpoint) MessageLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid()) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return _interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    function messageLibType() external pure virtual override returns (MessageLibType) {\n        return MessageLibType.Receive;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/SendLibBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroExecutor } from \"./interfaces/ILayerZeroExecutor.sol\";\nimport { ILayerZeroTreasury } from \"./interfaces/ILayerZeroTreasury.sol\";\nimport { SafeCall } from \"./libs/SafeCall.sol\";\nimport { MessageLibBase } from \"./MessageLibBase.sol\";\n\nstruct WorkerOptions {\n    uint8 workerId;\n    bytes options;\n}\n\nstruct SetDefaultExecutorConfigParam {\n    uint32 eid;\n    ExecutorConfig config;\n}\n\nstruct ExecutorConfig {\n    uint32 maxMessageSize;\n    address executor;\n}\n\n/// @dev base contract for both SendLibBaseE1 and SendLibBaseE2\nabstract contract SendLibBase is MessageLibBase, Ownable {\n    using SafeCall for address;\n\n    address private constant DEFAULT_CONFIG = address(0);\n    uint16 internal constant TREASURY_MAX_COPY = 32;\n\n    uint256 internal immutable treasuryGasLimit;\n    uint256 internal treasuryNativeFeeCap;\n\n    // config\n    address public treasury;\n    mapping(address oapp => mapping(uint32 eid => ExecutorConfig)) public executorConfigs;\n\n    // accumulated fees for workers and treasury\n    mapping(address worker => uint256) public fees;\n\n    event ExecutorFeePaid(address executor, uint256 fee);\n    event TreasurySet(address treasury);\n    event DefaultExecutorConfigsSet(SetDefaultExecutorConfigParam[] params);\n    event ExecutorConfigSet(address oapp, uint32 eid, ExecutorConfig config);\n    event TreasuryNativeFeeCapSet(uint256 newTreasuryNativeFeeCap);\n\n    error LZ_MessageLib_InvalidMessageSize(uint256 actual, uint256 max);\n    error LZ_MessageLib_InvalidAmount(uint256 requested, uint256 available);\n    error LZ_MessageLib_TransferFailed();\n    error LZ_MessageLib_InvalidExecutor();\n    error LZ_MessageLib_ZeroMessageSize();\n\n    constructor(\n        address _endpoint,\n        uint32 _localEid,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap\n    ) MessageLibBase(_endpoint, _localEid) {\n        treasuryGasLimit = _treasuryGasLimit;\n        treasuryNativeFeeCap = _treasuryNativeFeeCap;\n    }\n\n    function setDefaultExecutorConfigs(SetDefaultExecutorConfigParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultExecutorConfigParam calldata param = _params[i];\n\n            if (param.config.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();\n            if (param.config.maxMessageSize == 0) revert LZ_MessageLib_ZeroMessageSize();\n\n            executorConfigs[DEFAULT_CONFIG][param.eid] = param.config;\n        }\n        emit DefaultExecutorConfigsSet(_params);\n    }\n\n    /// @dev the new value can not be greater than the old value, i.e. down only\n    function setTreasuryNativeFeeCap(uint256 _newTreasuryNativeFeeCap) external onlyOwner {\n        // assert the new value is no greater than the old value\n        if (_newTreasuryNativeFeeCap > treasuryNativeFeeCap)\n            revert LZ_MessageLib_InvalidAmount(_newTreasuryNativeFeeCap, treasuryNativeFeeCap);\n        treasuryNativeFeeCap = _newTreasuryNativeFeeCap;\n        emit TreasuryNativeFeeCapSet(_newTreasuryNativeFeeCap);\n    }\n\n    // ============================ View ===================================\n    // @dev get the executor config and if not set, return the default config\n    function getExecutorConfig(address _oapp, uint32 _remoteEid) public view returns (ExecutorConfig memory rtnConfig) {\n        ExecutorConfig storage defaultConfig = executorConfigs[DEFAULT_CONFIG][_remoteEid];\n        ExecutorConfig storage customConfig = executorConfigs[_oapp][_remoteEid];\n\n        uint32 maxMessageSize = customConfig.maxMessageSize;\n        rtnConfig.maxMessageSize = maxMessageSize != 0 ? maxMessageSize : defaultConfig.maxMessageSize;\n\n        address executor = customConfig.executor;\n        rtnConfig.executor = executor != address(0x0) ? executor : defaultConfig.executor;\n    }\n\n    // ======================= Internal =======================\n    function _assertMessageSize(uint256 _actual, uint256 _max) internal pure {\n        if (_actual > _max) revert LZ_MessageLib_InvalidMessageSize(_actual, _max);\n    }\n\n    function _payExecutor(\n        address _executor,\n        uint32 _dstEid,\n        address _sender,\n        uint256 _msgSize,\n        bytes memory _executorOptions\n    ) internal returns (uint256 executorFee) {\n        executorFee = ILayerZeroExecutor(_executor).assignJob(_dstEid, _sender, _msgSize, _executorOptions);\n        if (executorFee > 0) {\n            fees[_executor] += executorFee;\n        }\n        emit ExecutorFeePaid(_executor, executorFee);\n    }\n\n    function _payTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal returns (uint256 treasuryNativeFee, uint256 lzTokenFee) {\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.payFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeCall(treasuryGasLimit, 0, TREASURY_MAX_COPY, callData);\n\n            (treasuryNativeFee, lzTokenFee) = _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n            // fee should be in lzTokenFee if payInLzToken, otherwise in native\n            if (treasuryNativeFee > 0) {\n                fees[treasury] += treasuryNativeFee;\n            }\n        }\n    }\n\n    /// @dev the abstract process for quote() is:\n    /// 0/ split out the executor options and options of other workers\n    /// 1/ quote workers\n    /// 2/ quote executor\n    /// 3/ quote treasury\n    /// @return nativeFee, lzTokenFee\n    function _quote(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _msgSize,\n        bool _payInLzToken,\n        bytes calldata _options\n    ) internal view returns (uint256, uint256) {\n        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);\n\n        // quote the verifier used in the library. for ULN, it is a list of DVNs\n        uint256 nativeFee = _quoteVerifier(_sender, _dstEid, validationOptions);\n\n        // quote executor\n        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);\n        // assert msg size\n        _assertMessageSize(_msgSize, config.maxMessageSize);\n\n        nativeFee += ILayerZeroExecutor(config.executor).getFee(_dstEid, _sender, _msgSize, executorOptions);\n\n        // quote treasury\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _quoteTreasury(_sender, _dstEid, nativeFee, _payInLzToken);\n        nativeFee += treasuryNativeFee;\n\n        return (nativeFee, lzTokenFee);\n    }\n\n    /// @dev this interface should be DoS-free if the user is paying with native. properties\n    /// 1/ treasury can return an overly high lzToken fee\n    /// 2/ if treasury returns an overly high native fee, it will be capped by maxNativeFee,\n    ///    which can be reasoned with the configurations\n    /// 3/ the owner can not configure the treasury in a way that force this function to revert\n    function _quoteTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // treasury must be set, and it has to be a contract\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.getFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeStaticCall(\n                treasuryGasLimit,\n                TREASURY_MAX_COPY,\n                callData\n            );\n\n            return _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n        }\n    }\n\n    function _parseTreasuryResult(\n        uint256 _totalNativeFee,\n        bool _payInLzToken,\n        bool _success,\n        bytes memory _result\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // failure, charges nothing\n        if (!_success || _result.length < TREASURY_MAX_COPY) return (0, 0);\n\n        // parse the result\n        uint256 treasureFeeQuote = abi.decode(_result, (uint256));\n        if (_payInLzToken) {\n            lzTokenFee = treasureFeeQuote;\n        } else {\n            // pay in native\n            // we must prevent high-treasuryFee Dos attack\n            // nativeFee = min(treasureFeeQuote, maxNativeFee)\n            // opportunistically raise the maxNativeFee to be the same as _totalNativeFee\n            // can't use the _totalNativeFee alone because the oapp can use custom workers to force the fee to 0.\n            // maxNativeFee = max (_totalNativeFee, treasuryNativeFeeCap)\n            uint256 maxNativeFee = _totalNativeFee > treasuryNativeFeeCap ? _totalNativeFee : treasuryNativeFeeCap;\n\n            // min (treasureFeeQuote, nativeFeeCap)\n            nativeFee = treasureFeeQuote > maxNativeFee ? maxNativeFee : treasureFeeQuote;\n        }\n    }\n\n    /// @dev authenticated by msg.sender only\n    function _debitFee(uint256 _amount) internal {\n        uint256 fee = fees[msg.sender];\n        if (_amount > fee) revert LZ_MessageLib_InvalidAmount(_amount, fee);\n        unchecked {\n            fees[msg.sender] = fee - _amount;\n        }\n    }\n\n    function _setTreasury(address _treasury) internal {\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    function _setExecutorConfig(uint32 _remoteEid, address _oapp, ExecutorConfig memory _config) internal {\n        executorConfigs[_oapp][_remoteEid] = _config;\n        emit ExecutorConfigSet(_oapp, _remoteEid, _config);\n    }\n\n    // ======================= Virtual =======================\n    /// @dev these two functions will be overridden with specific logics of the library function\n    function _quoteVerifier(\n        address _oapp,\n        uint32 _eid,\n        WorkerOptions[] memory _options\n    ) internal view virtual returns (uint256 nativeFee);\n\n    /// @dev this function will split the options into executorOptions and validationOptions\n    function _splitOptions(\n        bytes calldata _options\n    ) internal view virtual returns (bytes memory executorOptions, WorkerOptions[] memory validationOptions);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/SendLibBaseE2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ILayerZeroEndpointV2, MessagingFee } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IMessageLib, MessageLibType } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\";\nimport { ISendLib, Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { SendLibBase, WorkerOptions, ExecutorConfig } from \"./SendLibBase.sol\";\n\n/// @dev send-side message library base contract on endpoint v2.\n/// design: the high level logic is the same as SendLibBaseE1\n/// 1/ with added interfaces\n/// 2/ adapt the functions to the new types, like uint32 for eid, address for sender.\nabstract contract SendLibBaseE2 is SendLibBase, ERC165, ISendLib {\n    event NativeFeeWithdrawn(address worker, address receiver, uint256 amount);\n    event LzTokenFeeWithdrawn(address lzToken, address receiver, uint256 amount);\n\n    error LZ_MessageLib_NotTreasury();\n    error LZ_MessageLib_CannotWithdrawAltToken();\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap\n    ) SendLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid(), _treasuryGasLimit, _treasuryNativeFeeCap) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            _interfaceId == type(IMessageLib).interfaceId ||\n            _interfaceId == type(ISendLib).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    // ========================= OnlyEndpoint =========================\n    // @dev this function is marked as virtual and public for testing purpose\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) public virtual onlyEndpoint returns (MessagingFee memory, bytes memory) {\n        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_packet, _options);\n\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(\n            _packet.sender,\n            _packet.dstEid,\n            totalNativeFee,\n            _payInLzToken\n        );\n        totalNativeFee += treasuryNativeFee;\n\n        return (MessagingFee(totalNativeFee, lzTokenFee), encodedPacket);\n    }\n\n    // ========================= OnlyOwner =========================\n    function setTreasury(address _treasury) external onlyOwner {\n        _setTreasury(_treasury);\n    }\n\n    // ========================= External =========================\n    /// @dev E2 only\n    function withdrawFee(address _to, uint256 _amount) external {\n        _debitFee(_amount);\n        address nativeToken = ILayerZeroEndpointV2(endpoint).nativeToken();\n        // transfers native if nativeToken == address(0x0)\n        Transfer.nativeOrToken(nativeToken, _to, _amount);\n        emit NativeFeeWithdrawn(msg.sender, _to, _amount);\n    }\n\n    /// @dev _lzToken is a user-supplied value because lzToken might change in the endpoint before all lzToken can be taken out\n    /// @dev E2 only\n    /// @dev treasury only function\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external {\n        if (msg.sender != treasury) revert LZ_MessageLib_NotTreasury();\n\n        // lz token cannot be the same as the native token\n        if (ILayerZeroEndpointV2(endpoint).nativeToken() == _lzToken) revert LZ_MessageLib_CannotWithdrawAltToken();\n\n        Transfer.token(_lzToken, _to, _amount);\n\n        emit LzTokenFeeWithdrawn(_lzToken, _to, _amount);\n    }\n\n    // ========================= View =========================\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        (uint256 nativeFee, uint256 lzTokenFee) = _quote(\n            _packet.sender,\n            _packet.dstEid,\n            _packet.message.length,\n            _payInLzToken,\n            _options\n        );\n        return MessagingFee(nativeFee, lzTokenFee);\n    }\n\n    function messageLibType() external pure virtual override returns (MessageLibType) {\n        return MessageLibType.Send;\n    }\n\n    // ========================= Internal =========================\n    /// 1/ handle executor\n    /// 2/ handle other workers\n    function _payWorkers(\n        Packet calldata _packet,\n        bytes calldata _options\n    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {\n        // split workers options\n        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);\n\n        // handle executor\n        ExecutorConfig memory config = getExecutorConfig(_packet.sender, _packet.dstEid);\n        uint256 msgSize = _packet.message.length;\n        _assertMessageSize(msgSize, config.maxMessageSize);\n        totalNativeFee += _payExecutor(config.executor, _packet.dstEid, _packet.sender, msgSize, executorOptions);\n\n        // handle other workers\n        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(_packet, validationOptions); //for ULN, it will be dvns\n        totalNativeFee += verifierFee;\n\n        encodedPacket = packetBytes;\n    }\n\n    // ======================= Virtual =======================\n    // For implementation to override\n    function _payVerifier(\n        Packet calldata _packet,\n        WorkerOptions[] memory _options\n    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);\n\n    // receive native token from endpoint\n    receive() external payable virtual {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/SimpleReadExecutor.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { ILayerZeroReadExecutor } from \"./interfaces/ILayerZeroReadExecutor.sol\";\nimport { ExecutorOptions } from \"./libs/ExecutorOptions.sol\";\n\nstruct ExecutionParams {\n    address receiver;\n    Origin origin;\n    bytes32 guid;\n    bytes message;\n    bytes extraData;\n    uint256 gasLimit;\n}\n\ninterface ILayerZeroEndpointV2 {\n    function eid() external view returns (uint32);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external;\n}\n\ncontract SimpleReadExecutor is ILayerZeroReadExecutor {\n    using ExecutorOptions for bytes;\n\n    address public immutable endpoint;\n\n    uint128 public gasPerByte;\n    uint128 public gasPrice;\n\n    constructor(address _endpoint) {\n        endpoint = _endpoint;\n    }\n\n    function configGas(uint128 _gasPerByte, uint128 _gasPrice) external {\n        gasPerByte = _gasPerByte;\n        gasPrice = _gasPrice;\n    }\n\n    function assignJob(address _sender, bytes calldata _options) external returns (uint256) {\n        return getFee(_sender, _options);\n    }\n\n    function execute(ExecutionParams calldata _executionParams) external payable {\n        try\n            ILayerZeroEndpointV2(endpoint).lzReceive{ value: msg.value, gas: _executionParams.gasLimit }(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.message,\n                _executionParams.extraData\n            )\n        {\n            // do nothing\n        } catch (bytes memory reason) {\n            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(\n                _executionParams.origin,\n                _executionParams.receiver,\n                _executionParams.guid,\n                _executionParams.gasLimit,\n                msg.value,\n                _executionParams.message,\n                _executionParams.extraData,\n                reason\n            );\n        }\n    }\n\n    function mustExecute(ExecutionParams calldata _executionParams) external payable {\n        ILayerZeroEndpointV2(endpoint).lzReceive{ value: msg.value, gas: _executionParams.gasLimit }(\n            _executionParams.origin,\n            _executionParams.receiver,\n            _executionParams.guid,\n            _executionParams.message,\n            _executionParams.extraData\n        );\n    }\n\n    // ========================= View =========================\n\n    function getFee(address /*_sender*/, bytes calldata _options) public view returns (uint256) {\n        // For simplify, we only support one execute option, and must be LZREAD type\n        (uint8 optionType, bytes calldata option, ) = _options.nextExecutorOption(0);\n        require(optionType == ExecutorOptions.OPTION_TYPE_LZREAD, \"SimpleReadExecutor: not LZREAD option\");\n        (uint128 gas, uint32 calldataSize, uint128 value) = option.decodeLzReadOption();\n        // calculate fee\n        return (gas + calldataSize * gasPerByte) * gasPrice + value;\n    }\n\n    receive() external payable virtual {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroTreasury } from \"./interfaces/ILayerZeroTreasury.sol\";\n\ncontract Treasury is Ownable, ILayerZeroTreasury {\n    uint256 public nativeBP;\n    uint256 public lzTokenFee;\n    bool public lzTokenEnabled;\n\n    error LZ_Treasury_LzTokenNotEnabled();\n\n    function getFee(\n        address /*_sender*/,\n        uint32 /*_eid*/,\n        uint256 _totalFee,\n        bool _payInLzToken\n    ) external view override returns (uint256) {\n        return _getFee(_totalFee, _payInLzToken);\n    }\n\n    function payFee(\n        address /*_sender*/,\n        uint32 /*_eid*/,\n        uint256 _totalFee,\n        bool _payInLzToken\n    ) external payable override returns (uint256) {\n        return _getFee(_totalFee, _payInLzToken);\n    }\n\n    function setLzTokenEnabled(bool _lzTokenEnabled) external onlyOwner {\n        lzTokenEnabled = _lzTokenEnabled;\n    }\n\n    function setNativeFeeBP(uint256 _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n    }\n\n    function setLzTokenFee(uint256 _lzTokenFee) external onlyOwner {\n        lzTokenFee = _lzTokenFee;\n    }\n\n    function withdrawLzToken(address _messageLib, address _lzToken, address _to, uint256 _amount) external onlyOwner {\n        ISendLib(_messageLib).withdrawLzTokenFee(_lzToken, _to, _amount);\n    }\n\n    function withdrawNativeFee(address _messageLib, address payable _to, uint256 _amount) external onlyOwner {\n        ISendLib(_messageLib).withdrawFee(_to, _amount);\n    }\n\n    // this is for withdrawing lz token sent to this contract by uln301 and fee handler\n    // and to withdraw any native sent over via payFee\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    // ======================= Internal =======================\n\n    function _getFee(uint256 _totalFee, bool _payInLzToken) internal view returns (uint256) {\n        if (_payInLzToken) {\n            if (!lzTokenEnabled) revert LZ_Treasury_LzTokenNotEnabled();\n            return lzTokenFee;\n        } else {\n            return (_totalFee * nativeBP) / 10000;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/Worker.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IWorker } from \"./interfaces/IWorker.sol\";\n\nabstract contract Worker is AccessControl, Pausable, IWorker {\n    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256(\"MESSAGE_LIB_ROLE\");\n    bytes32 internal constant ALLOWLIST = keccak256(\"ALLOWLIST\");\n    bytes32 internal constant DENYLIST = keccak256(\"DENYLIST\");\n    bytes32 internal constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public workerFeeLib;\n\n    uint64 public allowlistSize;\n    uint16 public defaultMultiplierBps;\n    address public priceFeed;\n\n    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;\n\n    // ========================= Constructor =========================\n\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _defaultMultiplierBps default multiplier for worker fee\n    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    constructor(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) {\n        defaultMultiplierBps = _defaultMultiplierBps;\n        priceFeed = _priceFeed;\n\n        if (_roleAdmin != address(0x0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles\n        }\n\n        for (uint256 i = 0; i < _messageLibs.length; ++i) {\n            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);\n        }\n\n        for (uint256 i = 0; i < _admins.length; ++i) {\n            _grantRole(ADMIN_ROLE, _admins[i]);\n        }\n    }\n\n    // ========================= Modifier =========================\n\n    modifier onlyAcl(address _sender) {\n        if (!hasAcl(_sender)) {\n            revert Worker_NotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Access control list using allowlist and denylist\n    /// @dev 1) if one address is in the denylist -> deny\n    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow\n    /// @dev 3) else deny\n    /// @param _sender address to check\n    function hasAcl(address _sender) public view returns (bool) {\n        if (hasRole(DENYLIST, _sender)) {\n            return false;\n        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // ========================= OnyDefaultAdmin =========================\n\n    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)\n    /// @param _paused true to pause, false to unpause\n    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _priceFeed price feed address\n    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {\n        priceFeed = _priceFeed;\n        emit SetPriceFeed(_priceFeed);\n    }\n\n    /// @param _workerFeeLib worker fee lib address\n    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {\n        workerFeeLib = _workerFeeLib;\n        emit SetWorkerLib(_workerFeeLib);\n    }\n\n    /// @param _multiplierBps default multiplier for worker fee\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {\n        defaultMultiplierBps = _multiplierBps;\n        emit SetDefaultMultiplierBps(_multiplierBps);\n    }\n\n    /// @dev supports withdrawing fee from ULN301, ULN302 and more\n    /// @param _lib message lib address\n    /// @param _to address to withdraw fee to\n    /// @param _amount amount to withdraw\n    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();\n        ISendLib(_lib).withdrawFee(_to, _amount);\n        emit Withdraw(_lib, _to, _amount);\n    }\n\n    /// @dev supports withdrawing token from the contract\n    /// @param _token token address\n    /// @param _to address to withdraw token to\n    /// @param _amount amount to withdraw\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {\n        supportedOptionTypes[_eid] = _optionTypes;\n    }\n\n    // ========================= View Functions =========================\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {\n        return supportedOptionTypes[_eid];\n    }\n\n    // ========================= Internal Functions =========================\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to grant\n    /// @param _account address to grant role to\n    function _grantRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && !hasRole(_role, _account)) {\n            ++allowlistSize;\n        }\n        super._grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to revoke\n    /// @param _account address to revoke role from\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && hasRole(_role, _account)) {\n            --allowlistSize;\n        }\n        super._revokeRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to disable renouncing of roles\n    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {\n        revert Worker_RoleRenouncingDisabled();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/decompressor/DVNDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport { ExecuteParam } from \"../uln/dvn/DVN.sol\";\n\nlibrary DVNDecoder {\n    uint8 internal constant DVN_INDEX_SIZE = 2; // uint16\n    uint8 internal constant PARAMS_LENGTH_SIZE = 1; // uint8\n    uint8 internal constant TARGET_INDEX_SIZE = 1; // uint8\n    uint8 internal constant EXPIRATION_SIZE = 16; // uint128\n    uint8 internal constant SIGNATURES_LENGTH_SIZE = 2; // uint16\n    uint8 internal constant CALL_DATA_LENGTH_SIZE = 8; // uint64\n\n    function execute(\n        bytes calldata _encoded,\n        uint32 _vid,\n        mapping(uint8 index => address target) storage _targets\n    ) internal view returns (uint16 dvnIndex, ExecuteParam[] memory params) {\n        uint256 cursor = 0;\n\n        dvnIndex = uint16(bytes2(_encoded[cursor:cursor + DVN_INDEX_SIZE]));\n        cursor += DVN_INDEX_SIZE;\n\n        uint8 length = uint8(bytes1(_encoded[cursor:cursor + PARAMS_LENGTH_SIZE]));\n        cursor += PARAMS_LENGTH_SIZE;\n\n        params = new ExecuteParam[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            uint8 targetIndex = uint8(bytes1(_encoded[cursor:cursor + TARGET_INDEX_SIZE]));\n            cursor += TARGET_INDEX_SIZE;\n\n            uint128 expiration = uint128(bytes16(_encoded[cursor:cursor + EXPIRATION_SIZE]));\n            cursor += EXPIRATION_SIZE;\n\n            uint16 signaturesLength = uint16(bytes2(_encoded[cursor:cursor + SIGNATURES_LENGTH_SIZE]));\n            cursor += SIGNATURES_LENGTH_SIZE;\n\n            bytes memory signatures = _encoded[cursor:cursor + signaturesLength];\n            cursor += signaturesLength;\n\n            uint64 callDataLength = uint64(bytes8(_encoded[cursor:cursor + CALL_DATA_LENGTH_SIZE]));\n            cursor += CALL_DATA_LENGTH_SIZE;\n\n            bytes memory callData = _encoded[cursor:cursor + callDataLength];\n            cursor += callDataLength;\n\n            params[i] = ExecuteParam(_vid, _targets[targetIndex], callData, expiration, signatures);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/decompressor/DVNDecompressor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { DVN, ExecuteParam } from \"../uln/dvn/DVN.sol\";\nimport { DVNDecoder } from \"./DVNDecoder.sol\";\nimport { DecompressorExtension } from \"./DecompressorExtension.sol\";\n\nstruct TargetParam {\n    uint8 idx;\n    address addr;\n}\n\nstruct DVNParam {\n    uint16 idx;\n    address addr;\n}\n\ncontract DVNDecompressor is Ownable, DecompressorExtension {\n    uint32 public immutable vid;\n\n    mapping(uint16 index => address dvn) public dvns;\n    mapping(uint8 index => address target) public targets;\n\n    constructor(uint32 _vid, DVNParam[] memory _dvns, TargetParam[] memory _targets) {\n        vid = _vid;\n\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            DVNParam memory param = _dvns[i];\n            dvns[param.idx] = param.addr;\n        }\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            TargetParam memory param = _targets[i];\n            targets[param.idx] = param.addr;\n        }\n    }\n\n    function addTargets(TargetParam[] memory _targets) external onlyOwner {\n        for (uint256 i = 0; i < _targets.length; i++) {\n            targets[_targets[i].idx] = _targets[i].addr;\n        }\n    }\n\n    function removeTargets(uint8[] memory _idx) external onlyOwner {\n        for (uint256 i = 0; i < _idx.length; i++) {\n            delete targets[_idx[i]];\n        }\n    }\n\n    function addDVNs(DVNParam[] memory _dvns) external onlyOwner {\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            dvns[_dvns[i].idx] = _dvns[i].addr;\n        }\n    }\n\n    function removeDVNs(uint16[] memory _idx) external onlyOwner {\n        for (uint256 i = 0; i < _idx.length; i++) {\n            delete dvns[_idx[i]];\n        }\n    }\n\n    function execute(bytes calldata _encoded) external onlyOwner {\n        (uint16 dvnIndex, ExecuteParam[] memory params) = DVNDecoder.execute(_encoded, vid, targets);\n\n        DVN(dvns[dvnIndex]).execute(params);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/decompressor/DecompressorExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title DecompressorExtension\n * @dev A contract that implements a decompression algorithm to be used in conjunction with compressed data.\n * You should implement in your contract a function that makes use of the internal methods `_setData`, `_setDataArray` for data addition to the dictionary.\n * NOTE: It is important to implement a delay when using the `_setData` and `_setDataArray` methods in your transactions. This delay helps to guard against the possibility of frontrunning, which can occur when the state of the dictionary changes during the execution of a transaction.\n * @notice This extension could result in a much higher gas consumption than expected and could potentially lead to significant memory expansion costs. Be sure to properly estimate these aspects to avoid unforeseen expenses.\n */\nabstract contract DecompressorExtension {\n    /**\n     * @dev Emitted when an offset is used incorrectly, either because it is too small, or because its sum with a dict data's length exceeds a certain limit.\n     * @param value The incorrect value used as an offset or as the sum of the offset and a dict data's length.\n     */\n    error IncorrectDictAccess(uint256 value);\n\n    uint256 public constant MAX_DICT_LEN = 1_048_576; // 2 ** 20\n    uint256 public constant RESERVE_DICT_LEN = 2; // 0: msg.sender; 1: address(this)\n\n    /**\n     * @dev The dictionary mapping storage slots to their associated compressed data.\n     */\n    bytes32[MAX_DICT_LEN] private _dict;\n\n    /**\n     * @dev Ensures the provided value is correctly used as an offset. This includes checks for the offset being too small or its sum with an dict data's length exceeding a certain limit. Value less `RESERVE_DICT_LEN` are reserved.\n     * @param value The value used as an offset or as the sum of the offset and an array's length.\n     */\n    modifier validDictAccess(uint256 value) {\n        if (value < RESERVE_DICT_LEN || value >= MAX_DICT_LEN) revert IncorrectDictAccess(value);\n        _;\n    }\n\n    /**\n     * @dev Returns the data stored in the dictionary in the specified range.\n     * @param begin The starting index of the data range to return. First 2 positions are reserved, so it should be greater than 1.\n     * @param end The ending index of the data range to return.\n     * @return res An array of bytes32 values containing the data in the specified range.\n     */\n    function getData(\n        uint256 begin,\n        uint256 end\n    ) external view validDictAccess(begin) validDictAccess(end) returns (bytes32[] memory res) {\n        unchecked {\n            if (begin < end) {\n                res = new bytes32[](end - begin);\n                for (uint256 i = begin; i < end; i++) {\n                    res[i - begin] = _dict[i];\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Sets the data at the specified dictionary offset.\n     * @param offset The dictionary offset to set the data at. First 2 positions are reserved, so it should be greater than 1.\n     * @param data The data to be stored at the specified offset.\n     */\n    function _setData(uint256 offset, bytes32 data) internal validDictAccess(offset) {\n        unchecked {\n            _dict[offset] = data;\n        }\n    }\n\n    /**\n     * @dev Sets an array of data starting at the specified dictionary offset.\n     * @param offset The starting dictionary offset to set the data at. First 2 positions are reserved, so it should be greater than 1.\n     * @param dataArray The array of data to be stored starting at the specified offset.\n     */\n    function _setDataArray(\n        uint256 offset,\n        bytes32[] calldata dataArray\n    ) internal validDictAccess(offset) validDictAccess(offset + dataArray.length) {\n        unchecked {\n            for (uint256 i = 0; i < dataArray.length; i++) {\n                _dict[offset + i] = dataArray[i];\n            }\n        }\n    }\n\n    /**\n     * @dev Decompresses the compressed data (N bytes) passed to the function using the _delegatecall function.\n     */\n    function decompress() external payable {\n        _delegatecall(decompressed());\n    }\n\n    /**\n     * @dev Calculates and returns the decompressed data from the compressed calldata.\n     * @return raw The decompressed raw data.\n     */\n    function decompressed() public view returns (bytes memory raw) {\n        return _decompressed(msg.data[4:]);\n    }\n\n    /**\n     * @dev Calculates and returns the decompressed raw data from the compressed data passed as an argument.\n     * @param cd The compressed data to be decompressed.\n     * @return raw The decompressed raw data.\n     */\n    function _decompressed(bytes calldata cd) internal view returns (bytes memory raw) {\n        assembly (\"memory-safe\") {\n            // solhint-disable-line no-inline-assembly\n            raw := mload(0x40)\n            let outptr := add(raw, 0x20)\n            let end := add(cd.offset, cd.length)\n            for {\n                let inptr := cd.offset\n            } lt(inptr, end) {\n\n            } {\n                // solhint-disable-line no-empty-blocks\n                let data := calldataload(inptr)\n\n                let key\n\n                // 00XXXXXX - insert X+1 zero bytes\n                // 01PXXXXX - copy X+1 bytes calldata (P means padding to 32 bytes or not)\n                // 10BBXXXX XXXXXXXX - use 12 bits as key for [32,20,4,31][B] bytes from storage X\n                // 11BBXXXX XXXXXXXX XXXXXXXX - use 20 bits as [32,20,4,31][B] bytes from storage X\n                switch shr(254, data)\n                case 0 {\n                    let size := add(byte(0, data), 1)\n                    calldatacopy(outptr, calldatasize(), size)\n                    inptr := add(inptr, 1)\n                    outptr := add(outptr, size)\n                    continue\n                }\n                case 1 {\n                    let size := add(and(0x1F, byte(0, data)), 1)\n                    if and(data, 0x2000000000000000000000000000000000000000000000000000000000000000) {\n                        mstore(outptr, 0)\n                        outptr := add(outptr, sub(32, size))\n                    }\n                    calldatacopy(outptr, add(inptr, 1), size)\n                    inptr := add(inptr, add(1, size))\n                    outptr := add(outptr, size)\n                    continue\n                }\n                case 2 {\n                    key := shr(244, shl(4, data))\n                    inptr := add(inptr, 2)\n                    // fallthrough\n                }\n                case 3 {\n                    key := shr(236, shl(4, data))\n                    inptr := add(inptr, 3)\n                    // fallthrough\n                }\n\n                // TODO: check sload argument\n                let value\n                switch key\n                case 0 {\n                    value := caller()\n                }\n                case 1 {\n                    value := address()\n                }\n                default {\n                    value := sload(add(_dict.slot, key))\n                }\n\n                switch shr(254, shl(2, data))\n                case 0 {\n                    mstore(outptr, value)\n                    outptr := add(outptr, 32)\n                }\n                case 1 {\n                    mstore(outptr, shl(96, value))\n                    outptr := add(outptr, 20)\n                }\n                case 2 {\n                    mstore(outptr, shl(224, value))\n                    outptr := add(outptr, 4)\n                }\n                default {\n                    mstore(outptr, shl(8, value))\n                    outptr := add(outptr, 31)\n                }\n            }\n            mstore(raw, sub(sub(outptr, raw), 0x20))\n            mstore(0x40, outptr)\n        }\n    }\n\n    /**\n     * @dev Executes a delegate call to the raw data calculated by the _decompressed function.\n     * @param raw The raw data to execute the delegate call with.\n     */\n    function _delegatecall(bytes memory raw) internal {\n        assembly (\"memory-safe\") {\n            // solhint-disable-line no-inline-assembly\n            let success := delegatecall(gas(), address(), add(raw, 0x20), mload(raw), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if success {\n                return(0, returndatasize())\n            }\n            revert(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/decompressor/ExecutorDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IExecutor } from \"../interfaces/IExecutor.sol\";\n\nlibrary ExecutorDecoder {\n    uint8 internal constant NATIVE_DROP_GAS_LIMIT_OFFSET = 0; // uint32\n    uint8 internal constant SRC_EID_OFFSET = 4; // uint32\n    uint8 internal constant SENDER_OFFSET = 8; // bytes32\n    uint8 internal constant NONCE_OFFSET = 40; // uint64\n    uint8 internal constant RECEIVER_OFFSET = 48; // address\n\n    uint8 internal constant NATIVEDROP_DST_EID_OFFSET = 68; // uint32\n    uint8 internal constant DST_EID_SIZE = 4; // uint32\n    function nativeDrop(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            Origin memory origin,\n            uint32 dstEid,\n            address receiver,\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:RECEIVER_OFFSET]));\n        receiver = address(bytes20(_encoded[RECEIVER_OFFSET:NATIVEDROP_DST_EID_OFFSET]));\n\n        uint8 nativeDropOffset = NATIVEDROP_DST_EID_OFFSET + DST_EID_SIZE;\n        dstEid = uint32(bytes4(_encoded[NATIVEDROP_DST_EID_OFFSET:nativeDropOffset]));\n\n        nativeDropParams = _nativeDrop(_encoded[nativeDropOffset:]);\n    }\n\n    uint8 internal constant EXECUTE301_GAS_LIMIT_OFFSET = 0; // uint64\n    uint8 internal constant EXECUTE301_PACKET_OFFSET = 8; // uint64\n    function execute301(bytes calldata encoded) internal pure returns (bytes memory packet, uint256 gasLimit) {\n        gasLimit = uint256(uint64(bytes8(encoded[EXECUTE301_GAS_LIMIT_OFFSET:EXECUTE301_PACKET_OFFSET])));\n        packet = encoded[EXECUTE301_PACKET_OFFSET:];\n    }\n\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET = 48; // uint64\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET = 56; // uint64\n    uint8 internal constant NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET = 64; // uint64\n    function nativeDropAndExecute301(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            Origin memory origin,\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            bytes memory packet,\n            uint256 gasLimit\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET]));\n\n        gasLimit = uint256(\n            uint64(\n                bytes8(\n                    _encoded[NATIVEDROP_AND_EXECUTE301_GAS_LIMIT_OFFSET:NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET]\n                )\n            )\n        );\n\n        uint64 packetLength = uint64(\n            bytes8(_encoded[NATIVEDROP_AND_EXECUTE301_PACKET_LENGTH_OFFSET:NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET])\n        );\n\n        uint256 cursor = NATIVEDROP_AND_EXECUTE301_PACKET_OFFSET;\n\n        packet = _encoded[cursor:cursor + packetLength];\n        cursor += packetLength;\n\n        nativeDropParams = _nativeDrop(_encoded[cursor:]);\n    }\n\n    uint8 internal constant EXECUTE302_GUID_OFFSET = 68; // bytes32\n    uint8 internal constant EXECUTE302_GAS_LIMIT_OFFSET = 100; // uint64\n    uint8 internal constant EXECUTE302_MESSAGE_LENGTH_OFFSET = 108; // uint64\n    uint8 internal constant EXECUTE302_MESSAGE_OFFSET = 116; // uint64\n    uint8 internal constant EXTRA_DATA_LENGTH_SIZE = 8; // uint64\n    function nativeDropAndExecute302(\n        bytes calldata _encoded\n    )\n        internal\n        pure\n        returns (\n            IExecutor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            IExecutor.ExecutionParams memory executionParams\n        )\n    {\n        nativeDropGasLimit = uint256(uint32(bytes4(_encoded[NATIVE_DROP_GAS_LIMIT_OFFSET:SRC_EID_OFFSET])));\n        executionParams.origin.srcEid = uint32(bytes4(_encoded[SRC_EID_OFFSET:SENDER_OFFSET]));\n        executionParams.origin.sender = bytes32(_encoded[SENDER_OFFSET:NONCE_OFFSET]);\n        executionParams.origin.nonce = uint64(bytes8(_encoded[NONCE_OFFSET:RECEIVER_OFFSET]));\n        executionParams.receiver = address(bytes20(_encoded[RECEIVER_OFFSET:EXECUTE302_GUID_OFFSET]));\n        executionParams.guid = bytes32(_encoded[EXECUTE302_GUID_OFFSET:EXECUTE302_GAS_LIMIT_OFFSET]);\n        executionParams.gasLimit = uint256(\n            uint64(bytes8(_encoded[EXECUTE302_GAS_LIMIT_OFFSET:EXECUTE302_MESSAGE_LENGTH_OFFSET]))\n        );\n\n        uint64 messageLength = uint64(bytes8(_encoded[EXECUTE302_MESSAGE_LENGTH_OFFSET:EXECUTE302_MESSAGE_OFFSET]));\n        uint256 cursor = EXECUTE302_MESSAGE_OFFSET;\n\n        executionParams.message = _encoded[cursor:cursor + messageLength];\n        cursor += messageLength;\n\n        uint64 extraDataLength = uint64(bytes8(_encoded[cursor:cursor + EXTRA_DATA_LENGTH_SIZE]));\n        cursor += EXTRA_DATA_LENGTH_SIZE;\n\n        executionParams.extraData = _encoded[cursor:cursor + extraDataLength];\n        cursor += extraDataLength;\n\n        nativeDropParams = _nativeDrop(_encoded[cursor:]);\n    }\n\n    uint8 internal constant NATIVE_DROP_RECEIVER_SIZE = 20; // address\n    uint8 internal constant NATIVE_DROP_AMOUNT_SIZE = 9; // uint72\n    uint8 internal constant NATIVE_DROP_PARAM_SIZE = 29; // 20 + 9\n    function _nativeDrop(\n        bytes calldata _encoded\n    ) internal pure returns (IExecutor.NativeDropParams[] memory nativeDropParams) {\n        uint256 cursor = 0;\n        uint256 nativeDropParamsLength = _encoded.length / NATIVE_DROP_PARAM_SIZE;\n\n        nativeDropParams = new IExecutor.NativeDropParams[](nativeDropParamsLength);\n        for (uint256 i = 0; i < nativeDropParamsLength; i++) {\n            nativeDropParams[i].receiver = address(bytes20(_encoded[cursor:cursor + NATIVE_DROP_RECEIVER_SIZE]));\n            cursor += NATIVE_DROP_RECEIVER_SIZE;\n            nativeDropParams[i].amount = uint256(uint72(bytes9(_encoded[cursor:cursor + NATIVE_DROP_AMOUNT_SIZE])));\n            cursor += NATIVE_DROP_AMOUNT_SIZE;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/decompressor/ExecutorDecompressor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { Executor } from \"../Executor.sol\";\nimport { ExecutorDecoder } from \"./ExecutorDecoder.sol\";\nimport { DecompressorExtension } from \"./DecompressorExtension.sol\";\n\ncontract ExecutorDecompressor is Ownable, DecompressorExtension {\n    Executor public immutable executor;\n\n    constructor(Executor _executor) {\n        executor = _executor;\n    }\n\n    function nativeDrop(bytes calldata _encoded) external onlyOwner {\n        (\n            Origin memory origin,\n            uint32 dstEid,\n            address oapp,\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit\n        ) = ExecutorDecoder.nativeDrop(_encoded);\n\n        executor.nativeDrop(origin, dstEid, oapp, nativeDropParams, nativeDropGasLimit);\n    }\n\n    function execute301(bytes calldata _encoded) external onlyOwner {\n        (bytes memory packet, uint256 gasLimit) = ExecutorDecoder.execute301(_encoded);\n\n        executor.execute301(packet, gasLimit);\n    }\n\n    function nativeDropAndExecute301(bytes calldata _encoded) external onlyOwner {\n        (\n            Origin memory origin,\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            bytes memory packet,\n            uint256 gasLimit\n        ) = ExecutorDecoder.nativeDropAndExecute301(_encoded);\n\n        executor.nativeDropAndExecute301(origin, nativeDropParams, nativeDropGasLimit, packet, gasLimit);\n    }\n\n    function nativeDropAndExecute302(bytes calldata _encoded) external onlyOwner {\n        (\n            Executor.NativeDropParams[] memory nativeDropParams,\n            uint256 nativeDropGasLimit,\n            Executor.ExecutionParams memory executionParams\n        ) = ExecutorDecoder.nativeDropAndExecute302(_encoded);\n\n        executor.nativeDropAndExecute302(nativeDropParams, nativeDropGasLimit, executionParams);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IWorker } from \"./IWorker.sol\";\nimport { ILayerZeroExecutor } from \"./ILayerZeroExecutor.sol\";\nimport { ILayerZeroReadExecutor } from \"./ILayerZeroReadExecutor.sol\";\n\ninterface IExecutor is IWorker, ILayerZeroExecutor, ILayerZeroReadExecutor {\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 lzReceiveBaseGas;\n        uint64 lzComposeBaseGas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n        uint128 nativeCap;\n    }\n\n    struct DstConfig {\n        uint64 lzReceiveBaseGas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n        uint128 nativeCap;\n        uint64 lzComposeBaseGas;\n    }\n\n    struct ExecutionParams {\n        address receiver;\n        Origin origin;\n        bytes32 guid;\n        bytes message;\n        bytes extraData;\n        uint256 gasLimit;\n    }\n\n    struct NativeDropParams {\n        address receiver;\n        uint256 amount;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event NativeDropApplied(Origin origin, uint32 dstEid, address oapp, NativeDropParams[] params, bool[] success);\n\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128, uint128, uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/IExecutorFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IExecutor } from \"./IExecutor.sol\";\n\ninterface IExecutorFeeLib {\n    struct FeeParams {\n        address priceFeed;\n        uint32 dstEid;\n        address sender;\n        uint256 calldataSize;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct FeeParamsForRead {\n        address priceFeed;\n        address sender;\n        uint16 defaultMultiplierBps;\n    }\n\n    error Executor_NoOptions();\n    error Executor_NativeAmountExceedsCap(uint256 amount, uint256 cap);\n    error Executor_UnsupportedOptionType(uint8 optionType);\n    error Executor_InvalidExecutorOptions(uint256 cursor);\n    error Executor_ZeroLzReceiveGasProvided();\n    error Executor_ZeroLzComposeGasProvided();\n    error Executor_ZeroCalldataSizeProvided();\n    error Executor_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external returns (uint256 fee);\n\n    function getFee(\n        FeeParams calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n\n    function getFeeOnSend(\n        FeeParamsForRead calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external returns (uint256 fee);\n\n    function getFee(\n        FeeParamsForRead calldata _params,\n        IExecutor.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroExecutor {\n    // @notice query price and assign jobs at the same time\n    // @param _dstEid - the destination endpoint identifier\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _calldataSize - dynamic data size of message + caller params\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external returns (uint256 price);\n\n    // @notice query the executor price for relaying the payload and its proof to the destination chain\n    // @param _dstEid - the destination endpoint identifier\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _calldataSize - dynamic data size of message + caller params\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(\n        uint32 _dstEid,\n        address _sender,\n        uint256 _calldataSize,\n        bytes calldata _options\n    ) external view returns (uint256 price);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroPriceFeed {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint32 eid;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint32 eid;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    error LZ_PriceFeed_OnlyPriceUpdater();\n    error LZ_PriceFeed_InsufficientFee(uint256 provided, uint256 required);\n    error LZ_PriceFeed_NotAnOPStack(uint32 l2Eid);\n\n    function nativeTokenPriceUSD() external view returns (uint128);\n\n    function getFee(uint32 _dstEid, uint256 _callDataSize, uint256 _gas) external view returns (uint256);\n\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n\n    function estimateFeeOnSend(\n        uint32 _dstEid,\n        uint256 _callDataSize,\n        uint256 _gas\n    ) external payable returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroReadExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroReadExecutor {\n    // @notice query price and assign jobs at the same time\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(address _sender, bytes calldata _options) external returns (uint256 fee);\n\n    // @notice query the executor price for executing the payload on this chain\n    // @param _sender - the source sending contract address. executors may apply price discrimination to senders\n    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens\n    function getFee(address _sender, bytes calldata _options) external view returns (uint256 fee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroTreasury {\n    function getFee(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) external view returns (uint256 fee);\n\n    function payFee(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) external payable returns (uint256 fee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/IWorker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IWorker {\n    event SetWorkerLib(address workerLib);\n    event SetPriceFeed(address priceFeed);\n    event SetDefaultMultiplierBps(uint16 multiplierBps);\n    event SetSupportedOptionTypes(uint32 dstEid, uint8[] optionTypes);\n    event Withdraw(address lib, address to, uint256 amount);\n\n    error Worker_NotAllowed();\n    error Worker_OnlyMessageLib();\n    error Worker_RoleRenouncingDisabled();\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function priceFeed() external view returns (address);\n\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external;\n\n    function defaultMultiplierBps() external view returns (uint16);\n\n    function withdrawFee(address _lib, address _to, uint256 _amount) external;\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external;\n\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.20;\n\n/// @dev copied from https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.\nlibrary SafeCall {\n    /// @notice calls a contract with a specified gas limit and value and captures the return data\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// to memory.\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function safeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // check that target has code\n        uint size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        if (size == 0) {\n            return (false, new bytes(0));\n        }\n\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 100 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function safeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // check that target has code\n        uint size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        if (size == 0) {\n            return (false, new bytes(0));\n        }\n\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/lowlat/EssenceDVNWrapper.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport { MultiCall } from \"./MultiCall.sol\";\n\n/// @title EssenceDVNWrapper is a contract, used to execute multiple worker calls in a single transaction\n/// The calls should be as follows:\n/// 1. N calls to dvn.execute() to verify the payload on ULN\n/// 2. 1 call to uln.commitVerification() to commit the verification into the endpoint\n/// 3. 1 call to executor.execute() to execute lzReceive() on the endpoint\n///\n/// Node: The DVN should assign EssenceDVNWrapper as an admin to the DVN contract.\n///\ncontract EssenceDVNWrapper is AccessControl, MultiCall {\n    bytes32 internal constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    error DVNWrapper_InvalidRole(bytes32 role);\n    error DVNWrapper_InvalidAdminCount();\n    error DVNWrapper_RoleRenouncingDisabled();\n\n    uint256 public adminCount;\n\n    modifier onlyAdmin(bytes32 _role) {\n        if (_role == ADMIN_ROLE) {\n            _checkRole(_role); // admin required\n        } else {\n            revert DVNWrapper_InvalidRole(_role);\n        }\n        _;\n    }\n\n    constructor(address[] memory admins) {\n        if (admins.length == 0) {\n            revert DVNWrapper_InvalidAdminCount();\n        }\n        for (uint i = 0; i < admins.length; i++) {\n            _setupRole(ADMIN_ROLE, admins[i]);\n        }\n        adminCount = admins.length;\n    }\n\n    function multiCall(\n        Call[] calldata _calls\n    ) public payable override onlyAdmin(ADMIN_ROLE) returns (bool[] memory successes, bytes[] memory results) {\n        (successes, results) = super.multiCall(_calls);\n    }\n\n    // ========================= Override Functions =========================\n\n    function grantRole(bytes32 _role, address _account) public override onlyAdmin(_role) {\n        _grantRole(_role, _account);\n    }\n\n    function revokeRole(bytes32 _role, address _account) public override onlyAdmin(_role) {\n        _revokeRole(_role, _account);\n    }\n\n    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {\n        revert DVNWrapper_RoleRenouncingDisabled();\n    }\n\n    function _grantRole(bytes32 _role, address _account) internal override {\n        if (_role == ADMIN_ROLE) ++adminCount;\n        super._grantRole(_role, _account);\n    }\n\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        if (_role == ADMIN_ROLE) --adminCount;\n        if (adminCount == 0) {\n            revert DVNWrapper_InvalidAdminCount(); // not allowed to remove all admins\n        }\n        super._revokeRole(_role, _account);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/lowlat/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\ncontract MultiCall {\n    struct Call {\n        address target;\n        bytes data;\n        uint256 gasLimit;\n        uint256 value;\n        bool revertOnError;\n    }\n\n    error NotEnoughGas(uint256 index, uint256 requested, uint256 available);\n    error CallReverted(uint256 index, bytes result);\n\n    function multiCall(\n        Call[] calldata _calls\n    ) public payable virtual returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](_calls.length);\n        results = new bytes[](_calls.length);\n\n        for (uint256 i = 0; i < _calls.length; i++) {\n            Call calldata call = _calls[i];\n\n            if (gasleft() < call.gasLimit) revert NotEnoughGas(i, call.gasLimit, gasleft());\n\n            (successes[i], results[i]) = call.target.call{\n                value: call.value,\n                gas: call.gasLimit == 0 ? gasleft() : call.gasLimit\n            }(call.data);\n\n            if (!successes[i] && _calls[i].revertOnError) revert CallReverted(i, results[i]);\n        }\n\n        if (address(this).balance > 0) {\n            Transfer.native(msg.sender, address(this).balance);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/mocks/DVNMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.22;\n\nimport { ExecuteParam } from \"../uln/dvn/DVN.sol\";\n\ncontract DVNMock {\n    event Executed(uint32 vid, address target, bytes callData, uint256 expiration, bytes signatures);\n\n    uint32 public immutable vid;\n\n    constructor(uint32 _vid) {\n        vid = _vid;\n    }\n\n    function execute(ExecuteParam[] calldata _params) external {\n        for (uint256 i = 0; i < _params.length; i++) {\n            emit Executed(\n                _params[i].vid,\n                _params[i].target,\n                _params[i].callData,\n                _params[i].expiration,\n                _params[i].signatures\n            );\n        }\n    }\n\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/mocks/ExecutorMock.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { IExecutor } from \"../../contracts/interfaces/IExecutor.sol\";\n\ncontract ExecutorMock {\n    using PacketV1Codec for bytes;\n\n    event NativeDropMeta(\n        uint32 srcEid,\n        bytes32 sender,\n        uint64 nonce,\n        uint32 dstEid,\n        address oapp,\n        uint256 nativeDropGasLimit\n    );\n    event NativeDropped(address receiver, uint256 amount);\n    event Executed301(bytes packet, uint256 gasLimit);\n    event Executed302(\n        uint32 srcEid,\n        bytes32 sender,\n        uint64 nonce,\n        address receiver,\n        bytes32 guid,\n        bytes message,\n        bytes extraData,\n        uint256 gasLimit\n    );\n\n    uint32 public immutable dstEid;\n\n    constructor(uint32 _dstEid) {\n        dstEid = _dstEid;\n    }\n\n    function nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) external payable {\n        _nativeDrop(_origin, _dstEid, _oapp, _nativeDropParams, _nativeDropGasLimit);\n    }\n\n    function nativeDropAndExecute301(\n        Origin calldata _origin,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        bytes calldata _packet,\n        uint256 _gasLimit\n    ) external payable {\n        _nativeDrop(_origin, _packet.dstEid(), _packet.receiverB20(), _nativeDropParams, _nativeDropGasLimit);\n        emit Executed301(_packet, _gasLimit);\n    }\n\n    function execute301(bytes calldata _packet, uint256 _gasLimit) external {\n        emit Executed301(_packet, _gasLimit);\n    }\n\n    function nativeDropAndExecute302(\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit,\n        IExecutor.ExecutionParams calldata _executionParams\n    ) external payable {\n        _nativeDrop(_executionParams.origin, dstEid, _executionParams.receiver, _nativeDropParams, _nativeDropGasLimit);\n\n        emit Executed302(\n            _executionParams.origin.srcEid,\n            _executionParams.origin.sender,\n            _executionParams.origin.nonce,\n            _executionParams.receiver,\n            _executionParams.guid,\n            _executionParams.message,\n            _executionParams.extraData,\n            _executionParams.gasLimit\n        );\n    }\n\n    function _nativeDrop(\n        Origin calldata _origin,\n        uint32 _dstEid,\n        address _oapp,\n        IExecutor.NativeDropParams[] calldata _nativeDropParams,\n        uint256 _nativeDropGasLimit\n    ) internal {\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            emit NativeDropped(_nativeDropParams[i].receiver, _nativeDropParams[i].amount);\n        }\n        emit NativeDropMeta(_origin.srcEid, _origin.sender, _origin.nonce, _dstEid, _oapp, _nativeDropGasLimit);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/LzExecutor.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { IReceiveUlnE2 } from \"./interfaces/IReceiveUlnE2.sol\";\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ExecutionState, EndpointV2ViewUpgradeable } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol\";\n\nimport { VerificationState } from \"./uln302/ReceiveUln302View.sol\";\n\nstruct LzReceiveParam {\n    Origin origin;\n    address receiver;\n    bytes32 guid;\n    bytes message;\n    bytes extraData;\n    uint256 gas;\n    uint256 value;\n}\n\nstruct NativeDropParam {\n    address _receiver;\n    uint256 _amount;\n}\n\ninterface IReceiveUlnView {\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState);\n}\n\ncontract LzExecutor is OwnableUpgradeable, EndpointV2ViewUpgradeable, Proxied {\n    error LzExecutor_Executed();\n    error LzExecutor_Verifying();\n    error LzExecutor_ReceiveLibViewNotSet();\n\n    event NativeWithdrawn(address _to, uint256 _amount);\n    event ReceiveLibViewSet(address _receiveLib, address _receiveLibView);\n\n    address public receiveUln302;\n    uint32 public localEid;\n\n    mapping(address receiveLib => address receiveLibView) public receiveLibToView;\n\n    function initialize(\n        address _receiveUln302,\n        address _receiveUln302View,\n        address _endpoint\n    ) external proxied initializer {\n        __Ownable_init();\n        __EndpointV2View_init(_endpoint);\n\n        receiveUln302 = _receiveUln302;\n        localEid = endpoint.eid();\n        receiveLibToView[_receiveUln302] = _receiveUln302View;\n    }\n\n    // ============================ OnlyOwner ===================================\n\n    function withdrawNative(address _to, uint256 _amount) external onlyOwner {\n        Transfer.native(_to, _amount);\n        emit NativeWithdrawn(_to, _amount);\n    }\n\n    function setReceiveLibView(address _receiveLib, address _receiveLibView) external onlyOwner {\n        receiveLibToView[_receiveLib] = _receiveLibView;\n        emit ReceiveLibViewSet(_receiveLib, _receiveLibView);\n    }\n\n    // ============================ External ===================================\n\n    /// @notice process for commit and execute\n    /// 1. check if executable, revert if executed, execute if executable\n    /// 2. check if verifiable, revert if verifying, commit if verifiable\n    /// 3. native drop\n    /// 4. try execute, will revert if not executable\n    function commitAndExecute(\n        address _receiveLib,\n        LzReceiveParam calldata _lzReceiveParam,\n        NativeDropParam[] calldata _nativeDropParams\n    ) external payable {\n        /// 1. check if executable, revert if executed\n        ExecutionState executionState = executable(_lzReceiveParam.origin, _lzReceiveParam.receiver);\n        if (executionState == ExecutionState.Executed) revert LzExecutor_Executed();\n\n        /// 2. if not executable, check if verifiable, revert if verifying, commit if verifiable\n        if (executionState != ExecutionState.Executable) {\n            address receiveLib = receiveUln302 == address(0x0) ? _receiveLib : address(receiveUln302);\n            bytes memory packetHeader = abi.encodePacked(\n                uint8(1), // packet version 1\n                _lzReceiveParam.origin.nonce,\n                _lzReceiveParam.origin.srcEid,\n                _lzReceiveParam.origin.sender,\n                localEid,\n                bytes32(uint256(uint160(_lzReceiveParam.receiver)))\n            );\n            bytes32 payloadHash = keccak256(abi.encodePacked(_lzReceiveParam.guid, _lzReceiveParam.message));\n\n            address receiveLibView = receiveLibToView[receiveLib];\n            if (receiveLibView == address(0x0)) revert LzExecutor_ReceiveLibViewNotSet();\n\n            VerificationState verificationState = IReceiveUlnView(receiveLibView).verifiable(packetHeader, payloadHash);\n            if (verificationState == VerificationState.Verifiable) {\n                // verification required\n                IReceiveUlnE2(receiveLib).commitVerification(packetHeader, payloadHash);\n            } else if (verificationState == VerificationState.Verifying) {\n                revert LzExecutor_Verifying();\n            }\n        }\n\n        /// 3. native drop\n        for (uint256 i = 0; i < _nativeDropParams.length; i++) {\n            NativeDropParam calldata param = _nativeDropParams[i];\n            Transfer.native(param._receiver, param._amount);\n        }\n\n        /// 4. try execute, will revert if not executable\n        endpoint.lzReceive{ gas: _lzReceiveParam.gas, value: _lzReceiveParam.value }(\n            _lzReceiveParam.origin,\n            _lzReceiveParam.receiver,\n            _lzReceiveParam.guid,\n            _lzReceiveParam.message,\n            _lzReceiveParam.extraData\n        );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/ReceiveUlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { UlnBase, UlnConfig } from \"./UlnBase.sol\";\n\nstruct Verification {\n    bool submitted;\n    uint64 confirmations;\n}\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract ReceiveUlnBase is UlnBase {\n    using PacketV1Codec for bytes;\n\n    mapping(bytes32 headerHash => mapping(bytes32 payloadHash => mapping(address dvn => Verification)))\n        public hashLookup;\n\n    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);\n\n    error LZ_ULN_InvalidPacketHeader();\n    error LZ_ULN_InvalidPacketVersion();\n    error LZ_ULN_InvalidEid();\n    error LZ_ULN_Verifying();\n\n    // ============================ External ===================================\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool) {\n        return _checkVerifiable(_config, _headerHash, _payloadHash);\n    }\n\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure {\n        _assertHeader(_packetHeader, _localEid);\n    }\n\n    // ============================ Internal ===================================\n    /// @dev per DVN signing function\n    function _verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) internal {\n        hashLookup[keccak256(_packetHeader)][_payloadHash][msg.sender] = Verification(true, _confirmations);\n        emit PayloadVerified(msg.sender, _packetHeader, _confirmations, _payloadHash);\n    }\n\n    function _verified(\n        address _dvn,\n        bytes32 _headerHash,\n        bytes32 _payloadHash,\n        uint64 _requiredConfirmation\n    ) internal view returns (bool verified) {\n        Verification memory verification = hashLookup[_headerHash][_payloadHash][_dvn];\n        // return true if the dvn has signed enough confirmations\n        verified = verification.submitted && verification.confirmations >= _requiredConfirmation;\n    }\n\n    function _verifyAndReclaimStorage(UlnConfig memory _config, bytes32 _headerHash, bytes32 _payloadHash) internal {\n        if (!_checkVerifiable(_config, _headerHash, _payloadHash)) {\n            revert LZ_ULN_Verifying();\n        }\n\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                delete hashLookup[_headerHash][_payloadHash][_config.requiredDVNs[i]];\n            }\n        }\n\n        // iterate the optional DVNs\n        if (_config.optionalDVNCount > 0) {\n            for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n                delete hashLookup[_headerHash][_payloadHash][_config.optionalDVNs[i]];\n            }\n        }\n    }\n\n    function _assertHeader(bytes calldata _packetHeader, uint32 _localEid) internal pure {\n        // assert packet header is of right size 81\n        if (_packetHeader.length != 81) revert LZ_ULN_InvalidPacketHeader();\n        // assert packet header version is the same as ULN\n        if (_packetHeader.version() != PacketV1Codec.PACKET_VERSION) revert LZ_ULN_InvalidPacketVersion();\n        // assert the packet is for this endpoint\n        if (_packetHeader.dstEid() != _localEid) revert LZ_ULN_InvalidEid();\n    }\n\n    /// @dev for verifiable view function\n    /// @dev checks if this verification is ready to be committed to the endpoint\n    function _checkVerifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) internal view returns (bool) {\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                if (!_verified(_config.requiredDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\n                    // return if any of the required DVNs haven't signed\n                    return false;\n                }\n            }\n            if (_config.optionalDVNCount == 0) {\n                // returns early if all required DVNs have signed and there are no optional DVNs\n                return true;\n            }\n        }\n\n        // then it must require optional validations\n        uint8 threshold = _config.optionalDVNThreshold;\n        for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n            if (_verified(_config.optionalDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\n                // increment the optional count if the optional DVN has signed\n                threshold--;\n                if (threshold == 0) {\n                    // early return if the optional threshold has hit\n                    return true;\n                }\n            }\n        }\n\n        // return false as a catch-all\n        return false;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/SendUlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { ILayerZeroDVN } from \"./interfaces/ILayerZeroDVN.sol\";\nimport { DVNOptions } from \"./libs/DVNOptions.sol\";\nimport { UlnOptions } from \"./libs/UlnOptions.sol\";\nimport { WorkerOptions } from \"../SendLibBase.sol\";\nimport { UlnConfig, UlnBase } from \"./UlnBase.sol\";\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract SendUlnBase is UlnBase {\n    event DVNFeePaid(address[] requiredDVNs, address[] optionalDVNs, uint256[] fees);\n\n    function _splitUlnOptions(bytes calldata _options) internal pure returns (bytes memory, WorkerOptions[] memory) {\n        (bytes memory executorOpts, bytes memory dvnOpts) = UlnOptions.decode(_options);\n\n        if (dvnOpts.length == 0) {\n            return (executorOpts, new WorkerOptions[](0));\n        }\n\n        WorkerOptions[] memory workerOpts = new WorkerOptions[](1);\n        workerOpts[0] = WorkerOptions(DVNOptions.WORKER_ID, dvnOpts);\n        return (executorOpts, workerOpts);\n    }\n\n    /// ---------- pay and assign jobs ----------\n\n    function _payDVNs(\n        mapping(address => uint256) storage _fees,\n        Packet memory _packet,\n        WorkerOptions[] memory _options\n    ) internal returns (uint256 totalFee, bytes memory encodedPacket) {\n        bytes memory packetHeader = PacketV1Codec.encodePacketHeader(_packet);\n        bytes memory payload = PacketV1Codec.encodePayload(_packet);\n        bytes32 payloadHash = keccak256(payload);\n        uint32 dstEid = _packet.dstEid;\n        address sender = _packet.sender;\n        UlnConfig memory config = getUlnConfig(sender, dstEid);\n\n        // if options is not empty, it must be dvn options\n        bytes memory dvnOptions = _options.length == 0 ? bytes(\"\") : _options[0].options;\n        uint256[] memory dvnFees;\n        (totalFee, dvnFees) = _assignJobs(\n            _fees,\n            config,\n            ILayerZeroDVN.AssignJobParam(dstEid, packetHeader, payloadHash, config.confirmations, sender),\n            dvnOptions\n        );\n        encodedPacket = abi.encodePacked(packetHeader, payload);\n\n        emit DVNFeePaid(config.requiredDVNs, config.optionalDVNs, dvnFees);\n    }\n\n    function _assignJobs(\n        mapping(address => uint256) storage _fees,\n        UlnConfig memory _ulnConfig,\n        ILayerZeroDVN.AssignJobParam memory _param,\n        bytes memory dvnOptions\n    ) internal returns (uint256 totalFee, uint256[] memory dvnFees) {\n        (bytes[] memory optionsArray, uint8[] memory dvnIds) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);\n\n        uint8 dvnsLength = _ulnConfig.requiredDVNCount + _ulnConfig.optionalDVNCount;\n        dvnFees = new uint256[](dvnsLength);\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _ulnConfig.requiredDVNCount\n                ? _ulnConfig.requiredDVNs[i]\n                : _ulnConfig.optionalDVNs[i - _ulnConfig.requiredDVNCount];\n\n            bytes memory options = \"\";\n            for (uint256 j = 0; j < dvnIds.length; ++j) {\n                if (dvnIds[j] == i) {\n                    options = optionsArray[j];\n                    break;\n                }\n            }\n\n            dvnFees[i] = ILayerZeroDVN(dvn).assignJob(_param, options);\n            if (dvnFees[i] > 0) {\n                _fees[dvn] += dvnFees[i];\n                totalFee += dvnFees[i];\n            }\n        }\n    }\n\n    /// ---------- quote ----------\n    function _quoteDVNs(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view returns (uint256 totalFee) {\n        UlnConfig memory config = getUlnConfig(_sender, _dstEid);\n\n        // if options is not empty, it must be dvn options\n        bytes memory dvnOptions = _options.length == 0 ? bytes(\"\") : _options[0].options;\n        (bytes[] memory optionsArray, uint8[] memory dvnIndices) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);\n\n        totalFee = _getFees(config, _dstEid, _sender, optionsArray, dvnIndices);\n    }\n\n    function _getFees(\n        UlnConfig memory _config,\n        uint32 _dstEid,\n        address _sender,\n        bytes[] memory _optionsArray,\n        uint8[] memory _dvnIds\n    ) internal view returns (uint256 totalFee) {\n        // here we merge 2 list of dvns into 1 to allocate the indexed dvn options to the right dvn\n        uint8 dvnsLength = _config.requiredDVNCount + _config.optionalDVNCount;\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _config.requiredDVNCount\n                ? _config.requiredDVNs[i]\n                : _config.optionalDVNs[i - _config.requiredDVNCount];\n\n            bytes memory options = \"\";\n            // it is a double loop here. however, if the list is short, the cost is very acceptable.\n            for (uint256 j = 0; j < _dvnIds.length; ++j) {\n                if (_dvnIds[j] == i) {\n                    options = _optionsArray[j];\n                    break;\n                }\n            }\n            totalFee += ILayerZeroDVN(dvn).getFee(_dstEid, _config.confirmations, _sender, options);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/UlnBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// the formal properties are documented in the setter functions\nstruct UlnConfig {\n    uint64 confirmations;\n    // we store the length of required DVNs and optional DVNs instead of using DVN.length directly to save gas\n    uint8 requiredDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNThreshold; // (0, optionalDVNCount]\n    address[] requiredDVNs; // no duplicates. sorted an an ascending order. allowed overlap with optionalDVNs\n    address[] optionalDVNs; // no duplicates. sorted an an ascending order. allowed overlap with requiredDVNs\n}\n\nstruct SetDefaultUlnConfigParam {\n    uint32 eid;\n    UlnConfig config;\n}\n\n/// @dev includes the utility functions for checking ULN states and logics\nabstract contract UlnBase is Ownable {\n    address private constant DEFAULT_CONFIG = address(0);\n    // reserved values for\n    uint8 internal constant DEFAULT = 0;\n    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;\n    uint64 internal constant NIL_CONFIRMATIONS = type(uint64).max;\n    // 127 to prevent total number of DVNs (127 * 2) exceeding uint8.max (255)\n    // by limiting the total size, it would help constraint the design of DVNOptions\n    uint8 private constant MAX_COUNT = (type(uint8).max - 1) / 2;\n\n    mapping(address oapp => mapping(uint32 eid => UlnConfig)) internal ulnConfigs;\n\n    error LZ_ULN_Unsorted();\n    error LZ_ULN_InvalidRequiredDVNCount();\n    error LZ_ULN_InvalidOptionalDVNCount();\n    error LZ_ULN_AtLeastOneDVN();\n    error LZ_ULN_InvalidOptionalDVNThreshold();\n    error LZ_ULN_InvalidConfirmations();\n    error LZ_ULN_UnsupportedEid(uint32 eid);\n\n    event DefaultUlnConfigsSet(SetDefaultUlnConfigParam[] params);\n    event UlnConfigSet(address oapp, uint32 eid, UlnConfig config);\n\n    // ============================ OnlyOwner ===================================\n\n    /// @dev about the DEFAULT ULN config\n    /// 1) its values are all LITERAL (e.g. 0 is 0). whereas in the oapp ULN config, 0 (default value) points to the default ULN config\n    ///     this design enables the oapp to point to DEFAULT config without explicitly setting the config\n    /// 2) its configuration is more restrictive than the oapp ULN config that\n    ///     a) it must not use NIL value, where NIL is used only by oapps to indicate the LITERAL 0\n    ///     b) it must have at least one DVN\n    function setDefaultUlnConfigs(SetDefaultUlnConfigParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultUlnConfigParam calldata param = _params[i];\n\n            // 2.a must not use NIL\n            if (param.config.requiredDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidRequiredDVNCount();\n            if (param.config.optionalDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidOptionalDVNCount();\n            if (param.config.confirmations == NIL_CONFIRMATIONS) revert LZ_ULN_InvalidConfirmations();\n\n            // 2.b must have at least one dvn\n            _assertAtLeastOneDVN(param.config);\n\n            _setConfig(DEFAULT_CONFIG, param.eid, param.config);\n        }\n        emit DefaultUlnConfigsSet(_params);\n    }\n\n    // ============================ View ===================================\n    // @dev assuming most oapps use default, we get default as memory and custom as storage to save gas\n    function getUlnConfig(address _oapp, uint32 _remoteEid) public view returns (UlnConfig memory rtnConfig) {\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\n        UlnConfig storage customConfig = ulnConfigs[_oapp][_remoteEid];\n\n        // if confirmations is 0, use default\n        uint64 confirmations = customConfig.confirmations;\n        if (confirmations == DEFAULT) {\n            rtnConfig.confirmations = defaultConfig.confirmations;\n        } else if (confirmations != NIL_CONFIRMATIONS) {\n            // if confirmations is uint64.max, no block confirmations required\n            rtnConfig.confirmations = confirmations;\n        } // else do nothing, rtnConfig.confirmation is 0\n\n        if (customConfig.requiredDVNCount == DEFAULT) {\n            if (defaultConfig.requiredDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.requiredDVNs = defaultConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = defaultConfig.requiredDVNCount;\n            } // else, do nothing\n        } else {\n            if (customConfig.requiredDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.requiredDVNs = customConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = customConfig.requiredDVNCount;\n            } // else, do nothing\n        }\n\n        if (customConfig.optionalDVNCount == DEFAULT) {\n            if (defaultConfig.optionalDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.optionalDVNs = defaultConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = defaultConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = defaultConfig.optionalDVNThreshold;\n            }\n        } else {\n            if (customConfig.optionalDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.optionalDVNs = customConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = customConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = customConfig.optionalDVNThreshold;\n            }\n        }\n\n        // the final value must have at least one dvn\n        // it is possible that some default config result into 0 dvns\n        _assertAtLeastOneDVN(rtnConfig);\n    }\n\n    /// @dev Get the uln config without the default config for the given remoteEid.\n    function getAppUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory) {\n        return ulnConfigs[_oapp][_remoteEid];\n    }\n\n    // ============================ Internal ===================================\n    function _setUlnConfig(uint32 _remoteEid, address _oapp, UlnConfig memory _param) internal {\n        _setConfig(_oapp, _remoteEid, _param);\n\n        // get ULN config again as a catch all to ensure the config is valid\n        getUlnConfig(_oapp, _remoteEid);\n        emit UlnConfigSet(_oapp, _remoteEid, _param);\n    }\n\n    /// @dev a supported Eid must have a valid default uln config, which has at least one dvn\n    function _isSupportedEid(uint32 _remoteEid) internal view returns (bool) {\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\n        return defaultConfig.requiredDVNCount > 0 || defaultConfig.optionalDVNThreshold > 0;\n    }\n\n    function _assertSupportedEid(uint32 _remoteEid) internal view {\n        if (!_isSupportedEid(_remoteEid)) revert LZ_ULN_UnsupportedEid(_remoteEid);\n    }\n\n    // ============================ Private ===================================\n\n    function _assertAtLeastOneDVN(UlnConfig memory _config) private pure {\n        if (_config.requiredDVNCount == 0 && _config.optionalDVNThreshold == 0) revert LZ_ULN_AtLeastOneDVN();\n    }\n\n    /// @dev this private function is used in both setDefaultUlnConfigs and setUlnConfig\n    function _setConfig(address _oapp, uint32 _eid, UlnConfig memory _param) private {\n        // @dev required dvns\n        // if dvnCount == NONE, dvns list must be empty\n        // if dvnCount == DEFAULT, dvn list must be empty\n        // otherwise, dvnList.length == dvnCount and assert the list is valid\n        if (_param.requiredDVNCount == NIL_DVN_COUNT || _param.requiredDVNCount == DEFAULT) {\n            if (_param.requiredDVNs.length != 0) revert LZ_ULN_InvalidRequiredDVNCount();\n        } else {\n            if (_param.requiredDVNs.length != _param.requiredDVNCount || _param.requiredDVNCount > MAX_COUNT)\n                revert LZ_ULN_InvalidRequiredDVNCount();\n            _assertNoDuplicates(_param.requiredDVNs);\n        }\n\n        // @dev optional dvns\n        // if optionalDVNCount == NONE, optionalDVNs list must be empty and threshold must be 0\n        // if optionalDVNCount == DEFAULT, optionalDVNs list must be empty and threshold must be 0\n        // otherwise, optionalDVNs.length == optionalDVNCount, threshold > 0 && threshold <= optionalDVNCount and assert the list is valid\n\n        // example use case: an oapp uses the DEFAULT 'required' but\n        //     a) use a custom 1/1 dvn (practically a required dvn), or\n        //     b) use a custom 2/3 dvn\n        if (_param.optionalDVNCount == NIL_DVN_COUNT || _param.optionalDVNCount == DEFAULT) {\n            if (_param.optionalDVNs.length != 0) revert LZ_ULN_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold != 0) revert LZ_ULN_InvalidOptionalDVNThreshold();\n        } else {\n            if (_param.optionalDVNs.length != _param.optionalDVNCount || _param.optionalDVNCount > MAX_COUNT)\n                revert LZ_ULN_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold == 0 || _param.optionalDVNThreshold > _param.optionalDVNCount)\n                revert LZ_ULN_InvalidOptionalDVNThreshold();\n            _assertNoDuplicates(_param.optionalDVNs);\n        }\n        // don't assert valid count here, as it needs to be validated along side default config\n\n        ulnConfigs[_oapp][_eid] = _param;\n    }\n\n    function _assertNoDuplicates(address[] memory _dvns) private pure {\n        address lastDVN = address(0);\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            address dvn = _dvns[i];\n            if (dvn <= lastDVN) revert LZ_ULN_Unsorted(); // to ensure no duplicates\n            lastDVN = dvn;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/DVN.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroUltraLightNodeV2 } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\nimport { Worker } from \"../../Worker.sol\";\nimport { MultiSig } from \"./MultiSig.sol\";\nimport { ReadLib1002 } from \"../readlib/ReadLib1002.sol\";\nimport { IDVN } from \"../interfaces/IDVN.sol\";\nimport { IDVNFeeLib } from \"../interfaces/IDVNFeeLib.sol\";\nimport { IReceiveUlnE2 } from \"../interfaces/IReceiveUlnE2.sol\";\n\nstruct ExecuteParam {\n    uint32 vid;\n    address target;\n    bytes callData;\n    uint256 expiration;\n    bytes signatures;\n}\n\ncontract DVN is Worker, MultiSig, IDVN {\n    // to uniquely identify this DVN instance\n    // set to endpoint v1 eid if available OR endpoint v2 eid % 30_000\n    uint32 public immutable vid;\n    uint32 public immutable localEidV2; // endpoint-v2 only, for read call\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n    mapping(bytes32 executableHash => bool used) public usedHashes;\n\n    error DVN_OnlySelf();\n    error DVN_InvalidRole(bytes32 role);\n    error DVN_InstructionExpired();\n    error DVN_InvalidTarget(address target);\n    error DVN_InvalidVid(uint32 vid);\n    error DVN_InvalidSignatures();\n    error DVN_DuplicatedHash(bytes32 executableHash);\n\n    event VerifySignaturesFailed(uint256 idx);\n    event ExecuteFailed(uint256 _index, bytes _data);\n    event HashAlreadyUsed(ExecuteParam param, bytes32 _hash);\n    // same as DVNFeePaid, but for ULNv2\n    event VerifierFeePaid(uint256 fee);\n\n    // ========================= Constructor =========================\n\n    /// @dev DVN doesn't have a roleAdmin (address(0x0))\n    /// @dev Supports all of ULNv2, ULN301, ULN302 and more\n    /// @param _localEidV2 local endpoint-v2 eid\n    /// @param _vid unique identifier for this DVN instance\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _signers array of signer addresses for multisig\n    /// @param _quorum quorum for multisig\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    constructor(\n        uint32 _localEidV2,\n        uint32 _vid,\n        address[] memory _messageLibs,\n        address _priceFeed,\n        address[] memory _signers,\n        uint64 _quorum,\n        address[] memory _admins\n    ) Worker(_messageLibs, _priceFeed, 12000, address(0x0), _admins) MultiSig(_signers, _quorum) {\n        vid = _vid;\n        localEidV2 = _localEidV2;\n    }\n\n    // ========================= Modifier =========================\n\n    /// @dev depending on role, restrict access to only self or admin\n    /// @dev ALLOWLIST, DENYLIST, MESSAGE_LIB_ROLE can only be granted/revoked by self\n    /// @dev ADMIN_ROLE can only be granted/revoked by admin\n    /// @dev reverts if not one of the above roles\n    /// @param _role role to check\n    modifier onlySelfOrAdmin(bytes32 _role) {\n        if (_role == ALLOWLIST || _role == DENYLIST || _role == MESSAGE_LIB_ROLE) {\n            // self required\n            if (address(this) != msg.sender) {\n                revert DVN_OnlySelf();\n            }\n        } else if (_role == ADMIN_ROLE) {\n            // admin required\n            _checkRole(ADMIN_ROLE);\n        } else {\n            revert DVN_InvalidRole(_role);\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (address(this) != msg.sender) {\n            revert DVN_OnlySelf();\n        }\n        _;\n    }\n\n    // ========================= OnlySelf =========================\n\n    /// @dev set signers for multisig\n    /// @dev function sig 0x31cb6105\n    /// @param _signer signer address\n    /// @param _active true to add, false to remove\n    function setSigner(address _signer, bool _active) external onlySelf {\n        _setSigner(_signer, _active);\n    }\n\n    /// @dev set quorum for multisig\n    /// @dev function sig 0x8585c945\n    /// @param _quorum to set\n    function setQuorum(uint64 _quorum) external onlySelf {\n        _setQuorum(_quorum);\n    }\n\n    // ========================= OnlySelf / OnlyAdmin =========================\n\n    /// @dev overrides AccessControl to allow self/admin to grant role'\n    /// @dev function sig 0x2f2ff15d\n    /// @param _role role to grant\n    /// @param _account account to grant role to\n    function grantRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {\n        _grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow self/admin to revoke role\n    /// @dev function sig 0xd547741f\n    /// @param _role role to revoke\n    /// @param _account account to revoke role from\n    function revokeRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {\n        _revokeRole(_role, _account);\n    }\n\n    // ========================= OnlyQuorum =========================\n\n    /// @notice function for quorum to change admin without going through execute function\n    /// @dev calldata in the case is abi.encode new admin address\n    function quorumChangeAdmin(ExecuteParam calldata _param) external {\n        if (_param.expiration <= block.timestamp) {\n            revert DVN_InstructionExpired();\n        }\n        if (_param.target != address(this)) {\n            revert DVN_InvalidTarget(_param.target);\n        }\n        if (_param.vid != vid) {\n            revert DVN_InvalidVid(_param.vid);\n        }\n\n        // generate and validate hash\n        bytes32 hash = hashCallData(_param.vid, _param.target, _param.callData, _param.expiration);\n        (bool sigsValid, ) = verifySignatures(hash, _param.signatures);\n        if (!sigsValid) {\n            revert DVN_InvalidSignatures();\n        }\n        if (usedHashes[hash]) {\n            revert DVN_DuplicatedHash(hash);\n        }\n\n        usedHashes[hash] = true;\n        _grantRole(ADMIN_ROLE, abi.decode(_param.callData, (address)));\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _params array of DstConfigParam\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            DstConfigParam calldata param = _params[i];\n            dstConfig[param.dstEid] = DstConfig(param.gas, param.multiplierBps, param.floorMarginUSD);\n        }\n        emit SetDstConfig(_params);\n    }\n\n    /// @dev takes a list of instructions and executes them in order\n    /// @dev if any of the instructions fail, it will emit an error event and continue to execute the rest of the instructions\n    /// @param _params array of ExecuteParam, includes target, callData, expiration, signatures\n    function execute(ExecuteParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            ExecuteParam calldata param = _params[i];\n            // 1. skip if invalid vid\n            if (param.vid != vid) {\n                continue;\n            }\n\n            // 2. skip if expired\n            if (param.expiration <= block.timestamp) {\n                continue;\n            }\n\n            // generate and validate hash\n            bytes32 hash = hashCallData(param.vid, param.target, param.callData, param.expiration);\n\n            // 3. check signatures\n            (bool sigsValid, ) = verifySignatures(hash, param.signatures);\n            if (!sigsValid) {\n                emit VerifySignaturesFailed(i);\n                continue;\n            }\n\n            // 4. should check hash\n            bool shouldCheckHash = _shouldCheckHash(bytes4(param.callData));\n            if (shouldCheckHash) {\n                if (usedHashes[hash]) {\n                    emit HashAlreadyUsed(param, hash);\n                    continue;\n                } else {\n                    usedHashes[hash] = true; // prevent reentry and replay attack\n                }\n            }\n\n            (bool success, bytes memory rtnData) = param.target.call(param.callData);\n            if (!success) {\n                if (shouldCheckHash) {\n                    // need to unset the usedHash otherwise it cant be used\n                    usedHashes[hash] = false;\n                }\n                // emit an event in any case\n                emit ExecuteFailed(i, rtnData);\n            }\n        }\n    }\n\n    /// @dev to support ULNv2\n    /// @dev the withdrawFee function for ULN30X is built in the Worker contract\n    /// @param _lib message lib address\n    /// @param _to address to withdraw to\n    /// @param _amount amount to withdraw\n    function withdrawFeeFromUlnV2(address _lib, address payable _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) {\n            revert Worker_OnlyMessageLib();\n        }\n        ILayerZeroUltraLightNodeV2(_lib).withdrawNative(_to, _amount);\n    }\n\n    // ========================= OnlyMessageLib =========================\n\n    /// @dev for ULN301, ULN302 and more to assign job\n    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist\n    /// @param _param assign job param\n    /// @param _options dvn options\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_param.sender) returns (uint256 totalFee) {\n        IDVNFeeLib.FeeParams memory feeParams = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _param.dstEid,\n            _param.confirmations,\n            _param.sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(feeParams, dstConfig[_param.dstEid], _options);\n    }\n\n    /// @dev to support ULNv2\n    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist\n    /// @param _dstEid destination EndpointId\n    /// @param //_outboundProofType outbound proof type\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    function assignJob(\n        uint16 _dstEid,\n        uint16 /*_outboundProofType*/,\n        uint64 _confirmations,\n        address _sender\n    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) returns (uint256 totalFee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        // ULNV2 does not have dvn options\n        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], bytes(\"\"));\n        emit VerifierFeePaid(totalFee);\n    }\n\n    /// @dev to support ReadLib\n    // @param _packetHeader - version + nonce + path\n    // @param _cmd - the command to be executed to obtain the payload\n    // @param _options - options\n    function assignJob(\n        address _sender,\n        bytes calldata /*_packetHeader*/,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external payable onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParamsForRead memory feeParams = IDVNFeeLib.FeeParamsForRead(\n            priceFeed,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        fee = IDVNFeeLib(workerFeeLib).getFeeOnSend(feeParams, dstConfig[localEidV2], _cmd, _options);\n    }\n\n    // ========================= View =========================\n\n    /// @dev getFee can revert if _sender doesn't pass ACL\n    /// @param _dstEid destination EndpointId\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    /// @param _options dvn options\n    /// @return fee fee in native amount\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        fee = IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);\n    }\n\n    /// @dev to support ULNv2\n    /// @dev getFee can revert if _sender doesn't pass ACL\n    /// @param _dstEid destination EndpointId\n    /// @param //_outboundProofType outbound proof type\n    /// @param _confirmations block confirmations\n    /// @param _sender message sender address\n    function getFee(\n        uint16 _dstEid,\n        uint16 /*_outboundProofType*/,\n        uint64 _confirmations,\n        address _sender\n    ) public view onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(\n            priceFeed,\n            _dstEid,\n            _confirmations,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        fee = IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], bytes(\"\"));\n    }\n\n    /// @dev to support ReadLib\n    // @param _packetHeader - version + nonce + path\n    // @param _cmd - the command to be executed to obtain the payload\n    // @param _options - options\n    function getFee(\n        address _sender,\n        bytes calldata /*_packetHeader*/,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external view onlyAcl(_sender) returns (uint256 fee) {\n        IDVNFeeLib.FeeParamsForRead memory feeParams = IDVNFeeLib.FeeParamsForRead(\n            priceFeed,\n            _sender,\n            quorum,\n            defaultMultiplierBps\n        );\n        fee = IDVNFeeLib(workerFeeLib).getFee(feeParams, dstConfig[localEidV2], _cmd, _options);\n    }\n\n    /// @param _target target address\n    /// @param _callData call data\n    /// @param _expiration expiration timestamp\n    /// @return hash of above\n    function hashCallData(\n        uint32 _vid,\n        address _target,\n        bytes calldata _callData,\n        uint256 _expiration\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_vid, _target, _expiration, _callData));\n    }\n\n    // ========================= Internal =========================\n\n    /// @dev to save gas, we don't check hash for some functions (where replaying won't change the state)\n    /// @dev for example, some administrative functions like changing signers, the contract should check hash to double spending\n    /// @dev should ensure that all onlySelf functions have unique functionSig\n    /// @param _functionSig function signature\n    /// @return true if should check hash\n    function _shouldCheckHash(bytes4 _functionSig) internal pure returns (bool) {\n        // never check for these selectors to save gas\n        return\n            _functionSig != IReceiveUlnE2.verify.selector && // 0x0223536e, replaying won't change the state\n            _functionSig != ReadLib1002.verify.selector && // 0xab750e75, replaying won't change the state\n            _functionSig != ILayerZeroUltraLightNodeV2.updateHash.selector; // 0x704316e5, replaying will be revert at uln\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/DVNFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { ILayerZeroPriceFeed } from \"../../interfaces/ILayerZeroPriceFeed.sol\";\nimport { IDVN } from \"../interfaces/IDVN.sol\";\nimport { IDVNFeeLib } from \"../interfaces/IDVNFeeLib.sol\";\nimport { DVNOptions } from \"../libs/DVNOptions.sol\";\nimport { ReadCmdCodecV1 } from \"../libs/ReadCmdCodecV1.sol\";\nimport { SupportedCmdTypesLib, SupportedCmdTypes, BitMap256 } from \"../libs/SupportedCmdTypes.sol\";\n\ncontract DVNFeeLib is Ownable, IDVNFeeLib {\n    using DVNOptions for bytes;\n\n    struct SetSupportedCmdTypesParam {\n        uint32 targetEid;\n        BitMap256 types;\n    }\n\n    struct BlockTimeConfig {\n        uint32 avgBlockTime; // milliseconds\n        uint64 blockNum; // the block number of the reference timestamp\n        uint64 timestamp; // second, the reference timestamp of the block number\n        uint32 maxPastRetention; // second, the max retention time the DVN will accept read requests/compute from the past time\n        uint32 maxFutureRetention; // second, the max retention time the DVN will accept read requests/compute from the future time\n    }\n\n    uint16 internal constant BPS_BASE = 10000;\n\n    // encoded( execute(ExecuteParam[]) ): funcSigHash + params -> 4  + 32(Offset of the array) + 32(array size) + 32(first element start offset)\\\n    // + 32(vid) + 32(target) + 32(calldata-offset) + 32(expiration) + 32(signatures-offset) = 260\n    uint16 internal constant EXECUTE_FIXED_BYTES = 260;\n    uint16 internal constant SIGNATURE_RAW_BYTES = 65; // not encoded\n    // verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations)\\\n    // 4 + 32(header offset) + 32(payloadHash) + 32(confirmations, 8 -> 32 padded) + 32(header-size) + 96(81 -> header-padded) = 228,\n    // padded to multiples of 32 = 256, encoded as bytes with an 32 byte for the bytes size = 288\n    uint16 internal constant VERIFY_BYTES_ULN = 288;\n    // verify(bytes calldata _packetHeader, bytes32 _cmdHash, bytes32 _payloadHash)\\\n    // 4 + 32(header offset) + 32(cmdHash) + 32(payloadHash) + 32(header-size) + 96(81 -> header-padded) = 228,\n    // padded to multiples of 32 = 256, encoded as bytes with an 32 byte for the bytes size = 288\n    uint16 internal constant VERIFY_BYTES_CMD_LIB = 288;\n\n    uint256 internal immutable nativeDecimalsRate;\n    uint32 internal immutable localEidV2; // endpoint-v2 only, for read call\n\n    SupportedCmdTypes internal supportedCmdTypes;\n\n    uint120 internal evmCallRequestV1FeeUSD;\n    uint120 internal evmCallComputeV1ReduceFeeUSD;\n    uint16 internal evmCallComputeV1MapBps;\n\n    mapping(uint32 dstEid => BlockTimeConfig) public dstBlockTimeConfigs;\n\n    constructor(uint32 _localEidV2, uint256 _nativeDecimalsRate) {\n        localEidV2 = _localEidV2;\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    // ================================ OnlyOwner ================================\n    function setSupportedCmdTypes(SetSupportedCmdTypesParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; i++) {\n            supportedCmdTypes.cmdTypes[_params[i].targetEid] = _params[i].types;\n        }\n    }\n\n    function getSupportedCmdTypes(uint32 _targetEid) external view returns (BitMap256) {\n        return supportedCmdTypes.cmdTypes[_targetEid];\n    }\n\n    function setDstBlockTimeConfigs(\n        uint32[] calldata dstEids,\n        BlockTimeConfig[] calldata _blockConfigs\n    ) external onlyOwner {\n        if (dstEids.length != _blockConfigs.length) revert DVN_INVALID_INPUT_LENGTH();\n        for (uint256 i = 0; i < dstEids.length; i++) {\n            dstBlockTimeConfigs[dstEids[i]] = _blockConfigs[i];\n        }\n    }\n\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    function setCmdFees(\n        uint120 _evmCallRequestV1FeeUSD,\n        uint120 _evmCallComputeV1ReduceFeeUSD,\n        uint16 _evmCallComputeV1MapBps\n    ) external onlyOwner {\n        evmCallRequestV1FeeUSD = _evmCallRequestV1FeeUSD;\n        evmCallComputeV1ReduceFeeUSD = _evmCallComputeV1ReduceFeeUSD;\n        evmCallComputeV1MapBps = _evmCallComputeV1MapBps;\n    }\n\n    function getCmdFees() external view returns (uint120, uint120, uint16) {\n        return (evmCallRequestV1FeeUSD, evmCallComputeV1ReduceFeeUSD, evmCallComputeV1MapBps);\n    }\n\n    // ========================= External =========================\n    /// @dev get fee function that can change state. e.g. paying priceFeed\n    /// @param _params fee params\n    /// @param _dstConfig dst config\n    /// @param //_options options\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external payable returns (uint256) {\n        return getFee(_params, _dstConfig, _options);\n    }\n\n    function getFeeOnSend(\n        FeeParamsForRead calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external payable returns (uint256 fee) {\n        fee = getFee(_params, _dstConfig, _cmd, _options);\n    }\n\n    // ========================= View =========================\n    /// @dev get fee view function\n    /// @param _params fee params\n    /// @param _dstConfig dst config\n    /// @param //_options options\n    function getFee(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) public view returns (uint256) {\n        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(_params.dstEid);\n\n        _decodeDVNOptions(_options); // validate options\n\n        uint256 callDataSize = _getCallDataSize(_params.quorum);\n        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(\n            _params.dstEid,\n            callDataSize,\n            _dstConfig.gas\n        );\n        return\n            _applyPremium(\n                fee,\n                _dstConfig.multiplierBps,\n                _params.defaultMultiplierBps,\n                _dstConfig.floorMarginUSD,\n                nativePriceUSD\n            );\n    }\n\n    function getFee(\n        FeeParamsForRead calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) public view returns (uint256) {\n        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(localEidV2);\n\n        _decodeDVNOptions(_options); // validate options\n\n        uint256 callDataSize = _getReadCallDataSize(_params.quorum);\n        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(\n            localEidV2,\n            callDataSize,\n            _dstConfig.gas\n        );\n\n        // cmdFeeUSD -> cmdFee native final\n        uint256 cmdFeeUSD = _estimateCmdFee(_cmd);\n        uint256 cmdFee = (cmdFeeUSD * nativeDecimalsRate) / nativePriceUSD;\n\n        return\n            _applyPremium(\n                fee + cmdFee,\n                _dstConfig.multiplierBps,\n                _params.defaultMultiplierBps,\n                _dstConfig.floorMarginUSD,\n                nativePriceUSD\n            );\n    }\n\n    // ========================= Internal =========================\n    function _getCallDataSize(uint256 _quorum) internal pure returns (uint256) {\n        return _getCallDataSizeByQuorumAndVerifyBytes(_quorum, VERIFY_BYTES_ULN);\n    }\n\n    function _getReadCallDataSize(uint256 _quorum) internal pure returns (uint256) {\n        return _getCallDataSizeByQuorumAndVerifyBytes(_quorum, VERIFY_BYTES_CMD_LIB);\n    }\n\n    function _getCallDataSizeByQuorumAndVerifyBytes(\n        uint256 _quorum,\n        uint256 verifyBytes\n    ) internal pure returns (uint256) {\n        uint256 totalSignatureBytes = _quorum * SIGNATURE_RAW_BYTES;\n        if (totalSignatureBytes % 32 != 0) {\n            totalSignatureBytes = totalSignatureBytes - (totalSignatureBytes % 32) + 32;\n        }\n        // getFee should charge on execute(updateHash)\n        // totalSignatureBytesPadded also has 32 as size of the bytes\n        return uint256(EXECUTE_FIXED_BYTES) + verifyBytes + totalSignatureBytes + 32;\n    }\n\n    function _applyPremium(\n        uint256 _fee,\n        uint16 _bps,\n        uint16 _defaultBps,\n        uint128 _marginUSD,\n        uint128 _nativePriceUSD\n    ) internal view returns (uint256) {\n        uint16 multiplierBps = _bps == 0 ? _defaultBps : _bps;\n\n        uint256 feeWithMultiplier = (_fee * multiplierBps) / 10000;\n        if (_nativePriceUSD == 0 || _marginUSD == 0) {\n            return feeWithMultiplier;\n        }\n\n        uint256 feeWithFloorMargin = _fee + (_marginUSD * nativeDecimalsRate) / _nativePriceUSD;\n\n        return feeWithFloorMargin > feeWithMultiplier ? feeWithFloorMargin : feeWithMultiplier;\n    }\n\n    function _decodeDVNOptions(bytes calldata _options) internal pure returns (uint256) {\n        uint256 cursor;\n        while (cursor < _options.length) {\n            (uint8 optionType, , uint256 newCursor) = _options.nextDVNOption(cursor);\n            cursor = newCursor;\n            revert DVN_UnsupportedOptionType(optionType);\n        }\n        if (cursor != _options.length) revert DVNOptions.DVN_InvalidDVNOptions(cursor);\n\n        return 0; // todo: precrime fee model\n    }\n\n    function _estimateCmdFee(bytes calldata _cmd) internal view returns (uint256 fee) {\n        ReadCmdCodecV1.Cmd memory cmd = ReadCmdCodecV1.decode(_cmd, _assertCmdTypeSupported);\n        fee = cmd.numEvmCallRequestV1 * evmCallRequestV1FeeUSD;\n        if (cmd.evmCallComputeV1Map) {\n            fee += (fee * evmCallComputeV1MapBps) / BPS_BASE;\n        }\n        if (cmd.evmCallComputeV1Reduce) {\n            fee += evmCallComputeV1ReduceFeeUSD;\n        }\n    }\n\n    function _assertCmdTypeSupported(\n        uint32 _targetEid,\n        bool _isBlockNum,\n        uint64 _blockNumOrTimestamp,\n        uint8 _cmdType\n    ) internal view {\n        supportedCmdTypes.assertSupported(_targetEid, _cmdType);\n        if (supportedCmdTypes.isSupported(_targetEid, SupportedCmdTypesLib.CMD_V1__TIMESTAMP_VALIDATE)) {\n            BlockTimeConfig memory blockCnf = dstBlockTimeConfigs[_targetEid];\n            uint64 timestamp = _blockNumOrTimestamp;\n            if (_isBlockNum) {\n                // convert the blockNum to the timestamp\n                if (_blockNumOrTimestamp > blockCnf.blockNum) {\n                    timestamp =\n                        blockCnf.timestamp +\n                        ((_blockNumOrTimestamp - blockCnf.blockNum) * blockCnf.avgBlockTime) /\n                        1000;\n                } else {\n                    timestamp =\n                        blockCnf.timestamp -\n                        ((blockCnf.blockNum - _blockNumOrTimestamp) * blockCnf.avgBlockTime) /\n                        1000;\n                }\n            }\n            if (\n                timestamp + blockCnf.maxPastRetention < block.timestamp ||\n                timestamp > block.timestamp + blockCnf.maxFutureRetention\n            ) {\n                revert DVN_TimestampOutOfRange(_targetEid, timestamp);\n            }\n        }\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor) {\n        return (1, 1);\n    }\n\n    // send funds here to pay for price feed directly\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/DeadDVN.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroDVN } from \"../interfaces/ILayerZeroDVN.sol\";\n\ncontract DeadDVN is ILayerZeroDVN {\n    string internal constant ERROR_NOT_ALLOWED = \"Please set your OApp's DVNs and/or Executor\";\n\n    /// @dev for ULN301, ULN302 and more to assign job\n    function assignJob(AssignJobParam calldata, bytes calldata) external payable returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    /// @dev to support ULNv2\n    function assignJob(uint16, uint16, uint64, address) external pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    // ========================= View =========================\n\n    function getFee(uint32, uint64, address, bytes calldata) external pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n\n    /// @dev to support ULNv2\n    function getFee(uint16, uint16, uint64, address) public pure returns (uint256) {\n        revert(ERROR_NOT_ALLOWED);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/MultiSig.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nabstract contract MultiSig {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    enum Errors {\n        NoError,\n        SignatureError,\n        DuplicatedSigner,\n        SignerNotInCommittee\n    }\n\n    EnumerableSet.AddressSet internal signerSet;\n    uint64 public quorum;\n\n    error MultiSig_OnlySigner();\n    error MultiSig_QuorumIsZero();\n    error MultiSig_SignersSizeIsLessThanQuorum(uint64 signersSize, uint64 quorum);\n    error MultiSig_UnorderedSigners();\n    error MultiSig_StateAlreadySet(address signer, bool active);\n    error MultiSig_StateNotSet(address signer, bool active);\n    error MultiSig_InvalidSigner();\n\n    event UpdateSigner(address _signer, bool _active);\n    event UpdateQuorum(uint64 _quorum);\n\n    modifier onlySigner() {\n        if (!isSigner(msg.sender)) {\n            revert MultiSig_OnlySigner();\n        }\n        _;\n    }\n\n    constructor(address[] memory _signers, uint64 _quorum) {\n        if (_quorum == 0) {\n            revert MultiSig_QuorumIsZero();\n        }\n        for (uint256 i = 0; i < _signers.length; i++) {\n            address signer = _signers[i];\n            if (signer == address(0)) {\n                revert MultiSig_InvalidSigner();\n            }\n            signerSet.add(signer);\n        }\n\n        uint64 _signerSize = uint64(signerSet.length());\n        if (_signerSize < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);\n        }\n\n        quorum = _quorum;\n    }\n\n    function _setSigner(address _signer, bool _active) internal {\n        if (_active) {\n            if (_signer == address(0)) {\n                revert MultiSig_InvalidSigner();\n            }\n            if (!signerSet.add(_signer)) {\n                revert MultiSig_StateAlreadySet(_signer, _active);\n            }\n        } else {\n            if (!signerSet.remove(_signer)) {\n                revert MultiSig_StateNotSet(_signer, _active);\n            }\n        }\n\n        uint64 _signerSize = uint64(signerSet.length());\n        uint64 _quorum = quorum;\n        if (_signerSize < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);\n        }\n        emit UpdateSigner(_signer, _active);\n    }\n\n    function _setQuorum(uint64 _quorum) internal {\n        if (_quorum == 0) {\n            revert MultiSig_QuorumIsZero();\n        }\n        uint64 _signerSize = uint64(signerSet.length());\n        if (_signerSize < _quorum) {\n            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);\n        }\n        quorum = _quorum;\n        emit UpdateQuorum(_quorum);\n    }\n\n    function verifySignatures(bytes32 _hash, bytes calldata _signatures) public view returns (bool, Errors) {\n        if (_signatures.length != uint256(quorum) * 65) {\n            return (false, Errors.SignatureError);\n        }\n\n        bytes32 messageDigest = _getEthSignedMessageHash(_hash);\n\n        address lastSigner = address(0); // There cannot be a signer with address 0.\n        for (uint256 i = 0; i < quorum; i++) {\n            // the quorum is guaranteed not to be zero in the constructor and setter\n            bytes calldata signature = _signatures[i * 65:(i + 1) * 65];\n            (address currentSigner, ECDSA.RecoverError error) = ECDSA.tryRecover(messageDigest, signature);\n\n            if (error != ECDSA.RecoverError.NoError) return (false, Errors.SignatureError);\n            if (currentSigner <= lastSigner) return (false, Errors.DuplicatedSigner); // prevent duplicate signatures, the signers must be ordered to sign the digest\n            if (!isSigner(currentSigner)) return (false, Errors.SignerNotInCommittee); // signature is not in committee\n            lastSigner = currentSigner;\n        }\n        return (true, Errors.NoError);\n    }\n\n    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n\n    // ============================================== View ==============================================\n    function getSigners() public view returns (address[] memory) {\n        return signerSet.values();\n    }\n\n    // compatibility with the previous version\n    function signers(address _signer) public view returns (bool) {\n        return isSigner(_signer);\n    }\n\n    function isSigner(address _signer) public view returns (bool) {\n        return signerSet.contains(_signer);\n    }\n\n    function signerSize() public view returns (uint256) {\n        return signerSet.length();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/SimpleReadDVN.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\n\nimport { ILayerZeroReadDVN } from \"../interfaces/ILayerZeroReadDVN.sol\";\nimport { ReadCmdCodecV1 } from \"../libs/ReadCmdCodecV1.sol\";\nimport { ReadLib1002 } from \"../readlib/ReadLib1002.sol\";\nimport { SupportedCmdTypes } from \"../libs/SupportedCmdTypes.sol\";\n\ncontract SimpleReadDVN is ILayerZeroReadDVN {\n    struct SetSupportedCmdTypesParam {\n        uint32 targetEid;\n        BitMap256 types;\n    }\n\n    uint128 internal constant DENOMINATOR = 10 ** 18;\n    uint128 internal constant NATIVE_DECIMALS = 10 ** 18;\n\n    uint16 internal constant BPS_BASE = 10000;\n\n    address payable public immutable readLib;\n\n    // the usd fee should be usd * DENOMINATOR\n    uint128 internal evmCallRequestV1FeeUSD;\n    uint128 internal evmCallComputeV1MapFeeUSD;\n    uint128 internal evmCallComputeV1ReduceFeeUSD;\n\n    uint128 internal nativePriceUSD; // usd * DENOMINATOR\n\n    SupportedCmdTypes internal supportedCmdTypes;\n\n    constructor(address payable _readLib) {\n        readLib = _readLib;\n    }\n\n    function setSupportedCmdTypes(SetSupportedCmdTypesParam[] calldata _params) external {\n        for (uint256 i = 0; i < _params.length; i++) {\n            supportedCmdTypes.cmdTypes[_params[i].targetEid] = _params[i].types;\n        }\n    }\n\n    function assignJob(\n        address /*_sender*/,\n        bytes calldata /*_packetHeader*/,\n        bytes calldata _cmd,\n        bytes calldata /*_options*/\n    ) external payable returns (uint256) {\n        uint256 cmdFeeUSD = _estimateCmdFee(_cmd);\n        uint256 cmdFee = (cmdFeeUSD * NATIVE_DECIMALS) / nativePriceUSD;\n\n        return cmdFee;\n    }\n\n    function verify(bytes calldata _packetHeader, bytes32 _cmdHash, bytes32 _payloadHash) external {\n        ReadLib1002(readLib).verify(_packetHeader, _cmdHash, _payloadHash);\n    }\n\n    // ========================= View =========================\n\n    function getFee(\n        address /*_sender*/,\n        bytes calldata /*_packetHeader*/,\n        bytes calldata _cmd,\n        bytes calldata /*_options*/\n    ) external view returns (uint256) {\n        // cmdFeeUSD -> cmdFee native\n        uint256 cmdFeeUSD = _estimateCmdFee(_cmd);\n        uint256 cmdFee = (cmdFeeUSD * NATIVE_DECIMALS) / nativePriceUSD;\n\n        return cmdFee;\n    }\n\n    function setCmdFees(\n        uint128 _evmCallReqV1FeeUSD,\n        uint128 _evmCallComputeV1MapFeeUSD,\n        uint128 _evmCallComputeV1ReduceFeeUSD,\n        uint128 _nativePriceUSD\n    ) external {\n        evmCallRequestV1FeeUSD = _evmCallReqV1FeeUSD;\n        evmCallComputeV1MapFeeUSD = _evmCallComputeV1MapFeeUSD;\n        evmCallComputeV1ReduceFeeUSD = _evmCallComputeV1ReduceFeeUSD;\n        nativePriceUSD = _nativePriceUSD;\n    }\n\n    function getCmdFees() external view returns (uint128, uint128, uint128, uint128) {\n        return (evmCallRequestV1FeeUSD, evmCallComputeV1MapFeeUSD, evmCallComputeV1ReduceFeeUSD, nativePriceUSD);\n    }\n\n    function _estimateCmdFee(bytes calldata _cmd) internal view returns (uint256 fee) {\n        ReadCmdCodecV1.Cmd memory cmd = ReadCmdCodecV1.decode(_cmd, _assertCmdTypeSupported);\n        fee = cmd.numEvmCallRequestV1 * evmCallRequestV1FeeUSD;\n        if (cmd.evmCallComputeV1Map) {\n            fee += evmCallComputeV1MapFeeUSD * cmd.numEvmCallRequestV1;\n        }\n        if (cmd.evmCallComputeV1Reduce) {\n            fee += evmCallComputeV1ReduceFeeUSD;\n        }\n    }\n\n    function _assertCmdTypeSupported(\n        uint32 _targetEid,\n        bool /*_isBlockNum*/,\n        uint64 /*_blockNumOrTimestamp*/,\n        uint8 _cmdType\n    ) internal view {\n        supportedCmdTypes.assertSupported(_targetEid, _cmdType);\n    }\n\n    receive() external payable virtual {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { IAny2EVMMessageReceiver } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { ICCIPDVNAdapter } from \"../../../interfaces/adapters/ICCIPDVNAdapter.sol\";\nimport { ICCIPDVNAdapterFeeLib } from \"../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol\";\n\n/// @title CCIPDVNAdapter\n/// @dev How CCIP DVN Adapter works:\n/// 1. Estimate gas cost for the message on-chain by calling `getFee` on the Router contract.\n///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#getfee\n/// 2. Call `ccipSend` on the Router contract to send the message.\n///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#ccipsend\n/// @dev Recovery:\n/// 1. If not enough gas paid, the message will be failed to execute on the destination chain, you can manually retry by calling `manuallyExecute` on the `OffRamp` contract.\n///     refer to https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/offRamp/EVM2EVMOffRamp.sol#L222\ncontract CCIPDVNAdapter is DVNAdapterBase, IAny2EVMMessageReceiver, ICCIPDVNAdapter {\n    address private constant NATIVE_GAS_TOKEN_ADDRESS = address(0);\n\n    IRouterClient public immutable router;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n    mapping(uint64 srcChainSelector => SrcConfig) public srcConfig;\n\n    constructor(address[] memory _admins, address _router) DVNAdapterBase(msg.sender, _admins, 12000) {\n        router = IRouterClient(_router);\n    }\n\n    // ========================= OnlyAdmin =========================\n    /// @notice sets configuration for destination chains\n    /// @param _params array of chain configurations\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam calldata param = _params[i];\n\n            uint32 eid = param.eid % 30000;\n\n            // set once per chainSelector\n            // only one adapter per dvn that services both endpoint v1 and v2\n            // we standardize the eid stored here with mod 30000\n            if (dstConfig[eid].chainSelector == 0) {\n                dstConfig[eid].chainSelector = param.chainSelector;\n                dstConfig[eid].peer = param.peer;\n                srcConfig[param.chainSelector].eid = eid;\n                srcConfig[param.chainSelector].peer = param.peer;\n            }\n\n            dstConfig[eid].multiplierBps = param.multiplierBps;\n            dstConfig[eid].gas = param.gas;\n        }\n\n        emit DstConfigSet(_params);\n    }\n\n    // ========================= OnlyMessageLib =========================\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable override onlyAcl(_param.sender) returns (uint256 totalFee) {\n        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(\n            _param.dstEid,\n            _param.confirmations,\n            _param.sender,\n            defaultMultiplierBps\n        );\n\n        DstConfig memory config = dstConfig[_param.dstEid % 30000];\n\n        bytes memory data = _encode(receiveLib, _param.packetHeader, _param.payloadHash);\n        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);\n\n        IRouterClient ccipRouter = router;\n        uint256 ccipFee;\n        (ccipFee, totalFee) = ICCIPDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(\n            feeLibParam,\n            config,\n            message,\n            _options,\n            ccipRouter\n        );\n\n        _assertBalanceAndWithdrawFee(msg.sender, ccipFee);\n\n        ccipRouter.ccipSend{ value: ccipFee }(config.chainSelector, message);\n    }\n\n    // ========================= OnlyRouter =========================\n    function ccipReceive(Client.Any2EVMMessage calldata _message) external {\n        if (msg.sender != address(router)) revert CCIPDVNAdapter_InvalidRouter(msg.sender);\n\n        SrcConfig memory config = srcConfig[_message.sourceChainSelector];\n\n        _assertPeer(_message.sourceChainSelector, _message.sender, config.peer);\n\n        _decodeAndVerify(config.eid, _message.data);\n    }\n\n    // ========================= View =========================\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view override onlyAcl(_sender) returns (uint256 totalFee) {\n        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(\n            _dstEid,\n            _confirmations,\n            _sender,\n            defaultMultiplierBps\n        );\n\n        DstConfig memory config = dstConfig[_dstEid % 30000];\n\n        bytes memory data = _encodeEmpty();\n        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);\n\n        totalFee = ICCIPDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, config, message, _options, router);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // ========================= Internal =========================\n    function _createCCIPMessage(\n        bytes memory _data,\n        bytes memory _receiver,\n        uint256 _gas\n    ) private pure returns (Client.EVM2AnyMessage memory message) {\n        message = Client.EVM2AnyMessage({\n            receiver: _receiver,\n            data: _data,\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: _gas, strict: false })),\n            feeToken: NATIVE_GAS_TOKEN_ADDRESS\n        });\n    }\n\n    function _assertPeer(uint64 _sourceChainSelector, bytes memory _sourceAddress, bytes memory peer) private pure {\n        if (keccak256(_sourceAddress) != keccak256(peer)) {\n            revert CCIPDVNAdapter_UntrustedPeer(_sourceChainSelector, _sourceAddress);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\n\nimport { ICCIPDVNAdapter } from \"../../../interfaces/adapters/ICCIPDVNAdapter.sol\";\nimport { ICCIPDVNAdapterFeeLib } from \"../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol\";\n\ncontract CCIPDVNAdapterFeeLib is OwnableUpgradeable, Proxied, ICCIPDVNAdapterFeeLib {\n    uint16 internal constant BPS_DENOMINATOR = 10000;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    function initialize() external proxied initializer {\n        __Ownable_init();\n    }\n\n    // ================================ OnlyOwner ===============================\n    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {\n        for (uint256 i = 0; i < _param.length; i++) {\n            DstConfigParam calldata param = _param[i];\n\n            dstConfig[param.dstEid] = DstConfig({ floorMarginUSD: param.floorMarginUSD });\n        }\n\n        emit DstConfigSet(_param);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external payable returns (uint256 ccipFee, uint256 totalFee) {\n        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);\n        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();\n\n        ccipFee = _router.getFee(_dstConfig.chainSelector, _message);\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, ccipFee);\n    }\n\n    function getFee(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external view returns (uint256 totalFee) {\n        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);\n        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();\n\n        totalFee = _router.getFee(_dstConfig.chainSelector, _message);\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, totalFee);\n    }\n\n    // ================================ Internal ================================\n    function _applyPremium(\n        uint16 _multiplierBps,\n        uint16 _defaultMultiplierBps,\n        uint256 _fee\n    ) internal pure returns (uint256 fee) {\n        uint256 multiplier = _multiplierBps == 0 ? _defaultMultiplierBps : _multiplierBps;\n        fee = (_fee * multiplier) / BPS_DENOMINATOR;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/DVNAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { ILayerZeroDVN } from \"../../interfaces/ILayerZeroDVN.sol\";\nimport { Worker } from \"../../../Worker.sol\";\nimport { DVNAdapterMessageCodec } from \"./libs/DVNAdapterMessageCodec.sol\";\n\ninterface ISendLibBase {\n    function fees(address _worker) external view returns (uint256);\n}\n\ninterface IReceiveUln {\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;\n}\n\nstruct ReceiveLibParam {\n    address sendLib;\n    uint32 dstEid;\n    bytes32 receiveLib;\n}\n\n/// @title SendDVNAdapterBase\n/// @notice base contract for DVN adapters\n/// @dev limitations:\n///  - doesn't accept alt token\n///  - doesn't respect block confirmations\nabstract contract DVNAdapterBase is Worker, ILayerZeroDVN {\n    // --- Errors ---\n    error DVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);\n    error DVNAdapter_NotImplemented();\n    error DVNAdapter_MissingRecieveLib(address sendLib, uint32 dstEid);\n\n    event ReceiveLibsSet(ReceiveLibParam[] params);\n\n    /// @dev on change of application config, dvn adapters will not perform any additional verification\n    /// @dev to avoid messages from being stuck, all verifications from adapters will be done with the maximum possible confirmations\n    uint64 internal constant MAX_CONFIRMATIONS = type(uint64).max;\n\n    /// @dev receive lib to call verify() on at destination\n    mapping(address sendLib => mapping(uint32 dstEid => bytes32 receiveLib)) public receiveLibs;\n\n    constructor(\n        address _roleAdmin,\n        address[] memory _admins,\n        uint16 _defaultMultiplierBps\n    ) Worker(new address[](0), address(0x0), _defaultMultiplierBps, _roleAdmin, _admins) {}\n\n    // ========================= OnlyAdmin =========================\n    /// @notice sets receive lib for destination chains\n    /// @dev DEFAULT_ADMIN_ROLE can set MESSAGE_LIB_ROLE for sendLibs and use below function to set receiveLibs\n    function setReceiveLibs(ReceiveLibParam[] calldata _params) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            ReceiveLibParam calldata param = _params[i];\n            receiveLibs[param.sendLib][param.dstEid] = param.receiveLib;\n        }\n\n        emit ReceiveLibsSet(_params);\n    }\n\n    // ========================= Internal =========================\n    function _getAndAssertReceiveLib(address _sendLib, uint32 _dstEid) internal view returns (bytes32 lib) {\n        lib = receiveLibs[_sendLib][_dstEid];\n        if (lib == bytes32(0)) revert DVNAdapter_MissingRecieveLib(_sendLib, _dstEid);\n    }\n\n    function _encode(\n        bytes32 _receiveLib,\n        bytes memory _packetHeader,\n        bytes32 _payloadHash\n    ) internal pure returns (bytes memory) {\n        return DVNAdapterMessageCodec.encode(_receiveLib, _packetHeader, _payloadHash);\n    }\n\n    function _encodeEmpty() internal pure returns (bytes memory) {\n        return\n            DVNAdapterMessageCodec.encode(bytes32(0), new bytes(DVNAdapterMessageCodec.PACKET_HEADER_SIZE), bytes32(0));\n    }\n\n    function _decodeAndVerify(uint32 _srcEid, bytes calldata _payload) internal {\n        require((DVNAdapterMessageCodec.srcEid(_payload) % 30000) == _srcEid, \"DVNAdapterBase: invalid srcEid\");\n\n        (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) = DVNAdapterMessageCodec.decode(_payload);\n\n        IReceiveUln(receiveLib).verify(packetHeader, payloadHash, MAX_CONFIRMATIONS);\n    }\n\n    function _withdrawFeeFromSendLib(address _sendLib, address _to) internal {\n        uint256 fee = ISendLibBase(_sendLib).fees(address(this));\n        if (fee > 0) {\n            ISendLib(_sendLib).withdrawFee(_to, fee);\n            emit Withdraw(_sendLib, _to, fee);\n        }\n    }\n\n    function _assertBalanceAndWithdrawFee(address _sendLib, uint256 _messageFee) internal {\n        uint256 balance = address(this).balance;\n        if (balance < _messageFee) {\n            // withdraw all fees from the sendLib if balance is insufficient\n            _withdrawFeeFromSendLib(_sendLib, address(this));\n\n            // check balance again\n            balance = address(this).balance;\n            // revert if balance is still insufficient, need to transfer more funds manually to the adapter\n            if (balance < _messageFee) revert DVNAdapter_InsufficientBalance(balance, _messageFee);\n        }\n    }\n\n    /// @dev to receive refund\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/arbitrum/ArbitrumDVNAdapterL1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { IInbox } from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\n\nimport { ArbitrumDVNAdapterL2 } from \"./ArbitrumDVNAdapterL2.sol\";\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { DVNAdapterMessageCodec } from \"../libs/DVNAdapterMessageCodec.sol\";\n\ncontract ArbitrumDVNAdapterL1 is DVNAdapterBase {\n    // --- Config Struct ---\n    struct DstConfig {\n        uint16 multiplierBps;\n        uint256 maxSubmissionCost;\n        uint256 gasLimit;\n        uint256 maxFeePerGas;\n    }\n\n    // --- Events ---\n    event RetryableTicketCreated(uint256 indexed ticketId);\n    error OnlyArbitrum();\n\n    uint32 public immutable arbitrumEid; // eid % 30000 (v1 eid)\n    IInbox public immutable inbox;\n\n    address public peer; // L2 adapter\n    DstConfig public dstConfig;\n\n    constructor(\n        address[] memory _admins,\n        uint32 _arbitrumEid,\n        address _inbox\n    ) DVNAdapterBase(msg.sender, _admins, 12000) {\n        arbitrumEid = _arbitrumEid; // eid % 30000 (v1 eid)\n        inbox = IInbox(_inbox);\n    }\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n    }\n\n    function setDstConfig(\n        uint16 _multiplierBps,\n        uint256 _maxSubmissionCost,\n        uint256 _gasLimit,\n        uint256 _maxFeePerGas\n    ) external onlyRole(ADMIN_ROLE) {\n        dstConfig = DstConfig({\n            multiplierBps: _multiplierBps,\n            maxSubmissionCost: _maxSubmissionCost,\n            gasLimit: _gasLimit,\n            maxFeePerGas: _maxFeePerGas\n        });\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata /*_options*/\n    ) external payable override onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_param.sender) returns (uint256 fee) {\n        DstConfig storage config = dstConfig;\n        fee = _getArbitrumFee(_param.dstEid, config);\n\n        bytes memory payload = abi.encodeWithSelector(\n            ArbitrumDVNAdapterL2.verify.selector,\n            DVNAdapterMessageCodec.encode(\n                receiveLibs[msg.sender][_param.dstEid],\n                _param.packetHeader,\n                _param.payloadHash\n            )\n        );\n\n        // fee estimation: https://github.com/OffchainLabs/arbitrum-sdk/blob/main/src/lib/message/L1ToL2MessageCreator.ts#L52\n        uint256 ticketID = inbox.createRetryableTicket{ value: fee }(\n            peer,\n            0,\n            config.maxSubmissionCost,\n            peer,\n            peer,\n            config.gasLimit,\n            config.maxFeePerGas,\n            payload\n        );\n        emit RetryableTicketCreated(ticketID);\n\n        // adjust fee based on multiplier\n        //        if (workerFeeLib != address(0)) {\n        //            fee = IDVNAdapterFeeLib(workerFeeLib).getFee(\n        //                _param.dstEid,\n        //                _param.sender,\n        //                defaultMultiplierBps,\n        //                config.multiplierBps,\n        //                fee\n        //            );\n        //        }\n    }\n\n    // --- View ---\n    function getFee(\n        uint32 _dstEid,\n        uint64 /*_confirmations*/,\n        address _sender,\n        bytes calldata /*_options*/\n    ) public view override onlyAcl(_sender) returns (uint256 fee) {\n        DstConfig storage config = dstConfig;\n        fee = _getArbitrumFee(_dstEid, config);\n\n        // adjust fee based on multiplier\n        //        if (workerFeeLib != address(0)) {\n        //            fee = IDVNAdapterFeeLib(workerFeeLib).getFee(\n        //                _dstEid,\n        //                _sender,\n        //                defaultMultiplierBps,\n        //                config.multiplierBps,\n        //                fee\n        //            );\n        //        }\n    }\n\n    function _getArbitrumFee(uint32 _dstEid, DstConfig storage _dstConfig) internal view returns (uint256 fee) {\n        if (_dstEid % 30000 != arbitrumEid) revert OnlyArbitrum();\n        fee = _dstConfig.maxSubmissionCost + _dstConfig.gasLimit * _dstConfig.maxFeePerGas;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/arbitrum/ArbitrumDVNAdapterL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { AddressAliasHelper } from \"@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\ncontract ArbitrumDVNAdapterL2 is DVNAdapterBase {\n    // --- Errors ---\n    error UntrustedPeer(address peer);\n\n    // --- Events ---\n    event PeerSet(address peer);\n\n    // --- Variables ---\n    address public peer; // L1 adapter\n\n    constructor(address[] memory _admins) DVNAdapterBase(msg.sender, _admins, 12000) {}\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata /*_param*/,\n        bytes calldata /*_options*/\n    ) external payable override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address /*_sender*/,\n        bytes calldata /*_options*/\n    ) external pure override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    // --- Receive ---\n    function verify(bytes calldata _payload) external {\n        // To check that message came from L1, we check that the sender is the L1 contract's L2 alias.\n        if (msg.sender != AddressAliasHelper.applyL1ToL2Alias(peer)) revert UntrustedPeer(msg.sender);\n        _decodeAndVerify(0, _payload); //todo: fix\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AxelarExecutable } from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\";\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\nimport { IAxelarDVNAdapter } from \"../../../interfaces/adapters/IAxelarDVNAdapter.sol\";\nimport { IAxelarDVNAdapterFeeLib } from \"../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol\";\n\ninterface ISendLibBase {\n    function fees(address _worker) external view returns (uint256);\n}\n\n/// @title AxelarDVNAdapter\n/// @dev How Axelar DVN Adapter works:\n///  1. Estimate gas fee off-chain using the Axelar SDK.\n///     refer to https://docs.axelar.dev/dev/axelarjs-sdk/axelar-query-api#estimategasfee\n///  2. Pay gas fee by calling `payNativeGasForContractCall` on the AxelarGasService contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas#paynativegasforcontractcall\n///  3. Send message by calling `callContract` on the AxelarGateway contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gmp-messages#call-a-contract-on-chain-b-from-chain-a\n///  4. Refund surplus gas fee asynchronously.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/refund\n/// @dev Recovery:\n///  1. If not enough gas fee is paid, the message will be hangup on source chain and can `add gas` to retry.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#increase-gas-payment-to-the-gas-receiver-on-the-source-chain\n///  2. If the message is not executed on the destination chain, you can manually retry by calling `execute` on the `ReceiveAxelarDVNAdapter` contract.\n///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#manually-execute-a-transfer\n/// @dev As the Gas is estimated off-chain, we need to update the gas fee periodically on-chain by calling `setNativeGasFee` with the new fee.\ncontract AxelarDVNAdapter is DVNAdapterBase, AxelarExecutable, IAxelarDVNAdapter {\n    mapping(string srcChainName => SrcConfig) public srcConfig; // by chain name\n    mapping(uint32 dstEid => DstConfig) public dstConfig; // by dstEid\n\n    // set default multiplier to 2.5x\n    constructor(\n        address[] memory _admins,\n        address _gateway\n    ) AxelarExecutable(_gateway) DVNAdapterBase(msg.sender, _admins, 10000) {}\n\n    // ========================= OnlyAdmin =========================\n    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            DstConfigParam calldata param = _params[i];\n\n            uint32 eid = param.eid % 30000;\n\n            // set once per chainName\n            // only one adapter per dvn that services both endpoint v1 and v2\n            // we standardize the eid stored here with mod 30000\n            if (bytes(dstConfig[eid].chainName).length == 0) {\n                dstConfig[eid].chainName = param.chainName;\n                dstConfig[eid].peer = param.peer;\n                srcConfig[param.chainName].eid = eid;\n                srcConfig[param.chainName].peer = param.peer;\n            }\n\n            dstConfig[eid].multiplierBps = param.multiplierBps;\n            dstConfig[eid].nativeGasFee = param.nativeGasFee;\n        }\n\n        emit DstConfigSet(_params);\n    }\n\n    /// @notice sets message fee in native gas for destination chains.\n    /// @dev Axelar does not support quoting fee on-chain. Instead, the fee needs to be obtained off-chain by querying through the Axelar SDK.\n    /// @dev The fee may change over time when token prices change, requiring admins to monitor and make necessary updates to reflect the actual fee.\n    /// @dev Adding a buffer to the required fee is advisable. Any surplus fee will be refunded asynchronously if it exceeds the necessary amount.\n    /// https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas\n    /// https://github.com/axelarnetwork/axelarjs/blob/070c8fe061f1082e79772fdc5c4675c0237bbba2/packages/api/src/axelar-query/isomorphic.ts#L54\n    /// https://github.com/axelarnetwork/axelar-cgp-solidity/blob/d4536599321774927bf9716178a9e360f8e0efac/contracts/gas-service/AxelarGasService.sol#L403\n    function setNativeGasFee(NativeGasFeeParam[] calldata _params) external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < _params.length; i++) {\n            NativeGasFeeParam calldata param = _params[i];\n            dstConfig[param.dstEid % 30000].nativeGasFee = param.nativeGasFee;\n        }\n        emit NativeGasFeeSet(_params);\n    }\n\n    // ========================= OnlyWorkerFeeLib =========================\n    function withdrawToFeeLib(address _sendLib) external {\n        if (msg.sender != workerFeeLib) revert AxelarDVNAdapter_OnlyWorkerFeeLib();\n\n        _withdrawFeeFromSendLib(_sendLib, workerFeeLib);\n    }\n\n    // ========================= OnlyMessageLib =========================\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata _options\n    ) external payable override onlyAcl(_param.sender) returns (uint totalFee) {\n        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param({\n            dstEid: _param.dstEid,\n            confirmations: _param.confirmations,\n            sender: _param.sender,\n            defaultMultiplierBps: defaultMultiplierBps\n        });\n        DstConfig memory config = dstConfig[_param.dstEid % 30000];\n\n        bytes memory payload = _encode(receiveLib, _param.packetHeader, _param.payloadHash);\n\n        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(\n            feeLibParam,\n            config,\n            payload,\n            _options,\n            msg.sender\n        );\n\n        gateway.callContract(config.chainName, config.peer, payload);\n    }\n\n    // ========================= View =========================\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view override returns (uint256 totalFee) {\n        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param(\n            _dstEid,\n            _confirmations,\n            _sender,\n            defaultMultiplierBps\n        );\n\n        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, dstConfig[_dstEid % 30000], _options);\n    }\n\n    // ========================= Internal =========================\n    function _execute(\n        string calldata _sourceChain,\n        string calldata _sourceAddress,\n        bytes calldata _payload\n    ) internal override {\n        SrcConfig memory config = srcConfig[_sourceChain];\n\n        // assert peer is the same as the source chain\n        _assertPeer(_sourceChain, _sourceAddress, config.peer);\n\n        _decodeAndVerify(config.eid, _payload);\n    }\n\n    function _assertPeer(string memory _sourceChain, string memory _sourceAddress, string memory peer) private pure {\n        if (keccak256(bytes(_sourceAddress)) != keccak256(bytes(peer))) {\n            revert AxelarDVNAdapter_UntrustedPeer(_sourceChain, _sourceAddress);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IAxelarGasService } from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IAxelarDVNAdapter } from \"../../../interfaces/adapters/IAxelarDVNAdapter.sol\";\nimport { IAxelarDVNAdapterFeeLib } from \"../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol\";\nimport { ILayerZeroPriceFeed } from \"../../../../interfaces/ILayerZeroPriceFeed.sol\";\n\ncontract AxelarDVNAdapterFeeLib is OwnableUpgradeable, Proxied, IAxelarDVNAdapterFeeLib {\n    uint16 internal constant BPS_DENOMINATOR = 10000;\n\n    /// @dev to be applied to native gas fee before sending to Axelar Gas Service\n    uint16 public nativeGasFeeMultiplierBps;\n\n    IAxelarDVNAdapter public dvn;\n    IAxelarGasService public gasService;\n    ILayerZeroPriceFeed public priceFeed;\n\n    mapping(uint32 dstEid => DstConfig) public dstConfig;\n\n    function initialize(\n        address _gasService,\n        address _dvn,\n        uint16 _nativeGasFeeMultiplierBps\n    ) external proxied initializer {\n        __Ownable_init();\n        gasService = IAxelarGasService(_gasService);\n        dvn = IAxelarDVNAdapter(_dvn);\n        nativeGasFeeMultiplierBps = _nativeGasFeeMultiplierBps;\n    }\n\n    // ================================ OnlyOwner ================================\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n        emit TokenWithdrawn(_token, _to, _amount);\n    }\n\n    function setGasService(address _gasService) external onlyOwner {\n        gasService = IAxelarGasService(_gasService);\n        emit GasServiceSet(_gasService);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyOwner {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        emit PriceFeedSet(_priceFeed);\n    }\n\n    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {\n        for (uint256 i = 0; i < _param.length; i++) {\n            DstConfigParam calldata param = _param[i];\n            dstConfig[param.dstEid] = DstConfig({ gas: param.gas, floorMarginUSD: param.floorMarginUSD });\n        }\n        emit DstConfigSet(_param);\n    }\n\n    function setNativeGasFeeMultiplierBps(uint16 _multiplierBps) external onlyOwner {\n        nativeGasFeeMultiplierBps = _multiplierBps;\n        emit NativeGasFeeMultiplierBpsSet(_multiplierBps);\n    }\n\n    // ================================ External ================================\n    function getFeeOnSend(\n        Param calldata _param,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes memory _payload,\n        bytes calldata _options,\n        address _sendLib\n    ) external payable returns (uint256 totalFee) {\n        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);\n        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();\n\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, _dstConfig.nativeGasFee);\n\n        uint256 feeToAxelar = _getAxelarFeeWithBuffer(_dstConfig.nativeGasFee);\n        // withdraw from uln to fee lib if not enough balance\n        uint256 balance = address(this).balance;\n        if (balance < feeToAxelar) {\n            dvn.withdrawToFeeLib(_sendLib);\n\n            // revert if still not enough\n            balance = address(this).balance;\n            if (balance < feeToAxelar) revert AxelarDVNAdapter_InsufficientBalance(balance, feeToAxelar);\n        }\n\n        // pay axelar gas service\n        gasService.payNativeGasForContractCall{ value: feeToAxelar }(\n            msg.sender, // sender\n            _dstConfig.chainName, // destinationChain\n            _dstConfig.peer, // destinationAddress\n            _payload, // payload\n            address(this) // refundAddress\n        );\n    }\n\n    function getFee(\n        Param calldata _param,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external pure returns (uint256 totalFee) {\n        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);\n        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();\n\n        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, _dstConfig.nativeGasFee);\n    }\n\n    // ================================ Internal ================================\n    function _getAxelarFeeWithBuffer(uint256 _nativeGasFee) internal view returns (uint256) {\n        return (_nativeGasFee * nativeGasFeeMultiplierBps) / BPS_DENOMINATOR;\n    }\n\n    function _applyPremium(\n        uint16 multiplierBps,\n        uint16 defaultMultiplierBps,\n        uint256 fee\n    ) internal pure returns (uint256) {\n        uint256 multiplier = multiplierBps == 0 ? defaultMultiplierBps : multiplierBps;\n        return (fee * multiplier) / BPS_DENOMINATOR;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/libs/DVNAdapterMessageCodec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nlibrary DVNAdapterMessageCodec {\n    using AddressCast for bytes32;\n\n    error DVNAdapter_InvalidMessageSize();\n\n    uint256 private constant RECEIVE_LIB_OFFSET = 0;\n    uint256 private constant PAYLOAD_HASH_OFFSET = 32;\n    uint256 private constant PACKET_HEADER_OFFSET = 64;\n    uint256 private constant SRC_EID_OFFSET = 73; // 64 + 1 + 8\n\n    uint256 internal constant PACKET_HEADER_SIZE = 81; // version(uint8) + nonce(uint64) + path(uint32,bytes32,uint32,bytes32)\n    uint256 internal constant MESSAGE_SIZE = 32 + 32 + PACKET_HEADER_SIZE; // receive_lib(bytes32) + payloadHash(bytes32) + packetHeader\n\n    function encode(\n        bytes32 _receiveLib,\n        bytes memory _packetHeader,\n        bytes32 _payloadHash\n    ) internal pure returns (bytes memory payload) {\n        return abi.encodePacked(_receiveLib, _payloadHash, _packetHeader);\n    }\n\n    function decode(\n        bytes calldata _message\n    ) internal pure returns (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) {\n        if (_message.length != MESSAGE_SIZE) revert DVNAdapter_InvalidMessageSize();\n\n        receiveLib = bytes32(_message[RECEIVE_LIB_OFFSET:PAYLOAD_HASH_OFFSET]).toAddress();\n        payloadHash = bytes32(_message[PAYLOAD_HASH_OFFSET:PACKET_HEADER_OFFSET]);\n        packetHeader = _message[PACKET_HEADER_OFFSET:];\n    }\n\n    function srcEid(bytes calldata _message) internal pure returns (uint32) {\n        return uint32(bytes4(_message[SRC_EID_OFFSET:SRC_EID_OFFSET + 4]));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/optimism/OptimismDVNAdapterL1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\nimport { OptimismDVNAdapterL2 } from \"./OptimismDVNAdapterL2.sol\";\nimport { DVNAdapterMessageCodec } from \"../libs/DVNAdapterMessageCodec.sol\";\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\n/// @title OptimismDVNAdapterL1\n/// @dev How Optimism DVN adapter works:\n///  1. call `sendMessage` on the L1CrossDomainMessenger contract.\n///     refer to https://docs.optimism.io/builders/dapp-developers/bridging/messaging#basics-of-communication-between-layers\n/// @dev Recovery:\n///  1. If the message is not executed or failed to execute on the destination chain, you can manually retry by calling `relayMessage` on the `CrossDomainMessenger` contract.\n///     refer to https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/universal/CrossDomainMessenger.sol#L211C14-L211C26\ncontract OptimismDVNAdapterL1 is DVNAdapterBase {\n    // --- Errors ---\n    error OnlyOptimism();\n    error NoPeer();\n\n    // --- Events ---\n    event PeerSet(address indexed peer);\n    event GasLimitSet(uint32 gasLimit);\n\n    uint32 public immutable optimismEid; // eid % 30000 (v1 eid)\n    address public immutable l1Messenger; // L1CrossDomainMessenger\n\n    uint32 public gasLimit;\n    address public peer;\n\n    constructor(\n        address[] memory _admins,\n        uint32 _optimismEid,\n        address _l1Messenger\n    ) DVNAdapterBase(msg.sender, _admins, 12000) {\n        optimismEid = _optimismEid; // eid % 30000 (v1 eid)\n        l1Messenger = _l1Messenger;\n    }\n\n    // --- Admin ---\n    function setGasLimit(uint32 _gasLimit) external onlyRole(ADMIN_ROLE) {\n        gasLimit = _gasLimit;\n        emit GasLimitSet(_gasLimit);\n    }\n\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata _param,\n        bytes calldata /*_options*/\n    ) external payable override onlyAcl(_param.sender) returns (uint256) {\n        _getAndAssertReceiveLib(msg.sender, _param.dstEid);\n\n        if (_param.dstEid % 30000 != optimismEid) revert OnlyOptimism();\n        if (peer == address(0)) revert NoPeer();\n\n        bytes memory payload = abi.encodeWithSelector(\n            OptimismDVNAdapterL2.verify.selector,\n            DVNAdapterMessageCodec.encode(\n                receiveLibs[msg.sender][_param.dstEid],\n                _param.packetHeader,\n                _param.payloadHash\n            )\n        );\n        ICrossDomainMessenger(l1Messenger).sendMessage(peer, payload, gasLimit);\n\n        return 0;\n    }\n\n    // --- View ---\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address _sender,\n        bytes calldata /*_options*/\n    ) public view override onlyAcl(_sender) returns (uint256) {\n        // no fee, charged as gas when sending message from L1 to L2\n        return 0;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/adapters/optimism/OptimismDVNAdapterL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\nimport { DVNAdapterBase } from \"../DVNAdapterBase.sol\";\n\ncontract OptimismDVNAdapterL2 is DVNAdapterBase {\n    // --- Errors ---\n    error UntrustedPeer(address peer);\n    error Unauthorized();\n\n    // --- Events ---\n    event PeerSet(address indexed peer);\n\n    address public immutable l2Messenger; // L2CrossDomainMessenger\n\n    address public peer;\n\n    constructor(address[] memory _admins, address _l2Messenger) DVNAdapterBase(msg.sender, _admins, 12000) {\n        l2Messenger = _l2Messenger;\n    }\n\n    // --- Admin ---\n    function setPeer(address _peer) external onlyRole(ADMIN_ROLE) {\n        peer = _peer;\n        emit PeerSet(_peer);\n    }\n\n    // --- Send ---\n    function assignJob(\n        AssignJobParam calldata /*_param*/,\n        bytes calldata /*_options*/\n    ) external payable override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    function getFee(\n        uint32 /*_dstEid*/,\n        uint64 /*_confirmations*/,\n        address /*_sender*/,\n        bytes calldata /*_options*/\n    ) external pure override returns (uint256) {\n        revert DVNAdapter_NotImplemented();\n    }\n\n    // --- Receive ---\n    function verify(bytes calldata _payload) external {\n        // assert messenger\n        if (msg.sender != l2Messenger) revert Unauthorized();\n        // assert peer\n        address xSender = ICrossDomainMessenger(l2Messenger).xDomainMessageSender();\n        if (xSender != peer) revert UntrustedPeer(xSender);\n\n        _decodeAndVerify(0, _payload); //todo: fix\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/IDVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IWorker } from \"../../interfaces/IWorker.sol\";\nimport { ILayerZeroDVN } from \"./ILayerZeroDVN.sol\";\nimport { ILayerZeroReadDVN } from \"./ILayerZeroReadDVN.sol\";\n\ninterface IDVN is IWorker, ILayerZeroDVN, ILayerZeroReadDVN {\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 gas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD;\n    }\n\n    struct DstConfig {\n        uint64 gas;\n        uint16 multiplierBps;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event SetDstConfig(DstConfigParam[] params);\n\n    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/IDVNFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IDVN } from \"./IDVN.sol\";\n\ninterface IDVNFeeLib {\n    struct FeeParams {\n        address priceFeed;\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint64 quorum;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct FeeParamsForRead {\n        address priceFeed;\n        address sender;\n        uint64 quorum;\n        uint16 defaultMultiplierBps;\n    }\n\n    error DVN_UnsupportedOptionType(uint8 optionType);\n    error DVN_EidNotSupported(uint32 eid);\n    error DVN_TimestampOutOfRange(uint32 eid, uint64 timestamp);\n    error DVN_INVALID_INPUT_LENGTH();\n\n    function getFeeOnSend(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external payable returns (uint256 fee);\n\n    function getFee(\n        FeeParams calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n\n    function getFeeOnSend(\n        FeeParamsForRead calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external payable returns (uint256 fee);\n\n    function getFee(\n        FeeParamsForRead calldata _params,\n        IDVN.DstConfig calldata _dstConfig,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/ILayerZeroDVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroDVN {\n    struct AssignJobParam {\n        uint32 dstEid;\n        bytes packetHeader;\n        bytes32 payloadHash;\n        uint64 confirmations;\n        address sender;\n    }\n\n    // @notice query price and assign jobs at the same time\n    // @param _dstEid - the destination endpoint identifier\n    // @param _packetHeader - version + nonce + path\n    // @param _payloadHash - hash of guid + message\n    // @param _confirmations - block confirmation delay before relaying blocks\n    // @param _sender - the source sending contract address\n    // @param _options - options\n    function assignJob(AssignJobParam calldata _param, bytes calldata _options) external payable returns (uint256 fee);\n\n    // @notice query the dvn fee for relaying block information to the destination chain\n    // @param _dstEid the destination endpoint identifier\n    // @param _confirmations - block confirmation delay before relaying blocks\n    // @param _sender - the source sending contract address\n    // @param _options - options\n    function getFee(\n        uint32 _dstEid,\n        uint64 _confirmations,\n        address _sender,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/ILayerZeroReadDVN.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ILayerZeroReadDVN {\n    // @notice query price and assign jobs at the same time\n    // @param _packetHeader - version + nonce + path\n    // @param _cmd - the command to be executed to obtain the payload\n    // @param _options - options\n    function assignJob(\n        address _sender,\n        bytes calldata _packetHeader,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external payable returns (uint256 fee);\n\n    // @notice query the dvn fee for relaying block information to the destination chain\n    // @param _packetHeader - version + nonce + path\n    // @param _cmd - the command to be executed to obtain the payload\n    // @param _options - options\n    function getFee(\n        address _sender,\n        bytes calldata _packetHeader,\n        bytes calldata _cmd,\n        bytes calldata _options\n    ) external view returns (uint256 fee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/IReceiveUlnE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/// @dev should be implemented by the ReceiveUln302 contract and future ReceiveUln contracts on EndpointV2\ninterface IReceiveUlnE2 {\n    /// @notice for each dvn to verify the payload\n    /// @dev this function signature 0x0223536e\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;\n\n    /// @notice verify the payload at endpoint, will check if all DVNs verified\n    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/adapters/IAxelarDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IAxelarDVNAdapter {\n    struct MultiplierParam {\n        uint32 dstEid;\n        uint16 multiplierBps;\n    }\n\n    struct FloorMarginUSDParam {\n        uint32 dstEid;\n        uint128 floorMarginUSD;\n    }\n\n    struct NativeGasFeeParam {\n        uint32 dstEid;\n        uint256 nativeGasFee;\n    }\n\n    struct DstConfigParam {\n        uint32 eid;\n        string chainName;\n        string peer;\n        uint16 multiplierBps;\n        uint256 nativeGasFee;\n    }\n\n    struct DstConfig {\n        string chainName;\n        string peer;\n        uint16 multiplierBps;\n        uint256 nativeGasFee;\n    }\n\n    struct SrcConfig {\n        uint32 eid;\n        string peer;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event NativeGasFeeSet(NativeGasFeeParam[] params);\n    event MultiplierSet(MultiplierParam[] params);\n    event FloorMarginUSDSet(FloorMarginUSDParam[] params);\n\n    error AxelarDVNAdapter_UntrustedPeer(string chainName, string peer);\n    error AxelarDVNAdapter_OnlyWorkerFeeLib();\n\n    function withdrawToFeeLib(address _sendLib) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/adapters/IAxelarDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IAxelarDVNAdapter } from \"./IAxelarDVNAdapter.sol\";\n\ninterface IAxelarDVNAdapterFeeLib {\n    struct Param {\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct DstConfig {\n        uint64 gas;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint64 gas;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n    event TokenWithdrawn(address token, address to, uint256 amount);\n    event GasServiceSet(address gasService);\n    event PriceFeedSet(address priceFeed);\n    event NativeGasFeeMultiplierBpsSet(uint16 multiplierBps);\n\n    error AxelarDVNAdapter_OptionsUnsupported();\n    error AxelarDVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);\n    error AxelarDVNAdapter_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        Param calldata _params,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes memory _payload,\n        bytes calldata _options,\n        address _sendLib\n    ) external payable returns (uint256 totalFee);\n\n    function getFee(\n        Param calldata _params,\n        IAxelarDVNAdapter.DstConfig calldata _dstConfig,\n        bytes calldata _options\n    ) external view returns (uint256 totalFee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/adapters/ICCIPDVNAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ICCIPDVNAdapter {\n    struct DstConfigParam {\n        uint32 eid;\n        uint16 multiplierBps;\n        uint64 chainSelector;\n        uint256 gas;\n        bytes peer;\n    }\n\n    struct DstConfig {\n        // https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet#ethereum-sepolia\n        // https://docs.chain.link/ccip/supported-networks/v1_0_0/mainnet\n        uint64 chainSelector;\n        uint16 multiplierBps;\n        // https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/libraries/Client.sol#L22C51-L22C51\n        // for destination is evm chain, need to use `abi.encode(address)` to get the peer\n        bytes peer;\n        uint256 gas;\n    }\n\n    struct SrcConfig {\n        uint32 eid;\n        bytes peer;\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n\n    error CCIPDVNAdapter_UntrustedPeer(uint64 chainSelector, bytes peer);\n    error CCIPDVNAdapter_InvalidRouter(address router);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/adapters/ICCIPDVNAdapterFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { ICCIPDVNAdapter } from \"./ICCIPDVNAdapter.sol\";\n\ninterface ICCIPDVNAdapterFeeLib {\n    struct Param {\n        uint32 dstEid;\n        uint64 confirmations;\n        address sender;\n        uint16 defaultMultiplierBps;\n    }\n\n    struct DstConfig {\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    struct DstConfigParam {\n        uint32 dstEid;\n        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR\n    }\n\n    event DstConfigSet(DstConfigParam[] params);\n\n    error CCIPDVNAdapter_OptionsUnsupported();\n    error CCIPDVNAdapter_EidNotSupported(uint32 eid);\n\n    function getFeeOnSend(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external payable returns (uint256 ccipFee, uint256 totalFee);\n\n    function getFee(\n        Param calldata _params,\n        ICCIPDVNAdapter.DstConfig calldata _dstConfig,\n        Client.EVM2AnyMessage calldata _message,\n        bytes calldata _options,\n        IRouterClient _router\n    ) external view returns (uint256 totalFee);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/ReadCmdCodecV1.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SupportedCmdTypes, SupportedCmdTypesLib } from \"./SupportedCmdTypes.sol\";\n\nlibrary ReadCmdCodecV1 {\n    uint16 internal constant CMD_VERSION = 1;\n    uint8 internal constant REQUEST_VERSION = 1;\n    uint16 internal constant RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n    uint8 internal constant COMPUTE_VERSION = 1;\n    uint16 internal constant COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    uint8 internal constant COMPUTE_SETTING_MAP_ONLY = 0;\n    uint8 internal constant COMPUTE_SETTING_REDUCE_ONLY = 1;\n    uint8 internal constant COMPUTE_SETTING_MAP_AND_REDUCE = 2;\n\n    error InvalidCmd();\n    error InvalidVersion();\n    error InvalidType();\n\n    struct Cmd {\n        uint16 numEvmCallRequestV1;\n        bool evmCallComputeV1Map;\n        bool evmCallComputeV1Reduce;\n    }\n\n    function decode(\n        bytes calldata _cmd,\n        function(uint32, bool, uint64, uint8) view _assertCmdTypeSupported\n    ) internal view returns (Cmd memory cmd) {\n        uint256 cursor = 0;\n        // decode the header in scope, depress stack too deep\n        {\n            uint16 cmdVersion = uint16(bytes2(_cmd[cursor:cursor + 2]));\n            cursor += 2;\n            if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n            cursor += 2; // skip appCmdLabel\n\n            uint16 requestCount = uint16(bytes2(_cmd[cursor:cursor + 2]));\n            cursor += 2;\n\n            // there is only one request type in this version, so total request count should be the same as numEvmCallRequestV1\n            if (requestCount == 0) revert InvalidCmd();\n            cmd.numEvmCallRequestV1 = requestCount;\n        }\n\n        // decode the requests\n        for (uint16 i = 0; i < cmd.numEvmCallRequestV1; i++) {\n            uint8 requestVersion = uint8(_cmd[cursor]);\n            cursor += 1;\n            if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n            // skip appRequestLabel\n            cursor += 2;\n\n            uint16 resolverType = uint16(bytes2(_cmd[cursor:cursor + 2]));\n            cursor += 2;\n\n            if (resolverType == RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL) {\n                uint16 requestSize = uint16(bytes2(_cmd[cursor:cursor + 2]));\n                cursor += 2;\n\n                // decode the request in scope, depress stack too deep\n                {\n                    uint256 requestCursor = cursor;\n                    uint32 targetEid = uint32(bytes4(_cmd[requestCursor:requestCursor + 4]));\n                    requestCursor += 4;\n\n                    bool isBlockNum = uint8(_cmd[requestCursor]) == 1;\n                    requestCursor += 1;\n\n                    uint64 blockNumOrTimestamp = uint64(bytes8(_cmd[requestCursor:requestCursor + 8]));\n\n                    _assertCmdTypeSupported(\n                        targetEid,\n                        isBlockNum,\n                        blockNumOrTimestamp,\n                        SupportedCmdTypesLib.CMD_V1__REQUEST_V1__EVM_CALL\n                    );\n                }\n\n                if (cursor + requestSize > _cmd.length) revert InvalidCmd();\n                cursor += requestSize;\n            } else {\n                revert InvalidType();\n            }\n        }\n\n        // decode the compute if it exists\n        if (cursor < _cmd.length) {\n            uint8 computeVersion = uint8(_cmd[cursor]);\n            cursor += 1;\n            if (computeVersion != COMPUTE_VERSION) revert InvalidVersion();\n\n            uint16 computeType = uint16(bytes2(_cmd[cursor:cursor + 2]));\n            cursor += 2;\n            if (computeType != COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL) revert InvalidType();\n\n            uint8 computeSetting = uint8(_cmd[cursor]);\n            cursor += 1;\n\n            if (computeSetting == COMPUTE_SETTING_MAP_ONLY) {\n                cmd.evmCallComputeV1Map = true;\n            } else if (computeSetting == COMPUTE_SETTING_REDUCE_ONLY) {\n                cmd.evmCallComputeV1Reduce = true;\n            } else if (computeSetting == COMPUTE_SETTING_MAP_AND_REDUCE) {\n                cmd.evmCallComputeV1Map = true;\n                cmd.evmCallComputeV1Reduce = true;\n            } else {\n                revert InvalidType();\n            }\n\n            uint32 targetEid = uint32(bytes4(_cmd[cursor:cursor + 4]));\n            cursor += 4;\n\n            bool isBlockNum = uint8(_cmd[cursor]) == 1;\n            cursor += 1;\n\n            uint64 blockNumOrTimestamp = uint64(bytes8(_cmd[cursor:cursor + 8]));\n            cursor += 8;\n\n            _assertCmdTypeSupported(\n                targetEid,\n                isBlockNum,\n                blockNumOrTimestamp,\n                SupportedCmdTypesLib.CMD_V1__COMPUTE_V1__EVM_CALL\n            );\n\n            // assert the remaining length: confirmations(2), to(20)\n            cursor += 22;\n        }\n        if (cursor != _cmd.length) revert InvalidCmd();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/SupportedCmdTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\n\nstruct SupportedCmdTypes {\n    mapping(uint32 => BitMap256) cmdTypes; // support options\n}\n\nusing SupportedCmdTypesLib for SupportedCmdTypes global;\n\nlibrary SupportedCmdTypesLib {\n    // the max number of supported command types is 256\n    uint8 internal constant CMD_V1__REQUEST_V1__EVM_CALL = 0;\n    uint8 internal constant CMD_V1__COMPUTE_V1__EVM_CALL = 1;\n    uint8 internal constant CMD_V1__TIMESTAMP_VALIDATE = 2; // validate timestamp, to check if the timestamp is out of range\n    // more types can be added here in the future\n\n    error UnsupportedTargetEid();\n\n    function assertSupported(SupportedCmdTypes storage _self, uint32 _targetEid, uint8 _type) internal view {\n        if (!isSupported(_self, _targetEid, _type)) revert UnsupportedTargetEid();\n    }\n\n    function isSupported(SupportedCmdTypes storage _self, uint32 _targetEid, uint8 _type) internal view returns (bool) {\n        return _self.cmdTypes[_targetEid].get(_type);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/UlnOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol\";\n\nimport { DVNOptions } from \"./DVNOptions.sol\";\n\nlibrary UlnOptions {\n    using SafeCast for uint256;\n\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    error LZ_ULN_InvalidWorkerOptions(uint256 cursor);\n    error LZ_ULN_InvalidWorkerId(uint8 workerId);\n    error LZ_ULN_InvalidLegacyType1Option();\n    error LZ_ULN_InvalidLegacyType2Option();\n    error LZ_ULN_UnsupportedOptionType(uint16 optionType);\n\n    /// @dev decode the options into executorOptions and dvnOptions\n    /// @param _options the options can be either legacy options (type 1 or 2) or type 3 options\n    /// @return executorOptions the executor options, share the same format of type 3 options\n    /// @return dvnOptions the dvn options, share the same format of type 3 options\n    function decode(\n        bytes calldata _options\n    ) internal pure returns (bytes memory executorOptions, bytes memory dvnOptions) {\n        // at least 2 bytes for the option type, but can have no options\n        if (_options.length < 2) revert LZ_ULN_InvalidWorkerOptions(0);\n\n        uint16 optionsType = uint16(bytes2(_options[0:2]));\n        uint256 cursor = 2;\n\n        // type3 options: [worker_option][worker_option]...\n        // worker_option: [worker_id][option_size][option]\n        // worker_id: uint8, option_size: uint16, option: bytes\n        if (optionsType == TYPE_3) {\n            unchecked {\n                uint256 start = cursor;\n                uint8 lastWorkerId; // worker_id starts from 1, so 0 is an invalid worker_id\n\n                // heuristic: we assume that the options are mostly EXECUTOR options only\n                // checking the workerID can reduce gas usage for most cases\n                while (cursor < _options.length) {\n                    uint8 workerId = uint8(bytes1(_options[cursor:cursor + 1]));\n                    if (workerId == 0) revert LZ_ULN_InvalidWorkerId(0);\n\n                    // workerId must equal to the lastWorkerId for the first option\n                    // so it is always skipped in the first option\n                    // this operation slices out options whenever the the scan finds a different workerId\n                    if (lastWorkerId == 0) {\n                        lastWorkerId = workerId;\n                    } else if (workerId != lastWorkerId) {\n                        bytes calldata op = _options[start:cursor]; // slice out the last worker's options\n                        (executorOptions, dvnOptions) = _insertWorkerOptions(\n                            executorOptions,\n                            dvnOptions,\n                            lastWorkerId,\n                            op\n                        );\n\n                        // reset the start cursor and lastWorkerId\n                        start = cursor;\n                        lastWorkerId = workerId;\n                    }\n\n                    ++cursor; // for workerId\n\n                    uint16 size = uint16(bytes2(_options[cursor:cursor + 2]));\n                    if (size == 0) revert LZ_ULN_InvalidWorkerOptions(cursor);\n                    cursor += size + 2;\n                }\n\n                // the options length must be the same as the cursor at the end\n                if (cursor != _options.length) revert LZ_ULN_InvalidWorkerOptions(cursor);\n\n                // if we have reached the end of the options and the options are not empty\n                // we need to process the last worker's options\n                if (_options.length > 2) {\n                    bytes calldata op = _options[start:cursor];\n                    (executorOptions, dvnOptions) = _insertWorkerOptions(executorOptions, dvnOptions, lastWorkerId, op);\n                }\n            }\n        } else {\n            executorOptions = decodeLegacyOptions(optionsType, _options);\n        }\n    }\n\n    function _insertWorkerOptions(\n        bytes memory _executorOptions,\n        bytes memory _dvnOptions,\n        uint8 _workerId,\n        bytes calldata _newOptions\n    ) private pure returns (bytes memory, bytes memory) {\n        if (_workerId == ExecutorOptions.WORKER_ID) {\n            _executorOptions = _executorOptions.length == 0\n                ? _newOptions\n                : abi.encodePacked(_executorOptions, _newOptions);\n        } else if (_workerId == DVNOptions.WORKER_ID) {\n            _dvnOptions = _dvnOptions.length == 0 ? _newOptions : abi.encodePacked(_dvnOptions, _newOptions);\n        } else {\n            revert LZ_ULN_InvalidWorkerId(_workerId);\n        }\n        return (_executorOptions, _dvnOptions);\n    }\n\n    /// @dev decode the legacy options (type 1 or 2) into executorOptions\n    /// @param _optionType the legacy option type\n    /// @param _options the legacy options, which still has the option type in the first 2 bytes\n    /// @return executorOptions the executor options, share the same format of type 3 options\n    /// Data format:\n    /// legacy type 1: [extraGas]\n    /// legacy type 2: [extraGas][dstNativeAmt][dstNativeAddress]\n    /// extraGas: uint256, dstNativeAmt: uint256, dstNativeAddress: bytes\n    function decodeLegacyOptions(\n        uint16 _optionType,\n        bytes calldata _options\n    ) internal pure returns (bytes memory executorOptions) {\n        if (_optionType == TYPE_1) {\n            if (_options.length != 34) revert LZ_ULN_InvalidLegacyType1Option();\n\n            // execution gas\n            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();\n\n            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once\n            // the result is a lzReceive option: [executor_id][option_size][option_type][execution_gas]\n            // option_type: uint8, execution_gas: uint128\n            // option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17\n            executorOptions = abi.encodePacked(\n                ExecutorOptions.WORKER_ID,\n                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_LZRECEIVE,\n                executionGas\n            );\n        } else if (_optionType == TYPE_2) {\n            // receiver size <= 32\n            if (_options.length <= 66 || _options.length > 98) revert LZ_ULN_InvalidLegacyType2Option();\n\n            // execution gas\n            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();\n\n            // nativeDrop (amount + receiver)\n            uint128 amount = uint256(bytes32(_options[34:34 + 32])).toUint128(); // offset 2 + 32\n            bytes32 receiver;\n            unchecked {\n                uint256 receiverLen = _options.length - 66; // offset 2 + 32 + 32\n                receiver = bytes32(_options[66:]);\n                receiver = receiver >> (8 * (32 - receiverLen)); // padding 0 to the left\n            }\n\n            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once\n            // the result has one lzReceive option and one nativeDrop option:\n            //      [executor_id][lzReceive_option_size][option_type][execution_gas] +\n            //      [executor_id][nativeDrop_option_size][option_type][nativeDrop_amount][receiver]\n            // option_type: uint8, execution_gas: uint128, nativeDrop_amount: uint128, receiver: bytes32\n            // lzReceive_option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17\n            // nativeDrop_option_size = len(option_type) + len(nativeDrop_amount) + len(receiver) = 1 + 16 + 32 = 49\n            executorOptions = abi.encodePacked(\n                ExecutorOptions.WORKER_ID,\n                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_LZRECEIVE,\n                executionGas,\n                ExecutorOptions.WORKER_ID,\n                uint16(49), // 48 + 1, 32 + 16 for option_length, + 1 for option_type\n                ExecutorOptions.OPTION_TYPE_NATIVE_DROP,\n                amount,\n                receiver\n            );\n        } else {\n            revert LZ_ULN_UnsupportedOptionType(_optionType);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/readlib/ReadLib1002.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ERC165, IERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ILayerZeroEndpointV2, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { IMessageLib, MessageLibType, SetConfigParam } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\";\nimport { ISendLib, Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { ILayerZeroReadExecutor } from \"../../interfaces/ILayerZeroReadExecutor.sol\";\nimport { ILayerZeroReadDVN } from \"../interfaces/ILayerZeroReadDVN.sol\";\nimport { ILayerZeroTreasury } from \"../../interfaces/ILayerZeroTreasury.sol\";\n\nimport { UlnOptions } from \"../libs/UlnOptions.sol\";\nimport { DVNOptions } from \"../libs/DVNOptions.sol\";\nimport { SafeCall } from \"../../libs/SafeCall.sol\";\n\nimport { MessageLibBase } from \"../../MessageLibBase.sol\";\nimport { ReadLibBase, ReadLibConfig } from \"./ReadLibBase.sol\";\n\ncontract ReadLib1002 is ISendLib, ERC165, ReadLibBase, MessageLibBase {\n    using PacketV1Codec for bytes;\n    using SafeCall for address;\n\n    uint32 internal constant CONFIG_TYPE_READ_LID_CONFIG = 1;\n\n    uint16 internal constant TREASURY_MAX_COPY = 32;\n\n    uint256 internal immutable treasuryGasLimit;\n\n    mapping(address oapp => mapping(uint32 eid => mapping(uint64 nonce => bytes32 cmdHash))) public cmdHashLookup;\n    mapping(bytes32 headerHash => mapping(bytes32 cmdHash => mapping(address dvn => bytes32 payloadHash)))\n        public hashLookup;\n\n    // accumulated fees for workers and treasury\n    mapping(address worker => uint256 fee) public fees;\n    uint256 internal treasuryNativeFeeCap;\n    address internal treasury;\n\n    event PayloadVerified(address dvn, bytes header, bytes32 cmdHash, bytes32 payloadHash);\n    event ExecutorFeePaid(address executor, uint256 fee);\n    event DVNFeePaid(address[] requiredDVNs, address[] optionalDVNs, uint256[] fees);\n    event NativeFeeWithdrawn(address worker, address receiver, uint256 amount);\n    event LzTokenFeeWithdrawn(address lzToken, address receiver, uint256 amount);\n    event TreasurySet(address treasury);\n    event TreasuryNativeFeeCapSet(uint256 newTreasuryNativeFeeCap);\n\n    error LZ_RL_InvalidReceiver();\n    error LZ_RL_InvalidPacketHeader();\n    error LZ_RL_InvalidCmdHash();\n    error LZ_RL_InvalidPacketVersion();\n    error LZ_RL_InvalidEid();\n    error LZ_RL_Verifying();\n    error LZ_RL_InvalidConfigType(uint32 configType);\n    error LZ_RL_InvalidAmount(uint256 requested, uint256 available);\n    error LZ_RL_NotTreasury();\n    error LZ_RL_CannotWithdrawAltToken();\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryGasForFeeCap\n    ) MessageLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid()) {\n        treasuryGasLimit = _treasuryGasLimit;\n        treasuryNativeFeeCap = _treasuryGasForFeeCap;\n    }\n\n    function supportsInterface(bytes4 _interfaceId) public view override(ERC165, IERC165) returns (bool) {\n        return\n            _interfaceId == type(IMessageLib).interfaceId ||\n            _interfaceId == type(ISendLib).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    // ============================ OnlyOwner ===================================\n\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    /// @dev the new value can not be greater than the old value, i.e. down only\n    function setTreasuryNativeFeeCap(uint256 _newTreasuryNativeFeeCap) external onlyOwner {\n        // assert the new value is no greater than the old value\n        if (_newTreasuryNativeFeeCap > treasuryNativeFeeCap)\n            revert LZ_RL_InvalidAmount(_newTreasuryNativeFeeCap, treasuryNativeFeeCap);\n        treasuryNativeFeeCap = _newTreasuryNativeFeeCap;\n        emit TreasuryNativeFeeCapSet(_newTreasuryNativeFeeCap);\n    }\n\n    // ============================ OnlyEndpoint ===================================\n\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external onlyEndpoint returns (MessagingFee memory, bytes memory) {\n        // the receiver must be the same as the sender\n        if (AddressCast.toBytes32(_packet.sender) != _packet.receiver) revert LZ_RL_InvalidReceiver();\n\n        // pay worker and treasury\n        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_packet, _options);\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(\n            _packet.sender,\n            _packet.dstEid,\n            totalNativeFee,\n            _payInLzToken\n        );\n        totalNativeFee += treasuryNativeFee;\n\n        // store the cmdHash for verification in order to prevent reorg attack\n        cmdHashLookup[_packet.sender][_packet.dstEid][_packet.nonce] = keccak256(_packet.message);\n\n        return (MessagingFee(totalNativeFee, lzTokenFee), encodedPacket);\n    }\n\n    function setConfig(address _oapp, SetConfigParam[] calldata _params) external onlyEndpoint {\n        for (uint256 i = 0; i < _params.length; i++) {\n            SetConfigParam calldata param = _params[i];\n            _assertSupportedEid(param.eid);\n            if (param.configType == CONFIG_TYPE_READ_LID_CONFIG) {\n                _setReadLibConfig(param.eid, _oapp, abi.decode(param.config, (ReadLibConfig)));\n            } else {\n                revert LZ_RL_InvalidConfigType(param.configType);\n            }\n        }\n    }\n\n    // ============================ External ===================================\n    /// @dev The verification will be done in the same chain where the packet is sent.\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\n    /// @param _packetHeader - the srcEid should be the localEid and the dstEid should be the channel id.\n    ///        The original packet header in PacketSent event should be processed to flip the srcEid and dstEid.\n    function commitVerification(bytes calldata _packetHeader, bytes32 _cmdHash, bytes32 _payloadHash) external {\n        // assert packet header is of right size 81\n        if (_packetHeader.length != 81) revert LZ_RL_InvalidPacketHeader();\n        // assert packet header version is the same\n        if (_packetHeader.version() != PacketV1Codec.PACKET_VERSION) revert LZ_RL_InvalidPacketVersion();\n        // assert the packet is for this endpoint\n        if (_packetHeader.dstEid() != localEid) revert LZ_RL_InvalidEid();\n\n        // cache these values to save gas\n        address receiver = _packetHeader.receiverB20();\n        uint32 srcEid = _packetHeader.srcEid(); // channel id\n        uint64 nonce = _packetHeader.nonce();\n\n        // reorg protection. to allow reverification, the cmdHash cant be removed\n        if (cmdHashLookup[receiver][srcEid][nonce] != _cmdHash) revert LZ_RL_InvalidCmdHash();\n\n        ReadLibConfig memory config = getReadLibConfig(receiver, srcEid);\n        _verifyAndReclaimStorage(config, keccak256(_packetHeader), _cmdHash, _payloadHash);\n\n        // endpoint will revert if nonce <= lazyInboundNonce\n        Origin memory origin = Origin(srcEid, _packetHeader.sender(), nonce);\n        ILayerZeroEndpointV2(endpoint).verify(origin, receiver, _payloadHash);\n    }\n\n    /// @dev DVN verifies the payload with the packet header and command hash\n    /// @param _packetHeader - the packet header is needed for event only, which can be conveniently for off-chain to track the packet state.\n    function verify(bytes calldata _packetHeader, bytes32 _cmdHash, bytes32 _payloadHash) external {\n        hashLookup[keccak256(_packetHeader)][_cmdHash][msg.sender] = _payloadHash;\n        emit PayloadVerified(msg.sender, _packetHeader, _cmdHash, _payloadHash);\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external {\n        uint256 fee = fees[msg.sender];\n        if (_amount > fee) revert LZ_RL_InvalidAmount(_amount, fee);\n        unchecked {\n            fees[msg.sender] = fee - _amount;\n        }\n\n        // transfers native if nativeToken == address(0x0)\n        address nativeToken = ILayerZeroEndpointV2(endpoint).nativeToken();\n        Transfer.nativeOrToken(nativeToken, _to, _amount);\n        emit NativeFeeWithdrawn(msg.sender, _to, _amount);\n    }\n\n    // ============================ Treasury ===================================\n\n    /// @dev _lzToken is a user-supplied value because lzToken might change in the endpoint before all lzToken can be taken out\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external {\n        if (msg.sender != treasury) revert LZ_RL_NotTreasury();\n\n        // lz token cannot be the same as the native token\n        if (ILayerZeroEndpointV2(endpoint).nativeToken() == _lzToken) revert LZ_RL_CannotWithdrawAltToken();\n\n        Transfer.token(_lzToken, _to, _amount);\n\n        emit LzTokenFeeWithdrawn(_lzToken, _to, _amount);\n    }\n\n    // ============================ View ===================================\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        // split workers options\n        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(_options);\n\n        address sender = _packet.sender;\n        uint32 dstEid = _packet.dstEid;\n\n        // quote the executor and dvns\n        ReadLibConfig memory config = getReadLibConfig(sender, dstEid);\n        uint256 nativeFee = _quoteDVNs(\n            config,\n            sender,\n            PacketV1Codec.encodePacketHeader(_packet),\n            _packet.message,\n            dvnOptions\n        );\n        nativeFee += ILayerZeroReadExecutor(config.executor).getFee(sender, executorOptions);\n\n        // quote treasury\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _quoteTreasury(sender, dstEid, nativeFee, _payInLzToken);\n        nativeFee += treasuryNativeFee;\n\n        return MessagingFee(nativeFee, lzTokenFee);\n    }\n\n    function verifiable(\n        ReadLibConfig calldata _config,\n        bytes32 _headerHash,\n        bytes32 _cmdHash,\n        bytes32 _payloadHash\n    ) external view returns (bool) {\n        return _checkVerifiable(_config, _headerHash, _cmdHash, _payloadHash);\n    }\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_READ_LID_CONFIG) {\n            return abi.encode(getReadLibConfig(_oapp, _eid));\n        } else {\n            revert LZ_RL_InvalidConfigType(_configType);\n        }\n    }\n\n    function getTreasuryAndNativeFeeCap() external view returns (address, uint256) {\n        return (treasury, treasuryNativeFeeCap);\n    }\n\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (10, 0, 2);\n    }\n\n    // ============================ Internal ===================================\n\n    /// 1/ handle executor\n    /// 2/ handle other workers\n    function _payWorkers(\n        Packet calldata _packet,\n        bytes calldata _options\n    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {\n        // split workers options\n        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(_options);\n\n        // handle executor\n        ReadLibConfig memory config = getReadLibConfig(_packet.sender, _packet.dstEid);\n        totalNativeFee = _payExecutor(config.executor, _packet.sender, executorOptions);\n\n        // handle dvns\n        (uint256 dvnFee, bytes memory packetBytes) = _payDVNs(config, _packet, dvnOptions);\n        totalNativeFee += dvnFee;\n\n        encodedPacket = packetBytes;\n    }\n\n    function _payDVNs(\n        ReadLibConfig memory _config,\n        Packet calldata _packet,\n        bytes memory _options\n    ) internal returns (uint256 totalFee, bytes memory encodedPacket) {\n        bytes memory packetHeader = PacketV1Codec.encodePacketHeader(_packet);\n        bytes memory payload = PacketV1Codec.encodePayload(_packet);\n\n        uint256[] memory dvnFees;\n        (totalFee, dvnFees) = _assignDVNJobs(_config, _packet.sender, packetHeader, _packet.message, _options);\n\n        encodedPacket = abi.encodePacked(packetHeader, payload);\n        emit DVNFeePaid(_config.requiredDVNs, _config.optionalDVNs, dvnFees);\n    }\n\n    function _assignDVNJobs(\n        ReadLibConfig memory _config,\n        address _sender,\n        bytes memory _packetHeader,\n        bytes calldata _cmd,\n        bytes memory _options\n    ) internal returns (uint256 totalFee, uint256[] memory dvnFees) {\n        (bytes[] memory optionsArray, uint8[] memory dvnIds) = DVNOptions.groupDVNOptionsByIdx(_options);\n\n        uint8 dvnsLength = _config.requiredDVNCount + _config.optionalDVNCount;\n        dvnFees = new uint256[](dvnsLength);\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _config.requiredDVNCount\n                ? _config.requiredDVNs[i]\n                : _config.optionalDVNs[i - _config.requiredDVNCount];\n\n            bytes memory options = \"\";\n            for (uint256 j = 0; j < dvnIds.length; ++j) {\n                if (dvnIds[j] == i) {\n                    options = optionsArray[j];\n                    break;\n                }\n            }\n\n            dvnFees[i] = ILayerZeroReadDVN(dvn).assignJob(_sender, _packetHeader, _cmd, options);\n            if (dvnFees[i] > 0) {\n                fees[dvn] += dvnFees[i];\n                totalFee += dvnFees[i];\n            }\n        }\n    }\n\n    function _quoteDVNs(\n        ReadLibConfig memory _config,\n        address _sender,\n        bytes memory _packetHeader,\n        bytes calldata _cmd,\n        bytes memory _options\n    ) internal view returns (uint256 totalFee) {\n        (bytes[] memory optionsArray, uint8[] memory dvnIndices) = DVNOptions.groupDVNOptionsByIdx(_options);\n\n        // here we merge 2 list of dvns into 1 to allocate the indexed dvn options to the right dvn\n        uint8 dvnsLength = _config.requiredDVNCount + _config.optionalDVNCount;\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < _config.requiredDVNCount\n                ? _config.requiredDVNs[i]\n                : _config.optionalDVNs[i - _config.requiredDVNCount];\n\n            bytes memory options = \"\";\n            // it is a double loop here. however, if the list is short, the cost is very acceptable.\n            for (uint256 j = 0; j < dvnIndices.length; ++j) {\n                if (dvnIndices[j] == i) {\n                    options = optionsArray[j];\n                    break;\n                }\n            }\n            totalFee += ILayerZeroReadDVN(dvn).getFee(_sender, _packetHeader, _cmd, options);\n        }\n    }\n\n    function _payTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal returns (uint256 treasuryNativeFee, uint256 lzTokenFee) {\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.payFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeCall(treasuryGasLimit, 0, TREASURY_MAX_COPY, callData);\n\n            (treasuryNativeFee, lzTokenFee) = _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n            // fee should be in lzTokenFee if payInLzToken, otherwise in native\n            if (treasuryNativeFee > 0) {\n                fees[treasury] += treasuryNativeFee;\n            }\n        }\n    }\n\n    /// @dev this interface should be DoS-free if the user is paying with native. properties\n    /// 1/ treasury can return an overly high lzToken fee\n    /// 2/ if treasury returns an overly high native fee, it will be capped by maxNativeFee,\n    ///    which can be reasoned with the configurations\n    /// 3/ the owner can not configure the treasury in a way that force this function to revert\n    function _quoteTreasury(\n        address _sender,\n        uint32 _dstEid,\n        uint256 _totalNativeFee,\n        bool _payInLzToken\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // treasury must be set, and it has to be a contract\n        if (treasury != address(0x0)) {\n            bytes memory callData = abi.encodeCall(\n                ILayerZeroTreasury.getFee,\n                (_sender, _dstEid, _totalNativeFee, _payInLzToken)\n            );\n            (bool success, bytes memory result) = treasury.safeStaticCall(\n                treasuryGasLimit,\n                TREASURY_MAX_COPY,\n                callData\n            );\n\n            return _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);\n        }\n    }\n\n    function _parseTreasuryResult(\n        uint256 _totalNativeFee,\n        bool _payInLzToken,\n        bool _success,\n        bytes memory _result\n    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        // failure, charges nothing\n        if (!_success || _result.length < TREASURY_MAX_COPY) return (0, 0);\n\n        // parse the result\n        uint256 treasureFeeQuote = abi.decode(_result, (uint256));\n        if (_payInLzToken) {\n            lzTokenFee = treasureFeeQuote;\n        } else {\n            // pay in native\n            // we must prevent high-treasuryFee Dos attack\n            // nativeFee = min(treasureFeeQuote, maxNativeFee)\n            // opportunistically raise the maxNativeFee to be the same as _totalNativeFee\n            // can't use the _totalNativeFee alone because the oapp can use custom workers to force the fee to 0.\n            // maxNativeFee = max (_totalNativeFee, treasuryNativeFeeCap)\n            uint256 maxNativeFee = _totalNativeFee > treasuryNativeFeeCap ? _totalNativeFee : treasuryNativeFeeCap;\n\n            // min (treasureFeeQuote, nativeFeeCap)\n            nativeFee = treasureFeeQuote > maxNativeFee ? maxNativeFee : treasureFeeQuote;\n        }\n    }\n\n    function _verifyAndReclaimStorage(\n        ReadLibConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _cmdHash,\n        bytes32 _payloadHash\n    ) internal {\n        if (!_checkVerifiable(_config, _headerHash, _cmdHash, _payloadHash)) {\n            revert LZ_RL_Verifying();\n        }\n\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                delete hashLookup[_headerHash][_cmdHash][_config.requiredDVNs[i]];\n            }\n        }\n\n        // iterate the optional DVNs\n        if (_config.optionalDVNCount > 0) {\n            for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n                delete hashLookup[_headerHash][_cmdHash][_config.optionalDVNs[i]];\n            }\n        }\n    }\n\n    /// @dev for verifiable view function\n    /// @dev checks if this verification is ready to be committed to the endpoint\n    function _checkVerifiable(\n        ReadLibConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _cmdHash,\n        bytes32 _payloadHash\n    ) internal view returns (bool) {\n        // iterate the required DVNs\n        if (_config.requiredDVNCount > 0) {\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\n                if (!_verified(_config.requiredDVNs[i], _headerHash, _cmdHash, _payloadHash)) {\n                    // return if any of the required DVNs haven't signed\n                    return false;\n                }\n            }\n            if (_config.optionalDVNCount == 0) {\n                // returns early if all required DVNs have signed and there are no optional DVNs\n                return true;\n            }\n        }\n\n        // then it must require optional validations\n        uint8 threshold = _config.optionalDVNThreshold;\n        for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\n            if (_verified(_config.optionalDVNs[i], _headerHash, _cmdHash, _payloadHash)) {\n                // increment the optional count if the optional DVN has signed\n                threshold--;\n                if (threshold == 0) {\n                    // early return if the optional threshold has hit\n                    return true;\n                }\n            }\n        }\n\n        // return false as a catch-all\n        return false;\n    }\n\n    function _verified(\n        address _dvn,\n        bytes32 _headerHash,\n        bytes32 _cmdHash,\n        bytes32 _expectedPayloadHash\n    ) internal view returns (bool verified) {\n        verified = hashLookup[_headerHash][_cmdHash][_dvn] == _expectedPayloadHash;\n    }\n\n    function _payExecutor(\n        address _executor,\n        address _sender,\n        bytes memory _executorOptions\n    ) internal returns (uint256 executorFee) {\n        executorFee = ILayerZeroReadExecutor(_executor).assignJob(_sender, _executorOptions);\n        if (executorFee > 0) {\n            fees[_executor] += executorFee;\n        }\n        emit ExecutorFeePaid(_executor, executorFee);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/readlib/ReadLib1002View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { EndpointV2ViewUpgradeable } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol\";\n\nimport { ReadLibConfig } from \"./ReadLibBase.sol\";\nimport { ReadLib1002 } from \"./ReadLib1002.sol\";\n\nenum VerificationState {\n    Verifying,\n    Verifiable,\n    Verified,\n    NotInitializable,\n    Reorged\n}\n\ncontract ReadLib1002View is EndpointV2ViewUpgradeable, Proxied {\n    using PacketV1Codec for bytes;\n\n    ReadLib1002 public readLib;\n    uint32 internal localEid;\n\n    function initialize(address _endpoint, address payable _readLib) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n        readLib = ReadLib1002(_readLib);\n        localEid = endpoint.eid();\n    }\n\n    /// @dev get a verifiable payload hash based on the payloadHashLookup from the DVNs\n    function getVerifiablePayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _headerHash,\n        bytes32 _cmdHash\n    ) public view returns (bytes32) {\n        ReadLibConfig memory config = readLib.getReadLibConfig(_receiver, _srcEid);\n        uint8 dvnsLength = config.requiredDVNCount + config.optionalDVNCount;\n        for (uint8 i = 0; i < dvnsLength; ++i) {\n            address dvn = i < config.requiredDVNCount\n                ? config.requiredDVNs[i]\n                : config.optionalDVNs[i - config.requiredDVNCount];\n\n            bytes32 payloadHash = readLib.hashLookup(_headerHash, _cmdHash, dvn);\n            if (readLib.verifiable(config, _headerHash, _cmdHash, payloadHash)) {\n                return payloadHash;\n            }\n        }\n        return EMPTY_PAYLOAD_HASH; // not found\n    }\n\n    /// @dev a verifiable requires it to be endpoint verifiable and committable\n    function verifiable(bytes calldata _packetHeader, bytes32 _cmdHash) external view returns (VerificationState) {\n        address receiver = _packetHeader.receiverB20();\n        uint32 srcEid = _packetHeader.srcEid();\n\n        Origin memory origin = Origin(srcEid, _packetHeader.sender(), _packetHeader.nonce());\n\n        // check endpoint initializable\n        if (!initializable(origin, receiver)) {\n            return VerificationState.NotInitializable;\n        }\n\n        // check endpoint verifiable. if false, that means it is executed and can not be verified\n        if (!endpoint.verifiable(origin, receiver)) {\n            return VerificationState.Verified;\n        }\n\n        // get the verifiable payload hash\n        bytes32 payloadHash = getVerifiablePayloadHash(receiver, srcEid, keccak256(_packetHeader), _cmdHash);\n\n        if (payloadHash == EMPTY_PAYLOAD_HASH) {\n            // if payload hash is not empty, it is verified\n            if (endpoint.inboundPayloadHash(receiver, srcEid, origin.sender, origin.nonce) != EMPTY_PAYLOAD_HASH) {\n                return VerificationState.Verified;\n            }\n\n            // otherwise, it is verifying\n            return VerificationState.Verifying;\n        }\n\n        // check if the cmdHash matches\n        if (readLib.cmdHashLookup(receiver, srcEid, origin.nonce) != _cmdHash) {\n            return VerificationState.Reorged;\n        }\n\n        // check if the payload hash matches\n        // endpoint allows re-verify, check if this payload has already been verified\n        if (endpoint.inboundPayloadHash(receiver, origin.srcEid, origin.sender, origin.nonce) == payloadHash) {\n            return VerificationState.Verified;\n        }\n\n        return VerificationState.Verifiable;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/readlib/ReadLibBase.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct ReadLibConfig {\n    address executor;\n    // we store the length of required DVNs and optional DVNs instead of using DVN.length directly to save gas\n    uint8 requiredDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\n    uint8 optionalDVNThreshold; // (0, optionalDVNCount]\n    address[] requiredDVNs; // no duplicates. sorted an an ascending order. allowed overlap with optionalDVNs\n    address[] optionalDVNs; // no duplicates. sorted an an ascending order. allowed overlap with requiredDVNs\n}\n\nstruct SetDefaultReadLibConfigParam {\n    uint32 eid;\n    ReadLibConfig config;\n}\n\n/// @dev includes the utility functions for checking ReadLib states and logics\nabstract contract ReadLibBase is Ownable {\n    address internal constant DEFAULT_CONFIG = address(0);\n    // reserved values for\n    uint8 internal constant DEFAULT = 0;\n    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;\n    // 127 to prevent total number of DVNs (127 * 2) exceeding uint8.max (255)\n    // by limiting the total size, it would help constraint the design of DVNOptions\n    uint8 private constant MAX_COUNT = (type(uint8).max - 1) / 2;\n\n    mapping(address oapp => mapping(uint32 eid => ReadLibConfig config)) internal readLibConfigs;\n\n    error LZ_RL_Unsorted();\n    error LZ_RL_InvalidRequiredDVNCount();\n    error LZ_RL_InvalidOptionalDVNCount();\n    error LZ_RL_AtLeastOneDVN();\n    error LZ_RL_InvalidOptionalDVNThreshold();\n    error LZ_RL_UnsupportedEid(uint32 eid);\n    error LZ_RL_InvalidExecutor();\n\n    event DefaultReadLibConfigsSet(SetDefaultReadLibConfigParam[] params);\n    event ReadLibConfigSet(address oapp, uint32 eid, ReadLibConfig config);\n\n    // ============================ OnlyOwner ===================================\n\n    /// @dev about the DEFAULT ReadLib config\n    /// 1) its values are all LITERAL (e.g. 0 is 0). whereas in the oapp ReadLib config, 0 (default value) points to the default ReadLib config\n    ///     this design enables the oapp to point to DEFAULT config without explicitly setting the config\n    /// 2) its configuration is more restrictive than the oapp ReadLib config that\n    ///     a) it must not use NIL value, where NIL is used only by oapps to indicate the LITERAL 0\n    ///     b) it must have at least one DVN and executor\n    function setDefaultReadLibConfigs(SetDefaultReadLibConfigParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultReadLibConfigParam calldata param = _params[i];\n\n            // 2.a must not use NIL\n            if (param.config.requiredDVNCount == NIL_DVN_COUNT) revert LZ_RL_InvalidRequiredDVNCount();\n            if (param.config.optionalDVNCount == NIL_DVN_COUNT) revert LZ_RL_InvalidOptionalDVNCount();\n\n            // 2.b must have at least one dvn and executor\n            _assertAtLeastOneDVN(param.config);\n            if (param.config.executor == address(0x0)) revert LZ_RL_InvalidExecutor();\n\n            _setConfig(DEFAULT_CONFIG, param.eid, param.config);\n        }\n        emit DefaultReadLibConfigsSet(_params);\n    }\n\n    // ============================ View ===================================\n    // @dev assuming most oapps use default, we get default as memory and custom as storage to save gas\n    function getReadLibConfig(address _oapp, uint32 _remoteEid) public view returns (ReadLibConfig memory rtnConfig) {\n        ReadLibConfig storage defaultConfig = readLibConfigs[DEFAULT_CONFIG][_remoteEid];\n        ReadLibConfig storage customConfig = readLibConfigs[_oapp][_remoteEid];\n\n        address executor = customConfig.executor;\n        rtnConfig.executor = executor != address(0x0) ? executor : defaultConfig.executor;\n\n        if (customConfig.requiredDVNCount == DEFAULT) {\n            if (defaultConfig.requiredDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.requiredDVNs = defaultConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = defaultConfig.requiredDVNCount;\n            } // else, do nothing\n        } else {\n            if (customConfig.requiredDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.requiredDVNs = customConfig.requiredDVNs;\n                rtnConfig.requiredDVNCount = customConfig.requiredDVNCount;\n            } // else, do nothing\n        }\n\n        if (customConfig.optionalDVNCount == DEFAULT) {\n            if (defaultConfig.optionalDVNCount > 0) {\n                // copy only if count > 0. save gas\n                rtnConfig.optionalDVNs = defaultConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = defaultConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = defaultConfig.optionalDVNThreshold;\n            }\n        } else {\n            if (customConfig.optionalDVNCount != NIL_DVN_COUNT) {\n                rtnConfig.optionalDVNs = customConfig.optionalDVNs;\n                rtnConfig.optionalDVNCount = customConfig.optionalDVNCount;\n                rtnConfig.optionalDVNThreshold = customConfig.optionalDVNThreshold;\n            }\n        }\n\n        // the final value must have at least one dvn\n        // it is possible that some default config result into 0 dvns\n        _assertAtLeastOneDVN(rtnConfig);\n    }\n\n    /// @dev Get the readLib config without the default config for the given remoteEid.\n    function getAppReadLibConfig(address _oapp, uint32 _remoteEid) external view returns (ReadLibConfig memory) {\n        return readLibConfigs[_oapp][_remoteEid];\n    }\n\n    // ============================ Internal ===================================\n    function _setReadLibConfig(uint32 _remoteEid, address _oapp, ReadLibConfig memory _param) internal {\n        _setConfig(_oapp, _remoteEid, _param);\n\n        // get ReadLib config again as a catch all to ensure the config is valid\n        getReadLibConfig(_oapp, _remoteEid);\n        emit ReadLibConfigSet(_oapp, _remoteEid, _param);\n    }\n\n    /// @dev a supported Eid must have a valid default readLib config, which has at least one dvn\n    function _isSupportedEid(uint32 _remoteEid) internal view returns (bool) {\n        ReadLibConfig storage defaultConfig = readLibConfigs[DEFAULT_CONFIG][_remoteEid];\n        return defaultConfig.requiredDVNCount > 0 || defaultConfig.optionalDVNThreshold > 0;\n    }\n\n    function _assertSupportedEid(uint32 _remoteEid) internal view {\n        if (!_isSupportedEid(_remoteEid)) revert LZ_RL_UnsupportedEid(_remoteEid);\n    }\n\n    // ============================ Private ===================================\n\n    function _assertAtLeastOneDVN(ReadLibConfig memory _config) private pure {\n        if (_config.requiredDVNCount == 0 && _config.optionalDVNThreshold == 0) revert LZ_RL_AtLeastOneDVN();\n    }\n\n    /// @dev this private function is used in both setDefaultReadLibConfigs and setReadLibConfig\n    function _setConfig(address _oapp, uint32 _eid, ReadLibConfig memory _param) private {\n        // @dev required dvns\n        // if dvnCount == NONE, dvns list must be empty\n        // if dvnCount == DEFAULT, dvn list must be empty\n        // otherwise, dvnList.length == dvnCount and assert the list is valid\n        if (_param.requiredDVNCount == NIL_DVN_COUNT || _param.requiredDVNCount == DEFAULT) {\n            if (_param.requiredDVNs.length != 0) revert LZ_RL_InvalidRequiredDVNCount();\n        } else {\n            if (_param.requiredDVNs.length != _param.requiredDVNCount || _param.requiredDVNCount > MAX_COUNT)\n                revert LZ_RL_InvalidRequiredDVNCount();\n            _assertNoDuplicates(_param.requiredDVNs);\n        }\n\n        // @dev optional dvns\n        // if optionalDVNCount == NONE, optionalDVNs list must be empty and threshold must be 0\n        // if optionalDVNCount == DEFAULT, optionalDVNs list must be empty and threshold must be 0\n        // otherwise, optionalDVNs.length == optionalDVNCount, threshold > 0 && threshold <= optionalDVNCount and assert the list is valid\n\n        // example use case: an oapp uses the DEFAULT 'required' but\n        //     a) use a custom 1/1 dvn (practically a required dvn), or\n        //     b) use a custom 2/3 dvn\n        if (_param.optionalDVNCount == NIL_DVN_COUNT || _param.optionalDVNCount == DEFAULT) {\n            if (_param.optionalDVNs.length != 0) revert LZ_RL_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold != 0) revert LZ_RL_InvalidOptionalDVNThreshold();\n        } else {\n            if (_param.optionalDVNs.length != _param.optionalDVNCount || _param.optionalDVNCount > MAX_COUNT)\n                revert LZ_RL_InvalidOptionalDVNCount();\n            if (_param.optionalDVNThreshold == 0 || _param.optionalDVNThreshold > _param.optionalDVNCount)\n                revert LZ_RL_InvalidOptionalDVNThreshold();\n            _assertNoDuplicates(_param.optionalDVNs);\n        }\n        // don't assert valid count here, as it needs to be validated along side default config\n\n        readLibConfigs[_oapp][_eid] = _param;\n    }\n\n    function _assertNoDuplicates(address[] memory _dvns) private pure {\n        address lastDVN = address(0);\n        for (uint256 i = 0; i < _dvns.length; i++) {\n            address dvn = _dvns[i];\n            if (dvn <= lastDVN) revert LZ_RL_Unsorted(); // to ensure no duplicates\n            lastDVN = dvn;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/AddressSizeConfig.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract AddressSizeConfig is Ownable {\n    // EndpointV1 is using bytes as address. this map is for address length assertion\n    mapping(uint32 dstEid => uint256 size) public addressSizes;\n\n    event AddressSizeSet(uint16 eid, uint256 size);\n\n    error AddressSizeConfig_InvalidAddressSize();\n    error AddressSizeConfig_AddressSizeAlreadySet();\n\n    function setAddressSize(uint16 _eid, uint256 _size) external onlyOwner {\n        if (_size > 32) revert AddressSizeConfig_InvalidAddressSize();\n        if (addressSizes[_eid] != 0) revert AddressSizeConfig_AddressSizeAlreadySet();\n        addressSizes[_eid] = _size;\n        emit AddressSizeSet(_eid, _size);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/ReceiveLibBaseE1.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { AddressSizeConfig } from \"./AddressSizeConfig.sol\";\nimport { MessageLibBase } from \"../../MessageLibBase.sol\";\n\n// only receiver function from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\"\n// because we are separating the send and receive libraries\ninterface ILayerZeroReceiveLibrary {\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint256 _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint256 _configType\n    ) external view returns (bytes memory);\n}\n\nstruct SetDefaultExecutorParam {\n    uint32 eid;\n    address executor;\n}\n\n/// @dev receive-side message library base contract on endpoint v1.\n/// design:\n/// 1/ it provides an internal execute function that calls the endpoint. It enforces the path definition on V1.\n/// 2/ it provides interfaces to configure executors that is whitelisted to execute the msg to prevent grieving\nabstract contract ReceiveLibBaseE1 is MessageLibBase, AddressSizeConfig, ILayerZeroReceiveLibrary {\n    using AddressCast for bytes32;\n\n    mapping(address oapp => mapping(uint32 eid => address executor)) public executors;\n    mapping(uint32 eid => address executor) public defaultExecutors;\n\n    // this event is the same as the PacketDelivered event on EndpointV2\n    event PacketDelivered(Origin origin, address receiver);\n    event InvalidDst(\n        uint16 indexed srcChainId,\n        bytes32 srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event DefaultExecutorsSet(SetDefaultExecutorParam[] params);\n    event ExecutorSet(address oapp, uint32 eid, address executor);\n\n    error LZ_MessageLib_InvalidExecutor();\n    error LZ_MessageLib_OnlyExecutor();\n\n    constructor(address _endpoint, uint32 _localEid) MessageLibBase(_endpoint, _localEid) {}\n\n    function setDefaultExecutors(SetDefaultExecutorParam[] calldata _params) external onlyOwner {\n        for (uint256 i = 0; i < _params.length; ++i) {\n            SetDefaultExecutorParam calldata param = _params[i];\n            if (param.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();\n            defaultExecutors[param.eid] = param.executor;\n        }\n        emit DefaultExecutorsSet(_params);\n    }\n\n    function getExecutor(address _oapp, uint32 _remoteEid) public view returns (address) {\n        address executor = executors[_oapp][_remoteEid];\n        return executor != address(0x0) ? executor : defaultExecutors[_remoteEid];\n    }\n\n    function _setExecutor(uint32 _remoteEid, address _oapp, address _executor) internal {\n        executors[_oapp][_remoteEid] = _executor;\n        emit ExecutorSet(_oapp, _remoteEid, _executor);\n    }\n\n    /// @dev this function change pack the path as required for EndpointV1\n    function _execute(\n        uint16 _srcEid,\n        bytes32 _sender,\n        address _receiver,\n        uint64 _nonce,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal {\n        // if the executor is malicious, it can make the msg as a storedPayload or fail in the nonBlockingApp\n        // which might result in unintended behaviour and risks, like grieving.\n        // to err on the safe side, we should assert the executor here.\n        if (msg.sender != getExecutor(_receiver, _srcEid)) revert LZ_MessageLib_OnlyExecutor();\n\n        if (_receiver.code.length == 0) {\n            /// on chains where EOA has no codes, it will early return and emit InvalidDst event\n            // on chains where all address have codes, this will be skipped\n            emit InvalidDst(_srcEid, _sender, _receiver, _nonce, keccak256(_message));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_sender.toBytes(addressSizes[_srcEid]), _receiver);\n        ILayerZeroEndpoint(endpoint).receivePayload(_srcEid, pathData, _receiver, _nonce, _gasLimit, _message);\n\n        Origin memory origin = Origin(_srcEid, _sender, _nonce);\n        emit PacketDelivered(origin, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/ReceiveUln301.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\nimport { IUltraLightNode301 } from \"./interfaces/IUltraLightNode301.sol\";\nimport { ReceiveLibBaseE1 } from \"./ReceiveLibBaseE1.sol\";\nimport { ReceiveUlnBase } from \"../ReceiveUlnBase.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE1\ncontract ReceiveUln301 is IUltraLightNode301, ReceiveUlnBase, ReceiveLibBaseE1 {\n    using PacketV1Codec for bytes;\n    using SafeCast for uint32; // for chain ID uint32 to uint16 conversion\n\n    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint256 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint256 configType);\n\n    constructor(address _endpoint, uint32 _localEid) ReceiveLibBaseE1(_endpoint, _localEid) {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    function setConfig(\n        uint16 _eid,\n        address _oapp,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        _assertSupportedEid(_eid);\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            _setExecutor(_eid, _oapp, abi.decode(_config, (address)));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    // ============================ External ===================================\n\n    /// @dev in 301, this is equivalent to execution as in Endpoint V2\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external {\n        bytes calldata header = _packet.header();\n        _assertHeader(header, localEid);\n\n        // cache these values to save gas\n        address receiver = _packet.receiverB20();\n        uint16 srcEid = _packet.srcEid().toUint16();\n\n        UlnConfig memory config = getUlnConfig(receiver, srcEid);\n        _verifyAndReclaimStorage(config, keccak256(header), _packet.payloadHash());\n\n        // endpoint will revert if nonce != ++inboundNonce\n        _execute(srcEid, _packet.sender(), receiver, _packet.nonce(), _packet.message(), _gasLimit);\n    }\n\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {\n        _verify(_packetHeader, _payloadHash, _confirmations);\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutor(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 1);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/ReceiveUln301View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { ExecutionState, EndpointV2View } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol\";\n\nimport { UlnConfig } from \"../UlnBase.sol\";\n\nenum VerificationState {\n    Verifying,\n    Verifiable,\n    Verified\n}\n\ninterface IReceiveUln301 {\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;\n\n    function addressSizes(uint32 _dstEid) external view returns (uint256);\n\n    function endpoint() external view returns (address);\n\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool);\n\n    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);\n}\n\ncontract ReceiveUln301View is Initializable, Proxied {\n    using PacketV1Codec for bytes;\n    using AddressCast for bytes32;\n    using SafeCast for uint32;\n\n    ILayerZeroEndpoint public endpoint;\n    IReceiveUln301 public receiveUln301;\n    uint32 internal localEid;\n\n    function initialize(address _endpoint, uint32 _localEid, address _receiveUln301) external proxied initializer {\n        receiveUln301 = IReceiveUln301(_receiveUln301);\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        localEid = _localEid;\n    }\n\n    function executable(bytes calldata _packetHeader, bytes32 _payloadHash) public view returns (ExecutionState) {\n        receiveUln301.assertHeader(_packetHeader, localEid);\n\n        address receiver = _packetHeader.receiverB20();\n        uint16 srcEid = _packetHeader.srcEid().toUint16();\n        uint64 nonce = _packetHeader.nonce();\n\n        // executed if nonce less than or equal to inboundNonce\n        bytes memory path = abi.encodePacked(\n            _packetHeader.sender().toBytes(receiveUln301.addressSizes(srcEid)),\n            receiver\n        );\n        if (nonce <= endpoint.getInboundNonce(srcEid, path)) return ExecutionState.Executed;\n\n        // executable if not executed and _verified\n        if (\n            receiveUln301.verifiable(\n                receiveUln301.getUlnConfig(receiver, srcEid),\n                keccak256(_packetHeader),\n                _payloadHash\n            )\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        return ExecutionState.NotExecutable;\n    }\n\n    /// @dev keeping the same interface as 302\n    /// @dev a verifiable message requires it to be ULN verifiable only, excluding the endpoint verifiable check\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {\n        if (executable(_packetHeader, _payloadHash) == ExecutionState.NotExecutable) {\n            return VerificationState.Verifying;\n        }\n        return VerificationState.Verified;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/SendLibBaseE1.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\nimport { GUID } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/GUID.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IMessageLibE1 } from \"./interfaces/IMessageLibE1.sol\";\nimport { ITreasuryFeeHandler } from \"./interfaces/ITreasuryFeeHandler.sol\";\nimport { INonceContract } from \"./interfaces/INonceContract.sol\";\nimport { SendLibBase, WorkerOptions, ExecutorConfig } from \"../../SendLibBase.sol\";\nimport { AddressSizeConfig } from \"./AddressSizeConfig.sol\";\n\n/// @dev send-side message library base contract on endpoint v1.\n/// design:\n/// 1/ it enforces the path definition on V1 and interacts with the nonce contract\n/// 2/ quote: first executor, then verifier (e.g. DVNs), then treasury\n/// 3/ send: first executor, then verifier (e.g. DVNs), then treasury. the treasury pay much be DoS-proof\nabstract contract SendLibBaseE1 is SendLibBase, AddressSizeConfig, IMessageLibE1 {\n    INonceContract public immutable nonceContract;\n    ITreasuryFeeHandler public immutable treasuryFeeHandler;\n\n    // config\n    address internal lzToken;\n\n    // this event should be identical to the one on Endpoint V2\n    event PacketSent(bytes encodedPayload, bytes options, uint256 nativeFee, uint256 lzTokenFee);\n    event NativeFeeWithdrawn(address user, address receiver, uint256 amount);\n    event LzTokenSet(address token);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryNativeFeeCap,\n        address _nonceContract,\n        uint32 _localEid,\n        address _treasuryFeeHandler\n    ) SendLibBase(_endpoint, _localEid, _treasuryGasLimit, _treasuryNativeFeeCap) {\n        nonceContract = INonceContract(_nonceContract);\n        treasuryFeeHandler = ITreasuryFeeHandler(_treasuryFeeHandler);\n    }\n\n    // ======================= OnlyEndpoint =======================\n    /// @dev the abstract process for send() is:\n    /// 1/ pay workers, which includes the executor and the validation workers\n    /// 2/ pay treasury\n    /// 3/ in EndpointV1, here we handle the fees and refunds\n    function send(\n        address _sender,\n        uint64, // _nonce\n        uint16 _dstEid,\n        bytes calldata _path, // remoteAddress + localAddress\n        bytes calldata _message,\n        address payable _refundAddress,\n        address _lzTokenPaymentAddress,\n        bytes calldata _options\n    ) external payable onlyEndpoint {\n        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_sender, _dstEid, _path, _message, _options);\n\n        // quote treasury fee\n        uint32 dstEid = _dstEid; // stack too deep\n        address sender = _sender; // stack too deep\n        bool payInLzToken = _lzTokenPaymentAddress != address(0x0) && address(lzToken) != address(0x0);\n        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(sender, dstEid, totalNativeFee, payInLzToken);\n        totalNativeFee += treasuryNativeFee;\n\n        // pay native fee\n        // assert the user has attached enough native token for this address\n        if (msg.value < totalNativeFee) revert LZ_MessageLib_InsufficientMsgValue();\n        // refund if they send too much\n        uint256 refundAmt = msg.value - totalNativeFee;\n        if (refundAmt > 0) {\n            Transfer.native(_refundAddress, refundAmt);\n        }\n\n        // pay lz token fee if needed\n        if (lzTokenFee > 0) {\n            // in v2, we let user pass a payInLzToken boolean but always charging the sender\n            // likewise in v1, if _lzTokenPaymentAddress is passed, it must be the sender\n            if (_lzTokenPaymentAddress != sender) revert LZ_MessageLib_LzTokenPaymentAddressMustBeSender();\n            _payLzTokenFee(sender, lzTokenFee);\n        }\n\n        emit PacketSent(encodedPacket, _options, totalNativeFee, lzTokenFee);\n    }\n\n    // ======================= OnlyOwner =======================\n    function setLzToken(address _lzToken) external onlyOwner {\n        lzToken = _lzToken;\n        emit LzTokenSet(_lzToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        _setTreasury(_treasury);\n    }\n\n    // ======================= External =======================\n    function withdrawFee(address _to, uint256 _amount) external {\n        _debitFee(_amount);\n        Transfer.native(_to, _amount);\n        emit NativeFeeWithdrawn(msg.sender, _to, _amount);\n    }\n\n    // ======================= View =======================\n    function estimateFees(\n        uint16 _dstEid,\n        address _sender,\n        bytes calldata _message,\n        bool _payInLzToken,\n        bytes calldata _options\n    ) external view returns (uint256 nativeFee, uint256 lzTokenFee) {\n        return _quote(_sender, _dstEid, _message.length, _payInLzToken, _options);\n    }\n\n    // ======================= Internal =======================\n    /// @dev path = remoteAddress + localAddress.\n    function _assertPath(address _sender, bytes calldata _path, uint256 remoteAddressSize) internal pure {\n        if (_path.length != 20 + remoteAddressSize) revert LZ_MessageLib_InvalidPath();\n        address srcInPath = AddressCast.toAddress(_path[remoteAddressSize:]);\n        if (_sender != srcInPath) revert LZ_MessageLib_InvalidSender();\n    }\n\n    function _payLzTokenFee(address _sender, uint256 _lzTokenFee) internal {\n        treasuryFeeHandler.payFee(\n            lzToken,\n            _sender,\n            _lzTokenFee, // the supplied fee is always equal to the required fee\n            _lzTokenFee,\n            treasury\n        );\n    }\n\n    /// @dev outbound does three things\n    /// @dev 1) asserts path\n    /// @dev 2) increments the nonce\n    /// @dev 3) assemble packet\n    /// @return packet to be sent to workers\n    function _outbound(\n        address _sender,\n        uint16 _dstEid,\n        bytes calldata _path,\n        bytes calldata _message\n    ) internal returns (Packet memory packet) {\n        // assert toAddress size\n        uint256 remoteAddressSize = addressSizes[_dstEid];\n        if (remoteAddressSize == 0) revert LZ_MessageLib_InvalidPath();\n        _assertPath(_sender, _path, remoteAddressSize);\n\n        // increment nonce\n        uint64 nonce = nonceContract.increment(_dstEid, _sender, _path);\n\n        bytes32 receiver = AddressCast.toBytes32(_path[0:remoteAddressSize]);\n\n        bytes32 guid = GUID.generate(nonce, localEid, _sender, _dstEid, receiver);\n\n        // assemble packet\n        packet = Packet(nonce, localEid, _sender, _dstEid, receiver, guid, _message);\n    }\n\n    /// 1/ handle executor\n    /// 2/ handle other workers\n    function _payWorkers(\n        address _sender,\n        uint16 _dstEid,\n        bytes calldata _path,\n        bytes calldata _message,\n        bytes calldata _options\n    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {\n        Packet memory packet = _outbound(_sender, _dstEid, _path, _message);\n\n        // split workers options\n        (bytes memory executorOptions, WorkerOptions[] memory verificationOptions) = _splitOptions(_options);\n\n        // handle executor\n        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);\n        uint256 msgSize = packet.message.length;\n        _assertMessageSize(msgSize, config.maxMessageSize);\n        totalNativeFee += _payExecutor(config.executor, packet.dstEid, packet.sender, msgSize, executorOptions);\n\n        // handle other workers\n        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(packet, verificationOptions);\n        totalNativeFee += verifierFee;\n\n        encodedPacket = packetBytes;\n    }\n\n    // ======================= Virtual =======================\n    function _payVerifier(\n        Packet memory _packet, // packet is assembled in memory for endpoint-v1. so the location can not be calldata\n        WorkerOptions[] memory _options\n    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/SendUln301.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\n\nimport { ExecutorConfig, WorkerOptions } from \"../../SendLibBase.sol\";\nimport { SendLibBaseE1 } from \"./SendLibBaseE1.sol\";\nimport { SendUlnBase } from \"../SendUlnBase.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE1\ncontract SendUln301 is SendUlnBase, SendLibBaseE1 {\n    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint256 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint256 configType);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryGasForFeeCap,\n        address _nonceContract,\n        uint32 _localEid,\n        address _treasuryFeeHandler\n    )\n        SendLibBaseE1(\n            _endpoint,\n            _treasuryGasLimit,\n            _treasuryGasForFeeCap,\n            _nonceContract,\n            _localEid,\n            _treasuryFeeHandler\n        )\n    {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    function setConfig(\n        uint16 _eid,\n        address _oapp,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        _assertSupportedEid(_eid);\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            _setExecutorConfig(_eid, _oapp, abi.decode(_config, (ExecutorConfig)));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutorConfig(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 1);\n    }\n\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    // ============================ Internal ===================================\n\n    function _quoteVerifier(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view override returns (uint256) {\n        return _quoteDVNs(_sender, _dstEid, _options);\n    }\n\n    function _payVerifier(\n        Packet memory _packet,\n        WorkerOptions[] memory _options\n    ) internal virtual override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {\n        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);\n    }\n\n    function _splitOptions(\n        bytes calldata _options\n    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {\n        return _splitUlnOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/TreasuryFeeHandler.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\n\nimport { ITreasuryFeeHandler } from \"./interfaces/ITreasuryFeeHandler.sol\";\n\ncontract TreasuryFeeHandler is ITreasuryFeeHandler {\n    using SafeERC20 for IERC20;\n\n    ILayerZeroEndpoint public immutable endpoint;\n\n    error LZ_TreasuryFeeHandler_OnlySendLibrary();\n    error LZ_TreasuryFeeHandler_OnlyOnSending();\n    error LZ_TreasuryFeeHandler_InvalidAmount(uint256 required, uint256 supplied);\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // @dev payer of layerzero token must be sender\n    function payFee(\n        address _lzToken,\n        address _sender,\n        uint256 _required,\n        uint256 _supplied,\n        address _treasury\n    ) external {\n        // only sender's message library can call this function and only when sending a payload\n        if (endpoint.getSendLibraryAddress(_sender) != msg.sender) revert LZ_TreasuryFeeHandler_OnlySendLibrary();\n        if (!endpoint.isSendingPayload()) revert LZ_TreasuryFeeHandler_OnlyOnSending();\n        if (_required > _supplied) revert LZ_TreasuryFeeHandler_InvalidAmount(_required, _supplied);\n\n        // send lz token fee to the treasury directly\n        IERC20(_lzToken).safeTransferFrom(_sender, _treasury, _required);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/interfaces/IMessageLibE1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { ILayerZeroMessagingLibrary } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\";\n\n/// extends ILayerZeroMessagingLibrary instead of ILayerZeroMessagingLibraryV2 for reducing the contract size\ninterface IMessageLibE1 is ILayerZeroMessagingLibrary {\n    error LZ_MessageLib_InvalidPath();\n    error LZ_MessageLib_InvalidSender();\n    error LZ_MessageLib_InsufficientMsgValue();\n    error LZ_MessageLib_LzTokenPaymentAddressMustBeSender();\n\n    function setLzToken(address _lzToken) external;\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/interfaces/INonceContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface INonceContract {\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/interfaces/ITreasuryFeeHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ITreasuryFeeHandler {\n    function payFee(\n        address _lzToken,\n        address _sender,\n        uint256 _required,\n        uint256 _supplied,\n        address _treasury\n    ) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/interfaces/IUltraLightNode301.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IUltraLightNode301 {\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln301/mocks/NonceContractMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContractMock {\n    error OnlySendLibrary();\n\n    ILayerZeroEndpoint public immutable endpoint;\n    mapping(uint16 dstEid => mapping(bytes path => uint64 nonce)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        if (msg.sender != endpoint.getSendLibraryAddress(_ua)) {\n            revert OnlySendLibrary();\n        }\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/ReceiveUln302.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { SetConfigParam } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\";\nimport { ILayerZeroEndpointV2, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IReceiveUlnE2 } from \"../interfaces/IReceiveUlnE2.sol\";\nimport { ReceiveUlnBase } from \"../ReceiveUlnBase.sol\";\nimport { ReceiveLibBaseE2 } from \"../../ReceiveLibBaseE2.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE2\ncontract ReceiveUln302 is IReceiveUlnE2, ReceiveUlnBase, ReceiveLibBaseE2 {\n    using PacketV1Codec for bytes;\n\n    /// @dev CONFIG_TYPE_ULN=2 here to align with SendUln302/ReceiveUln302/ReceiveUln301\n    uint32 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint32 configType);\n\n    constructor(address _endpoint) ReceiveLibBaseE2(_endpoint) {}\n\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return _interfaceId == type(IReceiveUlnE2).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    // ============================ OnlyEndpoint ===================================\n\n    // only the ULN config on the receive side\n    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {\n        for (uint256 i = 0; i < _params.length; i++) {\n            SetConfigParam calldata param = _params[i];\n            _assertSupportedEid(param.eid);\n            if (param.configType == CONFIG_TYPE_ULN) {\n                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));\n            } else {\n                revert LZ_ULN_InvalidConfigType(param.configType);\n            }\n        }\n    }\n\n    // ============================ External ===================================\n\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\n    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external {\n        _assertHeader(_packetHeader, localEid);\n\n        // cache these values to save gas\n        address receiver = _packetHeader.receiverB20();\n        uint32 srcEid = _packetHeader.srcEid();\n\n        UlnConfig memory config = getUlnConfig(receiver, srcEid);\n        _verifyAndReclaimStorage(config, keccak256(_packetHeader), _payloadHash);\n\n        Origin memory origin = Origin(srcEid, _packetHeader.sender(), _packetHeader.nonce());\n        // endpoint will revert if nonce <= lazyInboundNonce\n        ILayerZeroEndpointV2(endpoint).verify(origin, receiver, _payloadHash);\n    }\n\n    /// @dev for dvn to verify the payload\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {\n        _verify(_packetHeader, _payloadHash, _confirmations);\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function isSupportedEid(uint32 _eid) external view override returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 2);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/ReceiveUln302View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { EndpointV2ViewUpgradeable } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\n\nenum VerificationState {\n    Verifying,\n    Verifiable,\n    Verified,\n    NotInitializable\n}\n\ninterface IReceiveUln302 {\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;\n\n    function verifiable(\n        UlnConfig memory _config,\n        bytes32 _headerHash,\n        bytes32 _payloadHash\n    ) external view returns (bool);\n\n    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);\n}\n\ncontract ReceiveUln302View is EndpointV2ViewUpgradeable, Proxied {\n    using PacketV1Codec for bytes;\n\n    IReceiveUln302 public receiveUln302;\n    uint32 internal localEid;\n\n    function initialize(address _endpoint, address _receiveUln302) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n        receiveUln302 = IReceiveUln302(_receiveUln302);\n        localEid = endpoint.eid();\n    }\n\n    /// @dev a ULN verifiable requires it to be endpoint verifiable and committable\n    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {\n        receiveUln302.assertHeader(_packetHeader, localEid);\n\n        address receiver = _packetHeader.receiverB20();\n\n        Origin memory origin = Origin(_packetHeader.srcEid(), _packetHeader.sender(), _packetHeader.nonce());\n\n        // check endpoint initializable\n        if (!initializable(origin, receiver)) {\n            return VerificationState.NotInitializable;\n        }\n\n        // check endpoint verifiable\n        if (!_endpointVerifiable(origin, receiver, _payloadHash)) {\n            return VerificationState.Verified;\n        }\n\n        // check uln verifiable\n        if (\n            receiveUln302.verifiable(\n                receiveUln302.getUlnConfig(receiver, origin.srcEid),\n                keccak256(_packetHeader),\n                _payloadHash\n            )\n        ) {\n            return VerificationState.Verifiable;\n        }\n        return VerificationState.Verifying;\n    }\n\n    /// @dev checks for endpoint verifiable and endpoint has payload hash\n    function _endpointVerifiable(\n        Origin memory origin,\n        address _receiver,\n        bytes32 _payloadHash\n    ) internal view returns (bool) {\n        // check endpoint verifiable\n        if (!verifiable(origin, _receiver, address(receiveUln302), _payloadHash)) return false;\n\n        // if endpoint.verifiable, also check if the payload hash matches\n        // endpoint allows re-verify, check if this payload has already been verified\n        if (endpoint.inboundPayloadHash(_receiver, origin.srcEid, origin.sender, origin.nonce) == _payloadHash)\n            return false;\n\n        return true;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/SendUln302.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { SetConfigParam } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\";\n\nimport { ExecutorConfig } from \"../../SendLibBase.sol\";\nimport { SendLibBaseE2, WorkerOptions } from \"../../SendLibBaseE2.sol\";\nimport { UlnConfig } from \"../UlnBase.sol\";\nimport { SendUlnBase } from \"../SendUlnBase.sol\";\n\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\n/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE2\ncontract SendUln302 is SendUlnBase, SendLibBaseE2 {\n    uint32 internal constant CONFIG_TYPE_EXECUTOR = 1;\n    uint32 internal constant CONFIG_TYPE_ULN = 2;\n\n    error LZ_ULN_InvalidConfigType(uint32 configType);\n\n    constructor(\n        address _endpoint,\n        uint256 _treasuryGasLimit,\n        uint256 _treasuryGasForFeeCap\n    ) SendLibBaseE2(_endpoint, _treasuryGasLimit, _treasuryGasForFeeCap) {}\n\n    // ============================ OnlyEndpoint ===================================\n\n    // on the send side the user can config both the executor and the ULN\n    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {\n        for (uint256 i = 0; i < _params.length; i++) {\n            SetConfigParam calldata param = _params[i];\n            _assertSupportedEid(param.eid);\n            if (param.configType == CONFIG_TYPE_EXECUTOR) {\n                _setExecutorConfig(param.eid, _oapp, abi.decode(param.config, (ExecutorConfig)));\n            } else if (param.configType == CONFIG_TYPE_ULN) {\n                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));\n            } else {\n                revert LZ_ULN_InvalidConfigType(param.configType);\n            }\n        }\n    }\n\n    // ============================ View ===================================\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\n            return abi.encode(getExecutorConfig(_oapp, _eid));\n        } else if (_configType == CONFIG_TYPE_ULN) {\n            return abi.encode(getUlnConfig(_oapp, _eid));\n        } else {\n            revert LZ_ULN_InvalidConfigType(_configType);\n        }\n    }\n\n    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (3, 0, 2);\n    }\n\n    function isSupportedEid(uint32 _eid) external view override returns (bool) {\n        return _isSupportedEid(_eid);\n    }\n\n    // ============================ Internal ===================================\n\n    function _quoteVerifier(\n        address _sender,\n        uint32 _dstEid,\n        WorkerOptions[] memory _options\n    ) internal view override returns (uint256) {\n        return _quoteDVNs(_sender, _dstEid, _options);\n    }\n\n    function _payVerifier(\n        Packet calldata _packet,\n        WorkerOptions[] memory _options\n    ) internal override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {\n        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);\n    }\n\n    function _splitOptions(\n        bytes calldata _options\n    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {\n        return _splitUlnOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/upgradeable/WorkerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { ISendLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\";\nimport { Transfer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol\";\n\nimport { IWorker } from \"../interfaces/IWorker.sol\";\n\nabstract contract WorkerUpgradeable is Initializable, AccessControlUpgradeable, PausableUpgradeable, IWorker {\n    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256(\"MESSAGE_LIB_ROLE\");\n    bytes32 internal constant ALLOWLIST = keccak256(\"ALLOWLIST\");\n    bytes32 internal constant DENYLIST = keccak256(\"DENYLIST\");\n    bytes32 internal constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    address public workerFeeLib;\n\n    uint64 public allowlistSize;\n    uint16 public defaultMultiplierBps;\n    address public priceFeed;\n\n    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;\n\n    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE\n    /// @param _priceFeed price feed address\n    /// @param _defaultMultiplierBps default multiplier for worker fee\n    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)\n    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE\n    function __Worker_init(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) internal onlyInitializing {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __Pausable_init_unchained();\n        __Worker_init_unchained(_messageLibs, _priceFeed, _defaultMultiplierBps, _roleAdmin, _admins);\n    }\n\n    function __Worker_init_unchained(\n        address[] memory _messageLibs,\n        address _priceFeed,\n        uint16 _defaultMultiplierBps,\n        address _roleAdmin,\n        address[] memory _admins\n    ) internal onlyInitializing {\n        defaultMultiplierBps = _defaultMultiplierBps;\n        priceFeed = _priceFeed;\n\n        if (_roleAdmin != address(0x0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles\n        }\n\n        for (uint256 i = 0; i < _messageLibs.length; ++i) {\n            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);\n        }\n\n        for (uint256 i = 0; i < _admins.length; ++i) {\n            _grantRole(ADMIN_ROLE, _admins[i]);\n        }\n    }\n\n    // ========================= Modifier =========================\n\n    modifier onlyAcl(address _sender) {\n        if (!hasAcl(_sender)) {\n            revert Worker_NotAllowed();\n        }\n        _;\n    }\n\n    /// @dev Access control list using allowlist and denylist\n    /// @dev 1) if one address is in the denylist -> deny\n    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow\n    /// @dev 3) else deny\n    /// @param _sender address to check\n    function hasAcl(address _sender) public view returns (bool) {\n        if (hasRole(DENYLIST, _sender)) {\n            return false;\n        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // ========================= OnyDefaultAdmin =========================\n\n    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)\n    /// @param _paused true to pause, false to unpause\n    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ========================= OnlyAdmin =========================\n\n    /// @param _priceFeed price feed address\n    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {\n        priceFeed = _priceFeed;\n        emit SetPriceFeed(_priceFeed);\n    }\n\n    /// @param _workerFeeLib worker fee lib address\n    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {\n        workerFeeLib = _workerFeeLib;\n        emit SetWorkerLib(_workerFeeLib);\n    }\n\n    /// @param _multiplierBps default multiplier for worker fee\n    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {\n        defaultMultiplierBps = _multiplierBps;\n        emit SetDefaultMultiplierBps(_multiplierBps);\n    }\n\n    /// @dev supports withdrawing fee from ULN301, ULN302 and more\n    /// @param _lib message lib address\n    /// @param _to address to withdraw fee to\n    /// @param _amount amount to withdraw\n    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();\n        ISendLib(_lib).withdrawFee(_to, _amount);\n        emit Withdraw(_lib, _to, _amount);\n    }\n\n    /// @dev supports withdrawing token from the contract\n    /// @param _token token address\n    /// @param _to address to withdraw token to\n    /// @param _amount amount to withdraw\n    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        // transfers native if _token is address(0x0)\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {\n        supportedOptionTypes[_eid] = _optionTypes;\n    }\n\n    // ========================= View Functions =========================\n    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {\n        return supportedOptionTypes[_eid];\n    }\n\n    // ========================= Internal Functions =========================\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to grant\n    /// @param _account address to grant role to\n    function _grantRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && !hasRole(_role, _account)) {\n            ++allowlistSize;\n        }\n        super._grantRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to allow for counting of allowlistSize\n    /// @param _role role to revoke\n    /// @param _account address to revoke role from\n    function _revokeRole(bytes32 _role, address _account) internal override {\n        if (_role == ALLOWLIST && hasRole(_role, _account)) {\n            --allowlistSize;\n        }\n        super._revokeRole(_role, _account);\n    }\n\n    /// @dev overrides AccessControl to disable renouncing of roles\n    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {\n        revert Worker_RoleRenouncingDisabled();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/upgradeable/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { TransparentUpgradeableProxy } from \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/ProxyAdmin.sol\n * to support custom errors and `initialOwner` constructor parameter.\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    error ImplementationCallFailed();\n    error AdminCallFailed();\n\n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        if (!success) {\n            revert ImplementationCallFailed();\n        }\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        if (!success) {\n            revert AdminCallFailed();\n        }\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/upgradeable/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\n * to support custom errors.\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error AdminAccessDenied();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            revert AdminAccessDenied();\n        }\n        super._beforeFallback();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { MessagingFee, MessagingParams, MessagingReceipt, Origin, ILayerZeroEndpointV2 } from \"./interfaces/ILayerZeroEndpointV2.sol\";\nimport { ISendLib, Packet } from \"./interfaces/ISendLib.sol\";\nimport { ILayerZeroReceiver } from \"./interfaces/ILayerZeroReceiver.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\nimport { Transfer } from \"./libs/Transfer.sol\";\nimport { MessagingChannel } from \"./MessagingChannel.sol\";\nimport { MessagingComposer } from \"./MessagingComposer.sol\";\nimport { MessageLibManager } from \"./MessageLibManager.sol\";\nimport { MessagingContext } from \"./MessagingContext.sol\";\n\n// LayerZero EndpointV2 is fully backward compatible with LayerZero Endpoint(V1), but it also supports additional\n// features that Endpoint(V1) does not support now and may not in the future. We have also changed some terminology\n// to clarify pre-existing language that might have been confusing.\n//\n// The following is a list of terminology changes:\n//     -chainId -> eid\n//          - Rationale: chainId was a term we initially used to describe an endpoint on a specific chain. Since\n//          LayerZero supports non-EVMs we could not map the classic EVM chainIds to the LayerZero chainIds, making it\n//          confusing for developers. With the addition of EndpointV2 and its backward compatible nature, we would have\n//          two chainIds per chain that has Endpoint(V1), further confusing developers. We have decided to change the\n//          name to Endpoint Id, or eid, for simplicity and clarity.\n//     -adapterParams -> options\n//     -userApplication -> oapp. Omnichain Application\n//     -srcAddress -> sender\n//     -dstAddress -> receiver\n//          - Rationale: The sender/receiver on EVM is the address. However, on non-EVM chains, the sender/receiver could\n//          represented as a public key, or some other identifier. The term sender/receiver is more generic\n//     -payload -> message.\n//          - Rationale: The term payload is used in the context of a packet, which is a combination of the message and GUID\ncontract EndpointV2 is ILayerZeroEndpointV2, MessagingChannel, MessageLibManager, MessagingComposer, MessagingContext {\n    address public lzToken;\n\n    mapping(address oapp => address delegate) public delegates;\n\n    /// @param _eid the unique Endpoint Id for this deploy that all other Endpoints can use to send to it\n    constructor(uint32 _eid, address _owner) MessagingChannel(_eid) {\n        _transferOwnership(_owner);\n    }\n\n    /// @dev MESSAGING STEP 0\n    /// @notice This view function gives the application built on top of LayerZero the ability to requests a quote\n    /// with the same parameters as they would to send their message. Since the quotes are given on chain there is a\n    /// race condition in which the prices could change between the time the user gets their quote and the time they\n    /// submit their message. If the price moves up and the user doesn't send enough funds the transaction will revert,\n    /// if the price goes down the _refundAddress provided by the app will be refunded the difference.\n    /// @param _params the messaging parameters\n    /// @param _sender the sender of the message\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory) {\n        // lzToken must be set to support payInLzToken\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // get the correct outbound nonce\n        uint64 nonce = outboundNonce[_sender][_params.dstEid][_params.receiver] + 1;\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: nonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(nonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        // use _ to avoid variable shadowing\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        return ISendLib(_sendLibrary).quote(packet, _params.options, _params.payInLzToken);\n    }\n\n    /// @dev MESSAGING STEP 1 - OApp need to transfer the fees to the endpoint before sending the message\n    /// @param _params the messaging parameters\n    /// @param _refundAddress the address to refund both the native and lzToken\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable sendContext(_params.dstEid, msg.sender) returns (MessagingReceipt memory) {\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // send message\n        (MessagingReceipt memory receipt, address _sendLibrary) = _send(msg.sender, _params);\n\n        // OApp can simulate with 0 native value it will fail with error including the required fee, which can be provided in the actual call\n        // this trick can be used to avoid the need to write the quote() function\n        // however, without the quote view function it will be hard to compose an oapp on chain\n        uint256 suppliedNative = _suppliedNative();\n        uint256 suppliedLzToken = _suppliedLzToken(_params.payInLzToken);\n        _assertMessagingFee(receipt.fee, suppliedNative, suppliedLzToken);\n\n        // handle lz token fees\n        _payToken(lzToken, receipt.fee.lzTokenFee, suppliedLzToken, _sendLibrary, _refundAddress);\n\n        // handle native fees\n        _payNative(receipt.fee.nativeFee, suppliedNative, _sendLibrary, _refundAddress);\n\n        return receipt;\n    }\n\n    /// @dev internal function for sending the messages used by all external send methods\n    /// @param _sender the address of the application sending the message to the destination chain\n    /// @param _params the messaging parameters\n    function _send(\n        address _sender,\n        MessagingParams calldata _params\n    ) internal returns (MessagingReceipt memory, address) {\n        // get the correct outbound nonce\n        uint64 latestNonce = _outbound(_sender, _params.dstEid, _params.receiver);\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: latestNonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(latestNonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        // messageLib always returns encodedPacket with guid\n        (MessagingFee memory fee, bytes memory encodedPacket) = ISendLib(_sendLibrary).send(\n            packet,\n            _params.options,\n            _params.payInLzToken\n        );\n\n        // Emit packet information for DVNs, Executors, and any other offchain infrastructure to only listen\n        // for this one event to perform their actions.\n        emit PacketSent(encodedPacket, _params.options, _sendLibrary);\n\n        return (MessagingReceipt(packet.guid, latestNonce, fee), _sendLibrary);\n    }\n\n    /// @dev MESSAGING STEP 2 - on the destination chain\n    /// @dev configured receive library verifies a message\n    /// @param _origin a struct holding the srcEid, nonce, and sender of the message\n    /// @param _receiver the receiver of the message\n    /// @param _payloadHash the payload hash of the message\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external {\n        if (!isValidReceiveLibrary(_receiver, _origin.srcEid, msg.sender)) revert Errors.LZ_InvalidReceiveLibrary();\n\n        uint64 lazyNonce = lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender];\n        if (!_initializable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotInitializable();\n        if (!_verifiable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotVerifiable();\n\n        // insert the message into the message channel\n        _inbound(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, _payloadHash);\n        emit PacketVerified(_origin, _receiver, _payloadHash);\n    }\n\n    /// @dev MESSAGING STEP 3 - the last step\n    /// @dev execute a verified message to the designated receiver\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver. the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev cant reentrant because the payload is cleared before execution\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // clear the payload first to prevent reentrancy, and then execute the message\n        _clearPayload(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, abi.encodePacked(_guid, _message));\n        ILayerZeroReceiver(_receiver).lzReceive{ value: msg.value }(_origin, _guid, _message, msg.sender, _extraData);\n        emit PacketDelivered(_origin, _receiver);\n    }\n\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor.\n    /// @param _reason the reason for failure\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzReceiveAlert(_receiver, msg.sender, _origin, _guid, _gas, _value, _message, _extraData, _reason);\n    }\n\n    /// @dev Oapp uses this interface to clear a message.\n    /// @dev this is a PULL mode versus the PUSH mode of lzReceive\n    /// @dev the cleared message can be ignored by the app (effectively burnt)\n    /// @dev authenticated by oapp\n    /// @param _origin the origin of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external {\n        _assertAuthorized(_oapp);\n\n        bytes memory payload = abi.encodePacked(_guid, _message);\n        _clearPayload(_oapp, _origin.srcEid, _origin.sender, _origin.nonce, payload);\n        emit PacketDelivered(_origin, _oapp);\n    }\n\n    /// @dev allows reconfiguration to recover from wrong configurations\n    /// @dev users should never approve the EndpointV2 contract to spend their non-layerzero tokens\n    /// @dev override this function if the endpoint is charging ERC20 tokens as native\n    /// @dev only owner\n    /// @param _lzToken the new layer zero token address\n    function setLzToken(address _lzToken) public virtual onlyOwner {\n        lzToken = _lzToken;\n        emit LzTokenSet(_lzToken);\n    }\n\n    /// @dev recover the token sent to this contract by mistake\n    /// @dev only owner\n    /// @param _token the token to recover. if 0x0 then it is native token\n    /// @param _to the address to send the token to\n    /// @param _amount the amount to send\n    function recoverToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    /// @dev handling token payments on endpoint. the sender must approve the endpoint to spend the token\n    /// @dev internal function\n    /// @param _token the token to pay\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the token\n    function _payToken(\n        address _token,\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal {\n        if (_required > 0) {\n            Transfer.token(_token, _receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.token(_token, _refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal virtual {\n        if (_required > 0) {\n            Transfer.native(_receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.native(_refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev get the balance of the lzToken as the supplied lzToken fee if payInLzToken is true\n    function _suppliedLzToken(bool _payInLzToken) internal view returns (uint256 supplied) {\n        if (_payInLzToken) {\n            supplied = IERC20(lzToken).balanceOf(address(this));\n\n            // if payInLzToken is true, the supplied fee must be greater than 0 to prevent a race condition\n            // in which an oapp sending a message with lz token and the lz token is set to a new token between the tx\n            // being sent and the tx being mined. if the required lz token fee is 0 and the old lz token would be\n            // locked in the contract instead of being refunded\n            if (supplied == 0) revert Errors.LZ_ZeroLzTokenFee();\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    function _suppliedNative() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n\n    /// @dev Assert the required fees and the supplied fees are enough\n    function _assertMessagingFee(\n        MessagingFee memory _required,\n        uint256 _suppliedNativeFee,\n        uint256 _suppliedLzTokenFee\n    ) internal pure {\n        if (_required.nativeFee > _suppliedNativeFee || _required.lzTokenFee > _suppliedLzTokenFee) {\n            revert Errors.LZ_InsufficientFee(\n                _required.nativeFee,\n                _suppliedNativeFee,\n                _required.lzTokenFee,\n                _suppliedLzTokenFee\n            );\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @return 0x0 if using native. otherwise the address of the native ERC20 token\n    function nativeToken() external view virtual returns (address) {\n        return address(0x0);\n    }\n\n    /// @notice delegate is authorized by the oapp to configure anything in layerzero\n    function setDelegate(address _delegate) external {\n        delegates[msg.sender] = _delegate;\n        emit DelegateSet(msg.sender, _delegate);\n    }\n\n    // ========================= Internal =========================\n    function _initializable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _lazyInboundNonce > 0 || // allowInitializePath already checked\n            ILayerZeroReceiver(_receiver).allowInitializePath(_origin);\n    }\n\n    /// @dev bytes(0) payloadHash can never be submitted\n    function _verifiable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _origin.nonce > _lazyInboundNonce || // either initializing an empty slot or reverifying\n            inboundPayloadHash[_receiver][_origin.srcEid][_origin.sender][_origin.nonce] != EMPTY_PAYLOAD_HASH; // only allow reverifying if it hasn't been executed\n    }\n\n    /// @dev assert the caller to either be the oapp or the delegate\n    function _assertAuthorized(address _oapp) internal view override(MessagingChannel, MessageLibManager) {\n        if (msg.sender != _oapp && msg.sender != delegates[_oapp]) revert Errors.LZ_Unauthorized();\n    }\n\n    // ========================= VIEW FUNCTIONS FOR OFFCHAIN ONLY =========================\n    // Not involved in any state transition function.\n    // ====================================================================================\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _initializable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _verifiable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2Alt.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { EndpointV2 } from \"./EndpointV2.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// @notice this is the endpoint contract for layerzero v2 deployed on chains using ERC20 as native tokens\ncontract EndpointV2Alt is EndpointV2 {\n    error LZ_OnlyAltToken();\n\n    /// @dev the altFeeToken is used for fees when the native token has no value\n    /// @dev it is immutable for gas saving. only 1 endpoint for such chains\n    address internal immutable nativeErc20;\n\n    constructor(uint32 _eid, address _owner, address _altToken) EndpointV2(_eid, _owner) {\n        nativeErc20 = _altToken;\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal override {\n        if (msg.value > 0) revert LZ_OnlyAltToken();\n        _payToken(nativeErc20, _required, _supplied, _receiver, _refundAddress);\n    }\n\n    /// @dev return the balance of the native token\n    function _suppliedNative() internal view override returns (uint256) {\n        return IERC20(nativeErc20).balanceOf(address(this));\n    }\n\n    /// @dev check if lzToken is set to the same address\n    function setLzToken(address _lzToken) public override onlyOwner {\n        if (_lzToken == nativeErc20) revert Errors.LZ_InvalidArgument();\n        super.setLzToken(_lzToken);\n    }\n\n    function nativeToken() external view override returns (address) {\n        return nativeErc20;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./EndpointV2ViewUpgradeable.sol\";\n\ncontract EndpointV2View is EndpointV2ViewUpgradeable, Proxied {\n    function initialize(address _endpoint) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./interfaces/ILayerZeroEndpointV2.sol\";\n\nenum ExecutionState {\n    NotExecutable, // executor: waits for PayloadVerified event and starts polling for executable\n    VerifiedButNotExecutable, // executor: starts active polling for executable\n    Executable,\n    Executed\n}\n\ncontract EndpointV2ViewUpgradeable is Initializable {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    function __EndpointV2View_init(address _endpoint) internal onlyInitializing {\n        __EndpointV2View_init_unchained(_endpoint);\n    }\n\n    function __EndpointV2View_init_unchained(address _endpoint) internal onlyInitializing {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function initializable(Origin memory _origin, address _receiver) public view returns (bool) {\n        try endpoint.initializable(_origin, _receiver) returns (bool _initializable) {\n            return _initializable;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev check if a message is verifiable.\n    function verifiable(\n        Origin memory _origin,\n        address _receiver,\n        address _receiveLib,\n        bytes32 _payloadHash\n    ) public view returns (bool) {\n        if (!endpoint.isValidReceiveLibrary(_receiver, _origin.srcEid, _receiveLib)) return false;\n\n        if (!endpoint.verifiable(_origin, _receiver)) return false;\n\n        // checked in _inbound for verify\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) return false;\n\n        return true;\n    }\n\n    /// @dev check if a message is executable.\n    /// @return ExecutionState of Executed, Executable, or NotExecutable\n    function executable(Origin memory _origin, address _receiver) public view returns (ExecutionState) {\n        bytes32 payloadHash = endpoint.inboundPayloadHash(_receiver, _origin.srcEid, _origin.sender, _origin.nonce);\n\n        // executed if the payload hash has been cleared and the nonce is less than or equal to lazyInboundNonce\n        if (\n            payloadHash == EMPTY_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.lazyInboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executed;\n        }\n\n        // executable if nonce has not been executed and has not been nilified and nonce is less than or equal to inboundNonce\n        if (\n            payloadHash != NIL_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.inboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        // only start active executable polling if payload hash is not empty nor nil\n        if (payloadHash != EMPTY_PAYLOAD_HASH && payloadHash != NIL_PAYLOAD_HASH) {\n            return ExecutionState.VerifiedButNotExecutable;\n        }\n\n        // return NotExecutable as a catch-all\n        return ExecutionState.NotExecutable;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/MessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"./interfaces/IMessageLib.sol\";\nimport { IMessageLibManager, SetConfigParam } from \"./interfaces/IMessageLibManager.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { BlockedMessageLib } from \"./messagelib/BlockedMessageLib.sol\";\n\nabstract contract MessageLibManager is Ownable, IMessageLibManager {\n    address private constant DEFAULT_LIB = address(0);\n\n    // the library that reverts both on send and quote\n    // must be configured on construction and be immutable\n    address public immutable blockedLibrary;\n\n    // only registered libraries all valid libraries\n    // the blockedLibrary will be registered on construction\n    address[] internal registeredLibraries;\n    mapping(address lib => bool) public isRegisteredLibrary;\n\n    // both sendLibrary and receiveLibrary config can be lazily resolved\n    mapping(address sender => mapping(uint32 dstEid => address lib)) internal sendLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => address lib)) internal receiveLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => Timeout)) public receiveLibraryTimeout;\n\n    mapping(uint32 dstEid => address lib) public defaultSendLibrary;\n    mapping(uint32 srcEid => address lib) public defaultReceiveLibrary;\n    mapping(uint32 srcEid => Timeout) public defaultReceiveLibraryTimeout;\n\n    constructor() {\n        blockedLibrary = address(new BlockedMessageLib());\n        registerLibrary(blockedLibrary);\n    }\n\n    modifier onlyRegistered(address _lib) {\n        if (!isRegisteredLibrary[_lib]) revert Errors.LZ_OnlyRegisteredLib();\n        _;\n    }\n\n    modifier isSendLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Receive) revert Errors.LZ_OnlySendLib();\n        }\n        _;\n    }\n\n    modifier isReceiveLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Send) revert Errors.LZ_OnlyReceiveLib();\n        }\n        _;\n    }\n\n    modifier onlyRegisteredOrDefault(address _lib) {\n        if (!isRegisteredLibrary[_lib] && _lib != DEFAULT_LIB) revert Errors.LZ_OnlyRegisteredOrDefaultLib();\n        _;\n    }\n\n    /// @dev check if the library supported the eid.\n    modifier onlySupportedEid(address _lib, uint32 _eid) {\n        /// @dev doesnt need to check for default lib, because when they are initially added they get passed through this modifier\n        if (_lib != DEFAULT_LIB) {\n            if (!IMessageLib(_lib).isSupportedEid(_eid)) revert Errors.LZ_UnsupportedEid();\n        }\n        _;\n    }\n\n    function getRegisteredLibraries() external view returns (address[] memory) {\n        return registeredLibraries;\n    }\n\n    /// @notice The Send Library is the Oapp specified library that will be used to send the message to the destination\n    /// endpoint. If the Oapp does not specify a Send Library, the default Send Library will be used.\n    /// @dev If the Oapp does not have a selected Send Library, this function will resolve to the default library\n    /// configured by LayerZero\n    /// @return lib address of the Send Library\n    /// @param _sender The address of the Oapp that is sending the message\n    /// @param _dstEid The destination endpoint id\n    function getSendLibrary(address _sender, uint32 _dstEid) public view returns (address lib) {\n        lib = sendLibrary[_sender][_dstEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultSendLibrary[_dstEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultSendLibUnavailable();\n        }\n    }\n\n    function isDefaultSendLibrary(address _sender, uint32 _dstEid) public view returns (bool) {\n        return sendLibrary[_sender][_dstEid] == DEFAULT_LIB;\n    }\n\n    /// @dev the receiveLibrary can be lazily resolved that if not set it will point to the default configured by LayerZero\n    function getReceiveLibrary(address _receiver, uint32 _srcEid) public view returns (address lib, bool isDefault) {\n        lib = receiveLibrary[_receiver][_srcEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultReceiveLibrary[_srcEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultReceiveLibUnavailable();\n            isDefault = true;\n        }\n    }\n\n    /// @dev called when the endpoint checks if the msgLib attempting to verify the msg is the configured msgLib of the Oapp\n    /// @dev this check provides the ability for Oapp to lock in a trusted msgLib\n    /// @dev it will fist check if the msgLib is the currently configured one. then check if the msgLib is the one in grace period of msgLib versioning upgrade\n    function isValidReceiveLibrary(\n        address _receiver,\n        uint32 _srcEid,\n        address _actualReceiveLib\n    ) public view returns (bool) {\n        // early return true if the _actualReceiveLib is the currently configured one\n        (address expectedReceiveLib, bool isDefault) = getReceiveLibrary(_receiver, _srcEid);\n        if (_actualReceiveLib == expectedReceiveLib) {\n            return true;\n        }\n\n        // check the timeout condition otherwise\n        // if the Oapp is using defaultReceiveLibrary, use the default Timeout config\n        // otherwise, use the Timeout configured by the Oapp\n        Timeout memory timeout = isDefault\n            ? defaultReceiveLibraryTimeout[_srcEid]\n            : receiveLibraryTimeout[_receiver][_srcEid];\n\n        // requires the _actualReceiveLib to be the same as the one in grace period and the grace period has not expired\n        // block.number is uint256 so timeout.expiry must > 0, which implies a non-ZERO value\n        if (timeout.lib == _actualReceiveLib && timeout.expiry > block.number) {\n            // timeout lib set and has not expired\n            return true;\n        }\n\n        // returns false by default\n        return false;\n    }\n\n    //------- Owner interfaces\n    /// @dev all libraries have to implement the erc165 interface to prevent wrong configurations\n    /// @dev only owner\n    function registerLibrary(address _lib) public onlyOwner {\n        // must have the right interface\n        if (!IERC165(_lib).supportsInterface(type(IMessageLib).interfaceId)) revert Errors.LZ_UnsupportedInterface();\n        // must have not been registered\n        if (isRegisteredLibrary[_lib]) revert Errors.LZ_AlreadyRegistered();\n\n        // insert into both the map and the list\n        isRegisteredLibrary[_lib] = true;\n        registeredLibraries.push(_lib);\n\n        emit LibraryRegistered(_lib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev can set to the blockedLibrary, which is a registered library\n    /// @dev the msgLib must enable the support before they can be registered to the endpoint as the default\n    /// @dev only owner\n    function setDefaultSendLibrary(\n        uint32 _eid,\n        address _newLib\n    ) external onlyOwner onlyRegistered(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        // must provide a different value\n        if (defaultSendLibrary[_eid] == _newLib) revert Errors.LZ_SameValue();\n        defaultSendLibrary[_eid] = _newLib;\n        emit DefaultSendLibrarySet(_eid, _newLib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev only owner\n    function setDefaultReceiveLibrary(\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyOwner onlyRegistered(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        address oldLib = defaultReceiveLibrary[_eid];\n        // must provide a different value\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n\n        defaultReceiveLibrary[_eid] = _newLib;\n        emit DefaultReceiveLibrarySet(_eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // override the current default timeout to the [old_lib + new expiry]\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = oldLib;\n            timeout.expiry = block.number + _gracePeriod;\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, timeout.expiry);\n        } else {\n            // otherwise, remove the old configuration.\n            delete defaultReceiveLibraryTimeout[_eid];\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, 0);\n        }\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2) force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setDefaultReceiveLibraryTimeout(\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) onlyOwner {\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete defaultReceiveLibraryTimeout[_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit DefaultReceiveLibraryTimeoutSet(_eid, _lib, _expiry);\n    }\n\n    /// @dev returns true only if both the default send/receive libraries are set\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return defaultSendLibrary[_eid] != address(0) && defaultReceiveLibrary[_eid] != address(0);\n    }\n\n    //------- OApp interfaces\n    /// @dev Oapp setting the sendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev authenticated by the Oapp\n    function setSendLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib\n    ) external onlyRegisteredOrDefault(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        // must provide a different value\n        if (sendLibrary[_oapp][_eid] == _newLib) revert Errors.LZ_SameValue();\n        sendLibrary[_oapp][_eid] = _newLib;\n        emit SendLibrarySet(_oapp, _eid, _newLib);\n    }\n\n    /// @dev Oapp setting the receiveLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev authenticated by the Oapp\n    /// @param _gracePeriod the number of blocks from now until oldLib expires\n    function setReceiveLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyRegisteredOrDefault(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        address oldLib = receiveLibrary[_oapp][_eid];\n        // must provide new values\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n        receiveLibrary[_oapp][_eid] = _newLib;\n        emit ReceiveLibrarySet(_oapp, _eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // to simplify the logic, we only allow to set timeout if neither the new lib nor old lib is DEFAULT_LIB, which would should read the default timeout configurations\n            // (1) if the Oapp wants to fall back to the DEFAULT, then set the newLib to DEFAULT with grace period == 0\n            // (2) if the Oapp wants to change to a non DEFAULT from DEFAULT, then set the newLib to 'non-default' with _gracePeriod == 0, then use setReceiveLibraryTimeout() interface\n            if (oldLib == DEFAULT_LIB || _newLib == DEFAULT_LIB) revert Errors.LZ_OnlyNonDefaultLib();\n\n            // write to storage\n            Timeout memory timeout = Timeout({ lib: oldLib, expiry: block.number + _gracePeriod });\n            receiveLibraryTimeout[_oapp][_eid] = timeout;\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, timeout.expiry);\n        } else {\n            delete receiveLibraryTimeout[_oapp][_eid];\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, 0);\n        }\n    }\n\n    /// @dev Oapp setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2)  force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setReceiveLibraryTimeout(\n        address _oapp,\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) {\n        _assertAuthorized(_oapp);\n\n        (, bool isDefault) = getReceiveLibrary(_oapp, _eid);\n        // if current library is DEFAULT, Oapp cant set the timeout\n        if (isDefault) revert Errors.LZ_OnlyNonDefaultLib();\n\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete receiveLibraryTimeout[_oapp][_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = receiveLibraryTimeout[_oapp][_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit ReceiveLibraryTimeoutSet(_oapp, _eid, _lib, _expiry);\n    }\n\n    //------- library config setter/getter. all pass-through functions to the msgLib\n\n    /// @dev authenticated by the _oapp\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external onlyRegistered(_lib) {\n        _assertAuthorized(_oapp);\n\n        IMessageLib(_lib).setConfig(_oapp, _params);\n    }\n\n    /// @dev a view function to query the current configuration of the OApp\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view onlyRegistered(_lib) returns (bytes memory config) {\n        return IMessageLib(_lib).getConfig(_eid, _oapp, _configType);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingChannel } from \"./interfaces/IMessagingChannel.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\n\nabstract contract MessagingChannel is IMessagingChannel {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    // The universally unique id (UUID) of this deployed Endpoint\n    uint32 public immutable eid;\n\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)))\n        public lazyInboundNonce;\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => mapping(uint64 inboundNonce => bytes32 payloadHash))))\n        public inboundPayloadHash;\n    mapping(address sender => mapping(uint32 dstEid => mapping(bytes32 receiver => uint64 nonce))) public outboundNonce;\n\n    /// @param _eid is the universally unique id (UUID) of this deployed Endpoint\n    constructor(uint32 _eid) {\n        eid = _eid;\n    }\n\n    /// @dev increase and return the next outbound nonce\n    function _outbound(address _sender, uint32 _dstEid, bytes32 _receiver) internal returns (uint64 nonce) {\n        unchecked {\n            nonce = ++outboundNonce[_sender][_dstEid][_receiver];\n        }\n    }\n\n    /// @dev inbound won't update the nonce eagerly to allow unordered verification\n    /// @dev instead, it will update the nonce lazily when the message is received\n    /// @dev messages can only be cleared in order to preserve censorship-resistance\n    function _inbound(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes32 _payloadHash\n    ) internal {\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) revert Errors.LZ_InvalidPayloadHash();\n        inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] = _payloadHash;\n    }\n\n    /// @dev returns the max index of the longest gapless sequence of verified msg nonces.\n    /// @dev the uninitialized value is 0. the first nonce is always 1\n    /// @dev it starts from the lazyInboundNonce (last checkpoint) and iteratively check if the next nonce has been verified\n    /// @dev this function can OOG if too many backlogs, but it can be trivially fixed by just clearing some prior messages\n    /// @dev NOTE: Oapp explicitly skipped nonces count as \"verified\" for these purposes\n    /// @dev eg. [1,2,3,4,6,7] => 4, [1,2,6,8,10] => 2, [1,3,4,5,6] => 1\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) public view returns (uint64) {\n        uint64 nonceCursor = lazyInboundNonce[_receiver][_srcEid][_sender];\n\n        // find the effective inbound currentNonce\n        unchecked {\n            while (_hasPayloadHash(_receiver, _srcEid, _sender, nonceCursor + 1)) {\n                ++nonceCursor;\n            }\n        }\n        return nonceCursor;\n    }\n\n    /// @dev checks if the storage slot is not initialized. Assumes computationally infeasible that payload can hash to 0\n    function _hasPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) internal view returns (bool) {\n        return inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] != EMPTY_PAYLOAD_HASH;\n    }\n\n    /// @dev the caller must provide _nonce to prevent skipping the unintended nonce\n    /// @dev it could happen in some race conditions, e.g. to skip nonce 3, but nonce 3 was consumed first\n    /// @dev usage: skipping the next nonce to prevent message verification, e.g. skip a message when Precrime throws alerts\n    /// @dev if the Oapp wants to skip a verified message, it should call the clear() function instead\n    /// @dev after skipping, the lazyInboundNonce is set to the provided nonce, which makes the inboundNonce also the provided nonce\n    /// @dev ie. allows the Oapp to increment the lazyInboundNonce without having had that corresponding msg be verified\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external {\n        _assertAuthorized(_oapp);\n\n        if (_nonce != inboundNonce(_oapp, _srcEid, _sender) + 1) revert Errors.LZ_InvalidNonce(_nonce);\n        lazyInboundNonce[_oapp][_srcEid][_sender] = _nonce;\n        emit InboundNonceSkipped(_srcEid, _sender, _oapp, _nonce);\n    }\n\n    /// @dev Marks a packet as verified, but disallows execution until it is re-verified.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev A non-verified nonce can be nilified by passing EMPTY_PAYLOAD_HASH for _payloadHash.\n    /// @dev Assumes the computational intractability of finding a payload that hashes to bytes32.max.\n    /// @dev Authenticated by the caller\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (_nonce <= lazyInboundNonce[_oapp][_srcEid][_sender] && curPayloadHash == EMPTY_PAYLOAD_HASH)\n            revert Errors.LZ_InvalidNonce(_nonce);\n        // set it to nil\n        inboundPayloadHash[_oapp][_srcEid][_sender][_nonce] = NIL_PAYLOAD_HASH;\n        emit PacketNilified(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev Marks a nonce as unexecutable and un-verifiable. The nonce can never be re-verified or executed.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev Only packets with nonces less than or equal to the lazy inbound nonce can be burned.\n    /// @dev Reverts if the nonce has already been executed.\n    /// @dev Authenticated by the caller\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (curPayloadHash == EMPTY_PAYLOAD_HASH || _nonce > lazyInboundNonce[_oapp][_srcEid][_sender])\n            revert Errors.LZ_InvalidNonce(_nonce);\n        delete inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        emit PacketBurnt(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev calling this function will clear the stored message and increment the lazyInboundNonce to the provided nonce\n    /// @dev if a lot of messages are queued, the messages can be cleared with a smaller step size to prevent OOG\n    /// @dev NOTE: this function does not change inboundNonce, it only changes the lazyInboundNonce up to the provided nonce\n    function _clearPayload(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal returns (bytes32 actualHash) {\n        uint64 currentNonce = lazyInboundNonce[_receiver][_srcEid][_sender];\n        if (_nonce > currentNonce) {\n            unchecked {\n                // try to lazily update the inboundNonce till the _nonce\n                for (uint64 i = currentNonce + 1; i <= _nonce; ++i) {\n                    if (!_hasPayloadHash(_receiver, _srcEid, _sender, i)) revert Errors.LZ_InvalidNonce(i);\n                }\n                lazyInboundNonce[_receiver][_srcEid][_sender] = _nonce;\n            }\n        }\n\n        // check the hash of the payload to verify the executor has given the proper payload that has been verified\n        actualHash = keccak256(_payload);\n        bytes32 expectedHash = inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n        if (expectedHash != actualHash) revert Errors.LZ_PayloadHashNotFound(expectedHash, actualHash);\n\n        // remove it from the storage\n        delete inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n    }\n\n    /// @dev returns the GUID for the next message given the path\n    /// @dev the Oapp might want to include the GUID into the message in some cases\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32) {\n        uint64 nextNonce = outboundNonce[_sender][_dstEid][_receiver] + 1;\n        return GUID.generate(nextNonce, eid, _sender, _dstEid, _receiver);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingComposer } from \"./interfaces/IMessagingComposer.sol\";\nimport { ILayerZeroComposer } from \"./interfaces/ILayerZeroComposer.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\nabstract contract MessagingComposer is IMessagingComposer {\n    bytes32 private constant NO_MESSAGE_HASH = bytes32(0);\n    bytes32 private constant RECEIVED_MESSAGE_HASH = bytes32(uint256(1));\n\n    mapping(address from => mapping(address to => mapping(bytes32 guid => mapping(uint16 index => bytes32 messageHash))))\n        public composeQueue;\n\n    /// @dev the Oapp sends the lzCompose message to the endpoint\n    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function\n    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time\n    /// @dev authenticated by the msg.sender\n    /// @param _to the address which will receive the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n        // must have not been sent before\n        if (composeQueue[msg.sender][_to][_guid][_index] != NO_MESSAGE_HASH) revert Errors.LZ_ComposeExists();\n        composeQueue[msg.sender][_to][_guid][_index] = keccak256(_message);\n        emit ComposeSent(msg.sender, _to, _guid, _index, _message);\n    }\n\n    /// @dev execute a composed messages from the sender to the composer (receiver)\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver.\n    ///      the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev can not re-entrant\n    /// @param _from the address which sends the composed message. in most cases, it is the Oapp's address.\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // assert the validity\n        bytes32 expectedHash = composeQueue[_from][_to][_guid][_index];\n        bytes32 actualHash = keccak256(_message);\n        if (expectedHash != actualHash) revert Errors.LZ_ComposeNotFound(expectedHash, actualHash);\n\n        // marks the message as received to prevent reentrancy\n        // cannot just delete the value, otherwise the message can be sent again and could result in some undefined behaviour\n        // even though the sender(composing Oapp) is implicitly fully trusted by the composer.\n        // eg. sender may not even realize it has such a bug\n        composeQueue[_from][_to][_guid][_index] = RECEIVED_MESSAGE_HASH;\n        ILayerZeroComposer(_to).lzCompose{ value: msg.value }(_from, _guid, _message, msg.sender, _extraData);\n        emit ComposeDelivered(_from, _to, _guid, _index);\n    }\n\n    /// @param _from the address which sends the composed message\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor\n    /// @param _reason the reason why the message is not received\n    function lzComposeAlert(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzComposeAlert(_from, _to, msg.sender, _guid, _index, _gas, _value, _message, _extraData, _reason);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/MessagingContext.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingContext } from \"./interfaces/IMessagingContext.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// this contract acts as a non-reentrancy guard and a source of messaging context\n/// the context includes the remote eid and the sender address\n/// it separates the send and receive context to allow messaging receipts (send back on receive())\nabstract contract MessagingContext is IMessagingContext {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private _sendContext = NOT_ENTERED;\n\n    /// @dev the sendContext is set to 8 bytes 0s + 4 bytes eid + 20 bytes sender\n    modifier sendContext(uint32 _dstEid, address _sender) {\n        if (_sendContext != NOT_ENTERED) revert Errors.LZ_SendReentrancy();\n        _sendContext = (uint256(_dstEid) << 160) | uint160(_sender);\n        _;\n        _sendContext = NOT_ENTERED;\n    }\n\n    /// @dev returns true if sending message\n    function isSendingMessage() public view returns (bool) {\n        return _sendContext != NOT_ENTERED;\n    }\n\n    /// @dev returns (eid, sender) if sending message, (0, 0) otherwise\n    function getSendContext() external view returns (uint32, address) {\n        return isSendingMessage() ? _getSendContext(_sendContext) : (0, address(0));\n    }\n\n    function _getSendContext(uint256 _context) internal pure returns (uint32, address) {\n        return (uint32(_context >> 160), address(uint160(_context)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @title ILayerZeroComposer\n */\ninterface ILayerZeroComposer {\n    /**\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev To ensure non-reentrancy, implementers of this interface MUST assert msg.sender is the corresponding EndpointV2 contract (i.e., onlyEndpointV2).\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     * @param _executor The address of the executor for the composed message.\n     * @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary Errors {\n    error LZ_LzTokenUnavailable();\n    error LZ_InvalidReceiveLibrary();\n    error LZ_InvalidNonce(uint64 nonce);\n    error LZ_InvalidArgument();\n    error LZ_InvalidExpiry();\n    error LZ_InvalidAmount(uint256 required, uint256 supplied);\n    error LZ_OnlyRegisteredOrDefaultLib();\n    error LZ_OnlyRegisteredLib();\n    error LZ_OnlyNonDefaultLib();\n    error LZ_Unauthorized();\n    error LZ_DefaultSendLibUnavailable();\n    error LZ_DefaultReceiveLibUnavailable();\n    error LZ_PathNotInitializable();\n    error LZ_PathNotVerifiable();\n    error LZ_OnlySendLib();\n    error LZ_OnlyReceiveLib();\n    error LZ_UnsupportedEid();\n    error LZ_UnsupportedInterface();\n    error LZ_AlreadyRegistered();\n    error LZ_SameValue();\n    error LZ_InvalidPayloadHash();\n    error LZ_PayloadHashNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeExists();\n    error LZ_SendReentrancy();\n    error LZ_NotImplemented();\n    error LZ_InsufficientFee(\n        uint256 requiredNative,\n        uint256 suppliedNative,\n        uint256 requiredLzToken,\n        uint256 suppliedLzToken\n    );\n    error LZ_ZeroLzTokenFee();\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/GUID.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"./AddressCast.sol\";\n\nlibrary GUID {\n    using AddressCast for address;\n\n    function generate(\n        uint64 _nonce,\n        uint32 _srcEid,\n        address _sender,\n        uint32 _dstEid,\n        bytes32 _receiver\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _srcEid, _sender.toBytes32(), _dstEid, _receiver));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    using SafeERC20 for IERC20;\n\n    address internal constant ADDRESS_ZERO = address(0);\n\n    error Transfer_NativeFailed(address _to, uint256 _value);\n    error Transfer_ToAddressIsZero();\n\n    function native(address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        (bool success, ) = _to.call{ value: _value }(\"\");\n        if (!success) revert Transfer_NativeFailed(_to, _value);\n    }\n\n    function token(address _token, address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        IERC20(_token).safeTransfer(_to, _value);\n    }\n\n    function nativeOrToken(address _token, address _to, uint256 _value) internal {\n        if (_token == ADDRESS_ZERO) {\n            native(_to, _value);\n        } else {\n            token(_token, _to, _value);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/BlockedMessageLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\n\ncontract BlockedMessageLib is ERC165 {\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (type(uint64).max, type(uint8).max, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    fallback() external {\n        revert Errors.LZ_NotImplemented();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/SimpleMessageLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Packet } from \"../interfaces/ISendLib.sol\";\nimport { ILayerZeroEndpointV2, MessagingFee, Origin } from \"../interfaces/ILayerZeroEndpointV2.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\nimport { PacketV1Codec } from \"./libs/PacketV1Codec.sol\";\nimport { Transfer } from \"../libs/Transfer.sol\";\n\ncontract SimpleMessageLib is Ownable, ERC165 {\n    using SafeERC20 for IERC20;\n    using PacketV1Codec for bytes;\n\n    address public immutable endpoint;\n    address public immutable treasury;\n    uint32 public immutable localEid;\n    uint8 public constant PACKET_VERSION = 1;\n\n    address public whitelistCaller;\n\n    uint256 public lzTokenFee;\n    uint256 public nativeFee;\n\n    bytes public defaultOption;\n\n    error OnlyEndpoint();\n    error OnlyWhitelistCaller();\n    error InvalidEndpoint(address expected, address actual);\n    error ToIsAddressZero();\n    error LzTokenIsAddressZero();\n    error TransferFailed();\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        if (endpoint != msg.sender) {\n            revert OnlyEndpoint();\n        }\n        _;\n    }\n\n    constructor(address _endpoint, address _treasury) {\n        endpoint = _endpoint;\n        treasury = _treasury;\n        localEid = ILayerZeroEndpointV2(_endpoint).eid();\n        lzTokenFee = 99;\n        nativeFee = 100;\n        //        defaultOption = Options.encodeLegacyOptionsType1(200000);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // no validation logic at all\n    function validatePacket(bytes calldata packetBytes) external {\n        if (whitelistCaller != address(0x0) && msg.sender != whitelistCaller) {\n            revert OnlyWhitelistCaller();\n        }\n        Origin memory origin = Origin(packetBytes.srcEid(), packetBytes.sender(), packetBytes.nonce());\n        ILayerZeroEndpointV2(endpoint).verify(origin, packetBytes.receiverB20(), keccak256(packetBytes.payload()));\n    }\n\n    // ------------------ onlyEndpoint ------------------\n    function send(\n        Packet calldata _packet,\n        bytes memory _options,\n        bool _payInLzToken\n    ) external onlyEndpoint returns (MessagingFee memory fee, bytes memory encodedPacket, bytes memory options) {\n        encodedPacket = PacketV1Codec.encode(_packet);\n\n        options = _options.length == 0 ? defaultOption : _options;\n        _handleMessagingParamsHook(encodedPacket, options);\n\n        fee = MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    // ------------------ onlyOwner ------------------\n    function setDefaultOption(bytes memory _defaultOption) external onlyOwner {\n        defaultOption = _defaultOption;\n    }\n\n    function setMessagingFee(uint256 _nativeFee, uint256 _lzTokenFee) external onlyOwner {\n        nativeFee = _nativeFee;\n        lzTokenFee = _lzTokenFee;\n    }\n\n    function setWhitelistCaller(address _whitelistCaller) external onlyOwner {\n        whitelistCaller = _whitelistCaller;\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n\n        address altTokenAddr = ILayerZeroEndpointV2(endpoint).nativeToken();\n\n        // transfers native if altTokenAddr == address(0x0)\n        Transfer.nativeOrToken(altTokenAddr, _to, _amount);\n    }\n\n    function withdrawLzTokenFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n        address lzToken = ILayerZeroEndpointV2(endpoint).lzToken();\n        if (lzToken == address(0x0)) {\n            revert LzTokenIsAddressZero();\n        }\n        IERC20(lzToken).safeTransfer(_to, _amount);\n    }\n\n    // ------------------ View ------------------\n    function quote(\n        Packet calldata /*_packet*/,\n        bytes calldata /*_options*/,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        return MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (0, 0, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    // ------------------ Internal ------------------\n    function _handleMessagingParamsHook(bytes memory _encodedPacket, bytes memory _options) internal virtual {}\n\n    fallback() external payable {\n        revert Errors.LZ_NotImplemented();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { CalldataBytesLib } from \"../../libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\n * to support custom errors.\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error AdminAccessDenied();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            revert AdminAccessDenied();\n        }\n        super._beforeFallback();\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/Endpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Endpoint is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(\n        uint16 srcChainId,\n        bytes srcAddress,\n        address dstAddress,\n        uint64 nonce,\n        bytes payload,\n        bytes reason\n    );\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(\n            msg.sender,\n            nonce,\n            _dstChainId,\n            _destination,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n                uint64(_payload.length),\n                _dstAddress,\n                keccak256(_payload)\n            );\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(\n            _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\n            \"LayerZero: invalid payload\"\n        );\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(\n        uint16 _newDefaultSendVersion\n    ) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(\n        uint16 _newDefaultReceiveVersion\n    ) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(\n                defaultSendVersion == defaultReceiveVersion,\n                \"LayerZero: can not set Config during DEFAULT migration\"\n            );\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION\n            ? defaultSendLibrary\n            : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(\n        address _userApplication\n    ) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(\n        address _userApplication\n    ) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_dstChainId][_srcAddress];\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/EndpointLite.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract EndpointLite is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(\n        uint16 srcChainId,\n        bytes srcAddress,\n        address dstAddress,\n        uint64 nonce,\n        bytes payload,\n        bytes reason\n    );\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(\n            msg.sender,\n            0,\n            _dstChainId,\n            _destination,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n                uint64(_payload.length),\n                _dstAddress,\n                keccak256(_payload)\n            );\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(\n            _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\n            \"LayerZero: invalid payload\"\n        );\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(\n        uint16 _newDefaultSendVersion\n    ) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(\n        uint16 _newDefaultReceiveVersion\n    ) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(\n                defaultSendVersion == defaultReceiveVersion,\n                \"LayerZero: can not set Config during DEFAULT migration\"\n            );\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION\n            ? defaultSendLibrary\n            : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(\n        address _userApplication\n    ) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(\n        address _userApplication\n    ) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16, address) external pure override returns (uint64) {\n        revert(\"LayerZero: no outbound nonce at endpoint\");\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/FeeHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract FeeHandler is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public feeToken;\n    mapping(address => bool) public approved;\n\n    constructor() {}\n\n    function setFeeToken(address _feeToken) external onlyOwner {\n        require(address(feeToken) == address(0x0), \"FeeHandler: feeToken already set\");\n        feeToken = IERC20(_feeToken);\n    }\n\n    function approve(address _uln) external onlyOwner {\n        approved[_uln] = true;\n    }\n\n    function creditFee(address[] calldata _receivers, uint[] calldata _amounts, address _refundAddress) external {\n        require(_receivers.length == _amounts.length, \"FeeHandler: invalid parameters\");\n        require(approved[msg.sender], \"FeeHandler: not approved\");\n\n        for (uint i = 0; i < _receivers.length; i++) {\n            feeToken.safeTransfer(_receivers[i], _amounts[i]);\n        }\n        uint remaining = feeToken.balanceOf(address(this));\n        if (remaining > 0) {\n            feeToken.safeTransfer(_refundAddress, remaining);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/NonceContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContract {\n    ILayerZeroEndpoint public immutable endpoint;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(\n            endpoint.getSendLibraryAddress(_ua) == msg.sender,\n            \"NonceContract: msg.sender is not valid sendlibrary\"\n        );\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/NonceContractRadar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract NonceContractRadar {\n    ILayerZeroEndpoint public immutable endpoint;\n    address public immutable ulnv2Radar;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n\n    constructor(address _endpoint, address _ulnv2Radar) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        ulnv2Radar = _ulnv2Radar;\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(\n            endpoint.getSendLibraryAddress(_ua) == msg.sender,\n            \"NonceContract: msg.sender is not valid sendlibrary\"\n        );\n        return ++outboundNonce[_chainId][_path];\n    }\n\n    // only ulnv2Radar can call this function\n    function initRadarOutboundNonce(uint16 _dstChainId, bytes calldata _path, uint64 _nonce) external {\n        require(msg.sender == ulnv2Radar, \"NonceContract: only ulnv2Radar\");\n        outboundNonce[_dstChainId][_path] = _nonce;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\ncontract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {\n    using SafeMath for uint;\n\n    uint128 public PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address => bool) public priceUpdater;\n\n    // [_chainId]\n    mapping(uint16 => Price) public defaultModelPrice;\n    ArbitrumPriceExt public arbitrumPriceExt;\n\n    uint128 public override nativeTokenPriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public proxied initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e10; // gas optimization: if you change this, you also need to change the RelayerV2\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    function onUpgrade() public proxied {\n        PRICE_RATIO_DENOMINATOR = 1e10; // gas optimization: if you change this, you also need to change the RelayerV2\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            require(priceUpdater[msg.sender], \"PriceFeed: not price updater\");\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.chainId, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePriceExt calldata _update = _price[i];\n\n            _setPrice(_update.chainId, _update.price);\n\n            uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n            uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n            arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n            arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n        }\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        nativeTokenPriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ Internal ==========================================\n    function _setPrice(uint16 chainId, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        defaultModelPrice[chainId] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    // For optimism l1 gas price lookup\n    function _getL1LookupId(uint16 _l2ChainId) internal pure returns (uint16) {\n        if (_l2ChainId == 111) {\n            return 101;\n        } else if (_l2ChainId == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (_l2ChainId == 20132) {\n            return 20121; // ethereum-goerli\n        } else {\n            revert(\"PriceFeed: unknown l2 chain id\");\n        }\n    }\n\n    // ============================ View ==========================================\n\n    function getPrice(uint16 _dstChainId) external view override returns (Price memory price) {\n        price = defaultModelPrice[_dstChainId];\n    }\n\n    function getPriceRatioDenominator() external view override returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    function estimateFeeByChain(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) external view override returns (uint fee, uint128 priceRatio) {\n        if (_dstChainId == 110 || _dstChainId == 10143 || _dstChainId == 20143) {\n            return estimateFeeWithArbitrumModel(_dstChainId, _callDataSize, _gas);\n        } else if (_dstChainId == 111 || _dstChainId == 10132 || _dstChainId == 20132) {\n            return estimateFeeWithOptimismModel(_dstChainId, _callDataSize, _gas);\n        } else {\n            return estimateFeeWithDefaultModel(_dstChainId, _callDataSize, _gas);\n        }\n    }\n\n    function estimateFeeWithDefaultModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        Price storage remotePrice = defaultModelPrice[_dstChainId];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint gasForCallData = _callDataSize.mul(remotePrice.gasPerByte);\n        uint remoteFee = (gasForCallData.add(_gas)).mul(remotePrice.gasPriceInUnit);\n        return ((remoteFee.mul(remotePrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), remotePrice.priceRatio);\n    }\n\n    function estimateFeeWithOptimismModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        uint16 ethereumId = _getL1LookupId(_dstChainId);\n\n        // L1 fee\n        Price storage ethereumPrice = defaultModelPrice[ethereumId];\n        uint gasForL1CallData = _callDataSize.mul(ethereumPrice.gasPerByte).add(3188); // 2100 + 68 * 16\n        uint l1Fee = gasForL1CallData.mul(ethereumPrice.gasPriceInUnit);\n\n        // L2 fee\n        Price storage optimismPrice = defaultModelPrice[_dstChainId];\n        uint gasForL2CallData = _callDataSize.mul(optimismPrice.gasPerByte);\n        uint l2Fee = (gasForL2CallData.add(_gas)).mul(optimismPrice.gasPriceInUnit);\n\n        uint l1FeeInSrcPrice = l1Fee.mul(ethereumPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint l2FeeInSrcPrice = l2Fee.mul(optimismPrice.priceRatio).div(PRICE_RATIO_DENOMINATOR);\n        uint gasFee = l1FeeInSrcPrice.add(l2FeeInSrcPrice);\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function estimateFeeWithArbitrumModel(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) public view returns (uint fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = defaultModelPrice[_dstChainId];\n\n        // L1 fee\n        uint gasForL1CallData = _callDataSize.mul(ARBITRUM_COMPRESSION_PERCENT).div(100).mul(\n            arbitrumPriceExt.gasPerL1CallDataByte\n        );\n        // L2 Fee\n        uint gasForL2CallData = _callDataSize.mul(arbitrumPrice.gasPerByte);\n        uint gasFee = (_gas.add(arbitrumPriceExt.gasPerL2Tx).add(gasForL1CallData).add(gasForL2CallData)).mul(\n            arbitrumPrice.gasPriceInUnit\n        );\n\n        return ((gasFee.mul(arbitrumPrice.priceRatio)).div(PRICE_RATIO_DENOMINATOR), arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/Relayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Relayer is ILayerZeroRelayer, ReentrancyGuard, OwnableUpgradeable, Proxied {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV1 public uln;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookup;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event WithdrawTokens(address token, address to, uint amount);\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n\n    address public stargateBridgeAddress;\n\n    event InvalidPayloadSize(uint indexed payloadSize);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n\n    //----------------------------------------------------------------------------------\n    // Relayer Interface V2 Change\n\n    event AssignJob(uint16 dstChainId, uint16 outboundProofType, address userApplication, uint totalFee);\n    event Ulnv2Set(address ulnv2);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved \");\n        }\n        _;\n    }\n\n    function initialize(address _uln) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n        setApprovedAddress(address(this), true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _transactionProof);\n    }\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    // other relayer fees are withdrawn through the RelayerFee interface\n    // uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2;\n    function withdrawQuotedFromULN(address payable _to, uint _amount) external onlyApproved {\n        uln.withdrawNative(2, address(0x0), _to, _amount);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        bytes memory _adapterParameters\n    ) internal view returns (uint basePrice, uint pricePerByte) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstPrice storage dstPrice = dstPriceLookup[_dstChainId];\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        uint totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\n        if (txType == 2) {\n            uint dstNativeAmt;\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large \");\n            totalRemoteToken = totalRemoteToken.add(dstNativeAmt);\n        }\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\n        uint remoteGasTotal = dstPrice.dstGasPriceInWei.mul(dstConfig.baseGas.add(extraGas));\n\n        totalRemoteToken = totalRemoteToken.add(remoteGasTotal);\n\n        // tokenConversionRate = dstPrice / localPrice\n        // basePrice = totalRemoteToken * tokenConversionRate\n        basePrice = totalRemoteToken.mul(dstPrice.dstPriceRatio).div(10 ** 10);\n\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\n        pricePerByte = dstPrice.dstGasPriceInWei.mul(dstConfig.gasPerByte).mul(dstPrice.dstPriceRatio).div(10 ** 10);\n    }\n\n    function notifyRelayer(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        bytes calldata _adapterParams\n    ) external override {\n        //do nothing\n    }\n\n    function getPrice(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        (uint basePrice, uint pricePerByte) = _getPrices(\n            _dstChainId,\n            _outboundProofType,\n            _userApplication,\n            _adapterParams\n        );\n        return basePrice.add(payloadSize.mul(pricePerByte));\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/RelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeedV2.sol\";\nimport \"./libs/RateLimiter.sol\";\n\ninterface IStargateComposer {\n    function isSending() external view returns (bool);\n}\n\ncontract RelayerV2 is ReentrancyGuard, OwnableUpgradeable, Proxied, ILayerZeroRelayerV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n    using RateLimiter for RateLimiter.Info;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n    address public stargateBridgeAddress;\n    uint public constant AIRDROP_GAS_LIMIT = 10000;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    struct DstMultiplier {\n        uint16 chainId;\n        uint128 multiplier;\n    }\n\n    struct DstFloorMargin {\n        uint16 chainId;\n        uint128 floorMargin;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookupOld;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event SetPriceConfigUpdater(address priceConfigUpdater, bool allow);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(\n        uint16 chainId,\n        uint16 outboundProofType,\n        uint128 dstNativeAmtCap,\n        uint64 baseGas,\n        uint64 gasPerByte\n    );\n\n    // new pauseable relayer\n    bool public paused;\n\n    // Update for Price Feed\n    ILayerZeroPriceFeedV2 public priceFeed;\n    // multipler for airdrop\n    uint128 public multiplierBps;\n\n    // PriceFeedContract Upgrade\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead;\n\n    // [chainId] => [multiplier]\n    mapping(uint16 => uint128) public dstMultipliers;\n    // [chainId] => [floor margin in USD]\n    mapping(uint16 => uint128) public dstFloorMarginsUSD;\n    mapping(address => bool) public priceConfigUpdaters;\n\n    // stargate guard\n    IStargateComposer public stargateComposer;\n    address public stargateBridgeAddr;\n\n    uint256 public nativeDecimalsRate;\n\n    RateLimiter.Info public limiter; // deprecated\n\n    event RateLimiterSet(uint64 capacity, uint64 rate); // deprecated\n\n    mapping(address => bool) public limiterWhitelist; // if true, sender bypasses rate limits\n    mapping(uint16 => RateLimiter.Info) public limiters;\n    event DstRateLimiterSet(uint16 dstChain, uint64 capacity, uint64 rate);\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    modifier onlyPriceConfigUpdater() {\n        if (owner() != msg.sender && !approvedAddresses[msg.sender]) {\n            require(priceConfigUpdaters[msg.sender], \"Relayer: not updater\");\n        }\n        _;\n    }\n\n    function initialize(\n        address _uln,\n        address _priceFeed,\n        address _stargateBridgeAddr,\n        address _stargateComposer,\n        uint256 _nativeDecimalsRate\n    ) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_uln);\n        setApprovedAddress(address(this), true);\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeedV2(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n        stargateBridgeAddr = _stargateBridgeAddr;\n        stargateComposer = IStargateComposer(_stargateComposer);\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    function onUpgrade(\n        address _stargateBridgeAddr,\n        address _stargateComposer,\n        uint256 _nativeDecimalsRate\n    ) public proxied {\n        stargateBridgeAddr = _stargateBridgeAddr;\n        stargateComposer = IStargateComposer(_stargateComposer);\n        nativeDecimalsRate = _nativeDecimalsRate;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n    function setLimiterWhitelist(address _addr, bool _skipRateLimits) external onlyApproved {\n        limiterWhitelist[_addr] = _skipRateLimits;\n    }\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        // No longer used: Write prices in PriceFeed.\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeedV2(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstPriceMultipliers(DstMultiplier[] calldata _multipliers) external onlyPriceConfigUpdater {\n        for (uint i = 0; i < _multipliers.length; i++) {\n            DstMultiplier calldata _data = _multipliers[i];\n            dstMultipliers[_data.chainId] = _data.multiplier;\n        }\n    }\n\n    function setDstFloorMarginsUSD(DstFloorMargin[] calldata _margins) external onlyPriceConfigUpdater {\n        for (uint i = 0; i < _margins.length; i++) {\n            DstFloorMargin calldata _data = _margins[i];\n            dstFloorMarginsUSD[_data.chainId] = _data.floorMargin;\n        }\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n    function configRateLimiter(uint16 _dstChainId, uint64 _capacity, uint64 _rate) external onlyOwner {\n        RateLimiter.Info storage dstLimiter = limiters[_dstChainId];\n        dstLimiter.setCapacity(_capacity);\n        dstLimiter.setRate(_rate);\n        emit DstRateLimiterSet(_dstChainId, _capacity, _rate);\n    }\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPriceConfigUpdater(address _priceConfigUpdater, bool _allow) public onlyOwner {\n        priceConfigUpdaters[_priceConfigUpdater] = _allow;\n        emit SetPriceConfigUpdater(_priceConfigUpdater, _allow);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        uint _payloadSize,\n        bytes memory _adapterParameters\n    ) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? _payloadSize.add(fpBytes) : _payloadSize.add(mptOverhead);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD) = priceFeed\n            .estimateFeeByEid(dstChainId, totalFixedBytes.add(proofBytes), dstConfig.baseGas.add(extraGas));\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n        uint airdropAmount = 0;\n        if (dstNativeAmt > 0) {\n            // gas saver if no airdrop\n            airdropAmount = dstNativeAmt.mul(priceRatio).div(priceRatioDenominator).mul(multiplierBps).div(10000); // cheaper than priceFeed.getPriceRatioDenominator()\n        }\n        return _getDstTxCost(dstChainId, fee, nativePriceUSD).add(airdropAmount);\n    }\n\n    function _getDstTxCost(uint16 _dstChainId, uint _fee, uint128 nativeTokenPriceUSD) private view returns (uint) {\n        uint128 _dstMultiplier = dstMultipliers[_dstChainId];\n        if (_dstMultiplier == 0) {\n            _dstMultiplier = multiplierBps;\n        }\n        uint dstTxCostWithMultiplier = _fee.mul(_dstMultiplier).div(10000);\n\n        if (nativeTokenPriceUSD == 0) {\n            return dstTxCostWithMultiplier;\n        }\n\n        uint dstTxCostWithMargin = _fee.add(\n            dstFloorMarginsUSD[_dstChainId].mul(nativeDecimalsRate).div(nativeTokenPriceUSD)\n        );\n\n        return dstTxCostWithMargin > dstTxCostWithMultiplier ? dstTxCostWithMargin : dstTxCostWithMultiplier;\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    // view function to convert pricefeed price to current price (for backwards compatibility)\n    function dstPriceLookup(uint16 _dstChainId) public view returns (DstPrice memory) {\n        ILayerZeroPriceFeedV2.Price memory price = priceFeed.getPrice(_dstChainId);\n        return DstPrice(price.priceRatio, price.gasPriceInUnit);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external override returns (uint fee) {\n        if (_dstChainId >= 10000) {\n            RateLimiter.Info storage dstLimiter = limiters[_dstChainId];\n            // sandbox or testnet\n            if (!limiterWhitelist[_userApplication] && dstLimiter.capacity > 0) {\n                dstLimiter.tryConsume(10000);\n            }\n        }\n\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize > 10000\");\n\n        if (_userApplication == stargateBridgeAddr) {\n            // following way also prevents user from inputting to address greater than 32 bytes\n            bool validPayload = (_payloadSize == 544 || // swap with no payload\n                _payloadSize == 320 || // redeem local callback\n                _payloadSize == 288 || // redeem local\n                _payloadSize == 160); // send credits\n\n            if (!validPayload) {\n                require(stargateComposer.isSending(), \"Relayer: stargate composer is not sending\");\n            }\n        }\n\n        fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyApproved {\n        if (_token == address(0)) {\n            uint total = address(this).balance;\n            require(_amount <= total, \"Relayer: not enough native fee for withdrawal\");\n            (bool sent, ) = payable(_to).call{ value: _amount }(\"\");\n            require(sent, \"Relayer: failed to send ether\");\n        } else {\n            uint total = IERC20(_token).balanceOf(address(this));\n            require(_amount <= total, \"Relayer: not enough fee for withdrawal\");\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{ gas: AIRDROP_GAS_LIMIT, value: msg.value }(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/RelayerV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2PriceData.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroPriceFeed.sol\";\n\n// RelayerV2Radar has an instance of RelayerV2.\n// It does not need to set prices.\n// it has view functions that use the internal RelayerV2 price data.\ncontract RelayerV2Radar is\n    ReentrancyGuard,\n    OwnableUpgradeable,\n    Proxied,\n    ILayerZeroRelayerV2,\n    ILayerZeroRelayerV2PriceData\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV2 public uln; // UltraLightNodeV2Radar\n    ILayerZeroRelayerV2PriceData public relayerV2;\n\n    address public stargateBridgeAddress;\n\n    //    struct DstPrice {\n    //        uint128 dstPriceRatio; // 10^10\n    //        uint128 dstGasPriceInWei;\n    //    }\n    //\n    //    struct DstConfig {\n    //        uint128 dstNativeAmtCap;\n    //        uint64 baseGas;\n    //        uint64 gasPerByte;\n    //    }\n\n    //    // [_chainId] => DstPriceData. change often\n    //    mapping(uint16 => RelayerV2.DstPrice) public dstPriceLookup;\n    //    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    //    mapping(uint16 => mapping(uint16 => RelayerV2.DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(\n        uint16 chainId,\n        uint16 outboundProofType,\n        uint128 dstNativeAmtCap,\n        uint64 baseGas,\n        uint64 gasPerByte\n    );\n\n    // new pauseable relayer\n    bool public paused;\n\n    // map of legacyChainid => v2 chainId. allows lookup thru to RelayerV2 contract (which is updated frequently)\n    mapping(uint16 => uint16) public legacyToV2ChainId; // legacy ChainId => v2 chainId\n\n    // Upgrade\n    ILayerZeroPriceFeed public priceFeed;\n    // all encoded param bytes except for proof for validateTransactionProofV1\n    uint128 public multiplierBps;\n    uint16 public validateProofBytes;\n    uint16 public fpBytes;\n    uint16 public mptOverhead; // average overhead for mpt\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    function initialize(address _ulnRadar, address _relayerV2, address _priceFeed) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_ulnRadar);\n        setApprovedAddress(address(this), true);\n\n        relayerV2 = ILayerZeroRelayerV2PriceData(_relayerV2);\n\n        legacyToV2ChainId[1] = 101; // ethereum\n        legacyToV2ChainId[2] = 102; // bsc\n        legacyToV2ChainId[12] = 112; // fantom\n\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function onUpgrade(address _priceFeed) public proxied {\n        multiplierBps = 12000;\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n        validateProofBytes = 164;\n        fpBytes = 160;\n        mptOverhead = 500;\n    }\n\n    function getV2ChainId(uint16 _legacyChainId) public view returns (uint16) {\n        require(legacyToV2ChainId[_legacyChainId] != 0, \"getLegacyChainId(): lookup not found\");\n        return legacyToV2ChainId[_legacyChainId];\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        //        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n        //        emit SetDstPrice(_chainId, _dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyApproved {\n        priceFeed = ILayerZeroPriceFeed(_priceFeed);\n    }\n\n    function setPriceMultiplierBps(uint128 _multiplierBps) external onlyApproved {\n        multiplierBps = _multiplierBps;\n    }\n\n    function setDstConfig(\n        uint16 _chainId,\n        uint16 _outboundProofType,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external onlyApproved {\n        //        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        //        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function dstPriceLookup(\n        uint16 _legacyChainId\n    ) public view override returns (ILayerZeroRelayerV2PriceData.DstPrice memory) {\n        return relayerV2.dstPriceLookup(getV2ChainId(_legacyChainId));\n    }\n\n    function dstConfigLookup(\n        uint16 _legacyChainId,\n        uint16 _outboundProofType\n    ) public view override returns (ILayerZeroRelayerV2PriceData.DstConfig memory) {\n        return relayerV2.dstConfigLookup(getV2ChainId(_legacyChainId), _outboundProofType);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address,\n        uint _payloadSize,\n        bytes memory _adapterParameters\n    ) internal view returns (uint) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _adapterParameters.length == 34 || _adapterParameters.length > 66,\n            \"Relayer: wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstConfig memory dstConfig = dstConfigLookup(_dstChainId, _outboundProofType);\n\n        uint dstNativeAmt = 0;\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n        }\n\n        // validateTransactionProof bytes = fixedBytes + proofBytes\n        // V2 has an extra 32 bytes for payable address\n        uint totalFixedBytes = txType == 2 ? uint(validateProofBytes).add(32) : validateProofBytes;\n        uint proofBytes = _outboundProofType == 2 ? fpBytes : _payloadSize.add(mptOverhead);\n        uint totalCallDataBytes = totalFixedBytes.add(proofBytes);\n\n        uint16 dstChainId = _dstChainId; // stack too deep\n        (uint fee, uint128 priceRatio) = priceFeed.estimateFeeByChain(\n            getV2ChainId(dstChainId),\n            totalCallDataBytes,\n            dstConfig.baseGas.add(extraGas)\n        );\n        uint airdropAmount = dstNativeAmt.mul(priceRatio).div(10 ** 10);\n        return fee.add(airdropAmount).mul(multiplierBps).div(10000);\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        return _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external override returns (uint) {\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        uint fee = _getPrices(_dstChainId, _outboundProofType, _userApplication, _payloadSize, _adapterParams);\n        emit AssignJob(fee);\n        return fee;\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function validateTransactionProofV2(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof,\n        address payable _to\n    ) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _blockHash,\n        bytes32 _data,\n        bytes calldata _transactionProof\n    ) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract Treasury is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV1 public immutable uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _uln) {\n        uln = ILayerZeroUltraLightNodeV1(_uln);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    //    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(0, address(0x0), _to, _amount);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/TreasuryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2 is ILayerZeroTreasury, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function withdrawToken(address _token, address _to, uint _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/TreasuryV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract TreasuryV2Radar is ILayerZeroTreasury, Ownable {\n    using SafeMath for uint;\n\n    uint public nativeBP;\n    uint public zroFee;\n    bool public feeEnabled;\n    bool public zroEnabled;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n\n    event NativeBP(uint bp);\n    event ZroFee(uint zroFee);\n    event FeeEnabled(bool feeEnabled);\n    event ZroEnabled(bool zroEnabled);\n\n    constructor(address _ulnv2) {\n        uln = ILayerZeroUltraLightNodeV2(_ulnv2);\n    }\n\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view override returns (uint) {\n        if (feeEnabled) {\n            if (payInZro) {\n                require(zroEnabled, \"LayerZero: ZRO is not enabled\");\n                return zroFee;\n            } else {\n                return relayerFee.add(oracleFee).mul(nativeBP).div(10000);\n            }\n        }\n        return 0;\n    }\n\n    function setFeeEnabled(bool _feeEnabled) external onlyOwner {\n        feeEnabled = _feeEnabled;\n        emit FeeEnabled(_feeEnabled);\n    }\n\n    function setZroEnabled(bool _zroEnabled) external onlyOwner {\n        zroEnabled = _zroEnabled;\n        emit ZroEnabled(_zroEnabled);\n    }\n\n    function setNativeBP(uint _nativeBP) external onlyOwner {\n        nativeBP = _nativeBP;\n        emit NativeBP(_nativeBP);\n    }\n\n    function setZroFee(uint _zroFee) external onlyOwner {\n        zroFee = _zroFee;\n        emit ZroFee(_zroFee);\n    }\n\n    function withdrawZROFromULN(address _to, uint _amount) external onlyOwner {\n        uln.withdrawZRO(_to, _amount);\n    }\n\n    function withdrawNativeFromULN(address payable _to, uint _amount) external onlyOwner {\n        uln.withdrawNative(_to, _amount);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/UltraLightNode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroRelayer.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroOracle.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\ncontract UltraLightNode is ILayerZeroMessagingLibrary, ILayerZeroUltraLightNodeV1, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    // Fee management\n    uint public constant BP_DENOMINATOR = 10000;\n    // treasury and relayer share the protocol fee, either in native token or ZRO\n    uint8 public constant WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES = 0;\n    uint8 public constant WITHDRAW_TYPE_ORACLE_QUOTED_FEES = 1; // quoted fee refers to the fee in block relaying\n    uint8 public constant WITHDRAW_TYPE_RELAYER_QUOTED_FEES = 2; //quoted fee refers the fee in msg relaying\n\n    mapping(address => uint) public oracleQuotedFees;\n    mapping(address => uint) public relayerQuotedFees;\n    uint public treasuryNativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => BlockData))) public hashLookup;\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n\n    // Events\n    event AppConfigUpdated(address userApplication, uint configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 chainId, uint16 proofType);\n    event HashReceived(uint16 srcChainId, address oracle, uint confirmations, bytes32 blockhash);\n    event Packet(uint16 chainId, bytes payload);\n    event RelayerParams(uint16 chainId, uint64 nonce, uint16 outboundProofType, bytes adapterParams);\n    event SetChainAddressSize(uint16 chainId, uint size);\n    event SetDefaultConfigForChainId(\n        uint16 chainId,\n        uint16 inboundProofLib,\n        uint64 inboundBlockConfirm,\n        address relayer,\n        uint16 outboundProofType,\n        uint16 outboundBlockConfirm,\n        address oracle\n    );\n    event SetDefaultAdapterParamsForChainId(uint16 chainId, uint16 proofType, bytes adapterParams);\n    event SetLayerZeroToken(address tokenAddress);\n    event SetRelayerFeeContract(address relayerFeeContract);\n    event SetRemoteUln(uint16 chainId, bytes32 uln);\n    event SetTreasury(address treasuryAddress);\n    event WithdrawZRO(address _msgSender, address _to, uint _amount);\n    event WithdrawNative(uint8 _type, address _owner, address _msgSender, address _to, uint _amount);\n\n    constructor(address _endpoint) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n\n    // This function completes delivery of a LayerZero message.\n    //\n    // In order to deliver the message, this function:\n    // (a) takes the _transactionProof submitted by UA's relayer, and\n    // (b) retrieve UA's validation library\n    // (c) takes the _blockData submitted by the UA's oracle given the their configuration (and blockConfirmations),\n    // (d) decodes using UA's validation library using (a) and (c)\n    //  then, this functions asserts that\n    // (e) the payload originated from the known Ultra Light Node from source chain, and\n    // (f) the _dstAddress the specified destination contract\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = getAppConfig(_srcChainId, _dstAddress);\n\n        // (a) assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        {\n            // (b) retrieve UA's validation library\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n\n            // (c) assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            BlockData storage blockData = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash];\n            require(\n                blockData.confirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // (d) decode\n            uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                blockData.data,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // (e) assert that the packet was emitted by the source ultra light node\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress, \"LayerZero: _packet.ulnAddress is invalid\");\n\n        // (f) assert that the _packet._dstAddress == the _dstAddress specified by the UAs message\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dst address\");\n\n        // publish the payload and _gasLimit to the endpoint for calling lzReceive at _dstAddress\n        endpoint.receivePayload(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            _gasLimit,\n            _packet.payload\n        );\n    }\n\n    // Called (by the Endpoint) with the information required to send a LayerZero message for a User Application.\n    // This function:\n    // (a) pays the protocol (native token or ZRO), oracle (native token) and relayer (native token) for their roles in sending the message.\n    // (b) generates the message payload and emits events of the message and adapterParams\n    // (c) notifies the oracle\n    function send(\n        address _ua,\n        uint64 _nonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        ApplicationConfiguration memory uaConfig = getAppConfig(_chainId, _ua);\n        address ua = _ua;\n        uint64 nonce = _nonce;\n        uint16 chainId = _chainId;\n        require(ulnLookup[chainId] != bytes32(0), \"LayerZero: chainId does not exist\");\n\n        uint totalNativeFee;\n        {\n            uint oracleFee;\n            // (a - 1), pay the oracle\n            {\n                oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n                oracleQuotedFees[uaConfig.oracle] = oracleQuotedFees[uaConfig.oracle].add(oracleFee);\n            }\n\n            // (a - 2), pay the relayer\n            {\n                uint payloadSize = _payload.length;\n                ILayerZeroRelayer relayer = ILayerZeroRelayer(uaConfig.relayer);\n                if (_adapterParams.length == 0) {\n                    bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                    totalNativeFee = relayer.getPrice(\n                        chainId,\n                        uaConfig.outboundProofType,\n                        ua,\n                        payloadSize,\n                        defaultAdaptorParam\n                    );\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, defaultAdaptorParam);\n                } else {\n                    totalNativeFee = relayer.getPrice(\n                        chainId,\n                        uaConfig.outboundProofType,\n                        ua,\n                        payloadSize,\n                        _adapterParams\n                    );\n                    relayer.notifyRelayer(chainId, uaConfig.outboundProofType, _adapterParams);\n                }\n                relayerQuotedFees[uaConfig.relayer] = relayerQuotedFees[uaConfig.relayer].add(totalNativeFee); // totalNativeFee == relayerFee here\n\n                // emit the param events\n                emit RelayerParams(chainId, nonce, uaConfig.outboundProofType, _adapterParams);\n            }\n\n            // (a - 3), pay the protocol\n            {\n                // if no ZRO token or not specifying a payment address, pay in native token\n                bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n                uint protocolFee = treasuryContract.getFees(!payInNative, totalNativeFee, oracleFee); // totalNativeFee == relayerFee here\n\n                if (protocolFee > 0) {\n                    if (payInNative) {\n                        treasuryNativeFees = treasuryNativeFees.add(protocolFee);\n                        totalNativeFee = totalNativeFee.add(protocolFee);\n                    } else {\n                        // zro payment address must equal the _ua or the tx.origin otherwise the transaction reverts\n                        require(\n                            _zroPaymentAddress == ua || _zroPaymentAddress == tx.origin,\n                            \"LayerZero: must be paid by sender or origin\"\n                        );\n\n                        // transfer the LayerZero token to this contract from the payee\n                        layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                        treasuryZROFees = treasuryZROFees.add(protocolFee);\n                    }\n                }\n            }\n\n            totalNativeFee = totalNativeFee.add(oracleFee);\n        }\n\n        // (b) emit payload and the adapterParams if any\n        {\n            bytes memory encodedPayload = abi.encodePacked(nonce, ua, _destination, _payload);\n            emit Packet(chainId, encodedPayload);\n            // (c) notify the oracle\n            ILayerZeroOracle(uaConfig.oracle).notifyOracle(\n                chainId,\n                uaConfig.outboundProofType,\n                uaConfig.outboundBlockConfirmations\n            );\n        }\n\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external override {\n        // this function may revert with a default message if the oracle address is not an ILayerZeroOracle\n        BlockData storage bd = hashLookup[msg.sender][_srcChainId][_lookupHash];\n        // if it has a record, requires a larger confirmation.\n        require(\n            bd.confirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        bd.confirmations = _confirmations;\n        bd.data = _data;\n\n        emit HashReceived(_srcChainId, msg.sender, _confirmations, _lookupHash);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) public view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[userApplicationAddress][_chainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_chainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 chainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][chainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[chainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[chainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _chainId,\n        address userApplicationAddress,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[userApplicationAddress][_chainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_chainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_chainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _chainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        uint16 chainId = _chainId;\n        address ua = _ua;\n        uint payloadSize = _payload.length;\n        bytes memory adapterParam = _adapterParams;\n\n        ApplicationConfiguration memory uaConfig = getAppConfig(chainId, ua);\n\n        // Relayer Fee\n        uint relayerFee;\n        {\n            if (adapterParam.length == 0) {\n                bytes memory defaultAdaptorParam = defaultAdapterParams[chainId][uaConfig.outboundProofType];\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(\n                    chainId,\n                    uaConfig.outboundProofType,\n                    ua,\n                    payloadSize,\n                    defaultAdaptorParam\n                );\n            } else {\n                relayerFee = ILayerZeroRelayer(uaConfig.relayer).getPrice(\n                    chainId,\n                    uaConfig.outboundProofType,\n                    ua,\n                    payloadSize,\n                    adapterParam\n                );\n            }\n        }\n\n        // Oracle Fee\n        uint oracleFee = ILayerZeroOracle(uaConfig.oracle).getPrice(chainId, uaConfig.outboundProofType);\n\n        // LayerZero Fee\n        {\n            uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n            _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n        }\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    // safemath overflow if the amount is not enough\n    function withdrawNative(\n        uint8 _type,\n        address _owner,\n        address payable _to,\n        uint _amount\n    ) external override nonReentrant {\n        if (_type == WITHDRAW_TYPE_TREASURY_PROTOCOL_FEES) {\n            require(msg.sender == address(treasuryContract), \"LayerZero:only treasury\");\n            treasuryNativeFees = treasuryNativeFees.sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_ORACLE_QUOTED_FEES) {\n            oracleQuotedFees[msg.sender] = oracleQuotedFees[msg.sender].sub(_amount);\n        } else if (_type == WITHDRAW_TYPE_RELAYER_QUOTED_FEES) {\n            relayerQuotedFees[msg.sender] = relayerQuotedFees[msg.sender].sub(_amount);\n        } else {\n            revert(\"LayerZero: unsupported withdraw type\");\n        }\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(_type, _owner, msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        require(maxInboundProofLibrary[_chainId] < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId]++;\n        inboundProofLibrary[_chainId][maxInboundProofLibrary[_chainId]] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint16 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData) {\n        return hashLookup[_oracle][_remoteChainId][_lookupHash];\n    }\n\n    function oracleQuotedAmount(address _oracle) external view override returns (uint) {\n        return oracleQuotedFees[_oracle];\n    }\n\n    function relayerQuotedAmount(address _relayer) external view override returns (uint) {\n        return relayerQuotedFees[_relayer];\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/UltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2 is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/UltraLightNodeV2AltToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./FeeHandler.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2AltToken is\n    ILayerZeroMessagingLibraryV2,\n    ILayerZeroUltraLightNodeV2,\n    ReentrancyGuard,\n    Ownable\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n    FeeHandler public immutable feeHandler;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _feeHandler) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n        feeHandler = FeeHandler(_feeHandler);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint[] memory fees = new uint[](3);\n        fees[0] = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        fees[1] = _handleOracle(dstChainId, uaConfig, ua);\n        fees[2] = _handleProtocolFee(fees[0], fees[1], ua, _zroPaymentAddress);\n\n        address[] memory receivers = new address[](3);\n        receivers[0] = uaConfig.relayer;\n        receivers[1] = uaConfig.oracle;\n        receivers[2] = address(treasuryContract);\n\n        feeHandler.creditFee(receivers, fees, _refundAddress);\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/UltraLightNodeV2Radar.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroTreasury.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n// v2\nimport \"./interfaces/ILayerZeroMessagingLibraryV2.sol\";\nimport \"./interfaces/ILayerZeroOracleV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./NonceContractRadar.sol\";\n\ncontract UltraLightNodeV2Radar is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address => uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address => mapping(uint16 => ApplicationConfiguration)) public appConfig; // app address => chainId => config\n    mapping(uint16 => ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 => mapping(uint16 => bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 => mapping(uint16 => address)) public inboundProofLibrary; // chainId => library Id => inboundProofLibrary contract\n    mapping(uint16 => uint16) public maxInboundProofLibrary; // chainId => inboundProofLibrary\n    mapping(uint16 => mapping(uint16 => bool)) public supportedOutboundProof; // chainId => outboundProofType => enabled\n    mapping(uint16 => uint) public chainAddressSizeMap;\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n    mapping(uint16 => bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContractRadar public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId, address _dappRadar) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContractRadar(_nonceContract);\n\n        // dappRadar\n        dappRadar = _dappRadar;\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    // Manual for DappRadar handling. This contract is dappRadar-only (send/receive)\n    // 1. Layerzero deploys UltraLightNodeV2Radar and NonceContractRadar using old chain ID with the local dappRadar address in constructor\n    // 2. Dapp Radar sets the messaging library to UltraLightNodeV2Radar\n    // 3. Dapp Radar sets the trustedRemote to the full path\n    // 4. Layerzero initializes the outboundNonce (1 call) and inboundNonce (batch call)\n    // 5. Test message flows\n    //\n    // 6. after an agree-upon period of time, decommission this contract (one-way trip).\n\n    //\n    // DappRadar constructs\n    //\n    address public immutable dappRadar;\n    bool public decommissioned;\n    mapping(uint16 => bool) public outboundNonceSet;\n    mapping(address => uint64) public inboundNonceCap;\n\n    // only dappRadar\n    function initRadarOutboundNonce(uint16 _dstChainId, address _dstRadarAddress) external onlyOwner {\n        // can only inherit the outbound nonce from previous path once\n        // assuming dappRadar has only 1 remote peer at a destination chain.\n        require(!outboundNonceSet[_dstChainId], \"LayerZero: dappRadar nonce already set\");\n        uint64 inheritedNonce = endpoint.getOutboundNonce(_dstChainId, dappRadar);\n        outboundNonceSet[_dstChainId] = true;\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_dstRadarAddress, dappRadar); //// remote + local\n\n        // insert into the nonce contract\n        nonceContract.initRadarOutboundNonce(_dstChainId, radarPath, inheritedNonce);\n    }\n\n    // generate a message from the new dappRadar-owned path with now payload\n    // dappRadar needs to first change the trustedRemote\n    // messages will fail locally in the nonBlockingLzApp from the nonce checking\n    // can only increment the nonce till we hit the legacy nonce\n    function incrementRadarInboundNonce(\n        uint16 _srcChainId,\n        address _srcRadarAddress,\n        uint _gasLimitPerCall,\n        uint _steps\n    ) external onlyOwner {\n        // initialize the inboundNonceCap, only once\n        if (inboundNonceCap[_srcRadarAddress] == 0) {\n            // check if the _srcRadarAddress is a legacy address by checking the nonce\n            uint64 inheritNonce = endpoint.getInboundNonce(_srcChainId, abi.encodePacked(_srcRadarAddress));\n            require(inheritNonce > 0, \"LayerZero: not legacy radar address\");\n\n            inboundNonceCap[_srcRadarAddress] = inheritNonce;\n        }\n\n        // can only set the path owned by the dappRadar\n        // dappRadar is only deployed on EVM chains so the address is 20 bytes for all\n        bytes memory radarPath = abi.encodePacked(_srcRadarAddress, dappRadar); // remote + local\n        uint64 radarPathNonce = endpoint.getInboundNonce(_srcChainId, radarPath);\n        uint64 nonceCap = inboundNonceCap[_srcRadarAddress];\n\n        for (uint i = 0; i < _steps; i++) {\n            // ensure that the nonce of the new path is not already at the cap\n            radarPathNonce++;\n            if (radarPathNonce > nonceCap) {\n                break;\n            }\n            // receive the message with null Payload\n            endpoint.receivePayload(_srcChainId, radarPath, dappRadar, radarPathNonce, _gasLimitPerCall, bytes(\"\"));\n        }\n    }\n\n    // this contract will only serve for a period of time\n    function decommission() external onlyOwner {\n        decommissioned = true;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        require(_dstAddress == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        // retrieve UA's configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA's relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA's oracle have no fewer confirmations than UA's configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(\n                storedConfirmations > 0 && storedConfirmations >= uaConfig.inboundBlockConfirmations,\n                \"LayerZero: not enough block confirmations\"\n            );\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(\n                _blockData,\n                _transactionProof,\n                remoteAddressSize\n            );\n        }\n\n        // packet content assertion\n        require(\n            ulnLookup[_srcChainId] == _packet.ulnAddress && _packet.ulnAddress != bytes32(0),\n            \"LayerZero: invalid _packet.ulnAddress\"\n        );\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(\n                _packet.srcChainId,\n                _packet.srcAddress,\n                _packet.dstAddress,\n                _packet.nonce,\n                keccak256(_packet.payload)\n            );\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(\n            _packet.srcChainId,\n            _packet.srcAddress,\n            _packet.dstAddress,\n            _packet.nonce,\n            keccak256(_packet.payload)\n        );\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(\n        address _ua,\n        uint64,\n        uint16 _dstChainId,\n        bytes calldata _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable override onlyEndpoint {\n        require(_ua == dappRadar, \"LayerZero: only dappRadar\");\n        require(!decommissioned, \"LayerZero: decommissioned\");\n\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving 'Stack Too Deep'\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(\n                chainAddressSize != 0 && _path.length == 20 + chainAddressSize,\n                \"LayerZero: incorrect remote address size\"\n            );\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee <= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua,\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(\n        uint16 _dstChainId,\n        ApplicationConfiguration memory _uaConfig,\n        address _ua\n    ) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(\n            _dstChainId,\n            _uaConfig.outboundProofType,\n            _uaConfig.outboundBlockConfirmations,\n            _ua\n        );\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(\n        uint _relayerFee,\n        uint _oracleFee,\n        address _ua,\n        address _zroPaymentAddress\n    ) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee > 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(\n                    _zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin,\n                    \"LayerZero: must be paid by sender or origin\"\n                );\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(\n            storedConfirmations < _confirmations,\n            \"LayerZero: oracle data can only update if it has more confirmations\"\n        );\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _ua\n    ) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(\n                inboundProofLibraryVersion <= maxInboundProofLibrary[_remoteChainId],\n                \"LayerZero: invalid inbound proof library version\"\n            );\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(\n                supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0,\n                \"LayerZero: invalid outbound proof type\"\n            );\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(\n        uint16 _remoteChainId,\n        address _ua,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(\n        uint16 _dstChainId,\n        address _ua,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length > 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            _ua,\n            _payload.length,\n            adapterParams\n        );\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(\n            _dstChainId,\n            uaConfig.outboundProofType,\n            uaConfig.outboundBlockConfirmations,\n            ua\n        );\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId < 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(\n        uint16 _chainId,\n        uint16 _inboundProofLibraryVersion,\n        uint64 _inboundBlockConfirmations,\n        address _relayer,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations,\n        address _oracle\n    ) external onlyOwner {\n        require(\n            _inboundProofLibraryVersion <= maxInboundProofLibrary[_chainId] && _inboundProofLibraryVersion > 0,\n            \"LayerZero: invalid inbound proof library version\"\n        );\n        require(_inboundBlockConfirmations > 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations > 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n        emit SetDefaultConfigForChainId(\n            _chainId,\n            _inboundProofLibraryVersion,\n            _inboundBlockConfirmations,\n            _relayer,\n            _outboundProofType,\n            _outboundBlockConfirmations,\n            _oracle\n        );\n    }\n\n    function setDefaultAdapterParamsForChainId(\n        uint16 _chainId,\n        uint16 _proofType,\n        bytes calldata _adapterParams\n    ) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/arbitrum/interfaces/ArbSys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns (uint);\n\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint);\n\n    /**\n     * @notice Send a transaction to L1\n     * @param destination recipient address on L1\n     * @param calldataForL1 (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint);\n\n    /**\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n     * @param account target account\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n     */\n    function getTransactionCount(address account) external view returns (uint256);\n\n    /**\n     * @notice get the value of target L2 storage slot\n     * This function is only callable from address 0 to prevent contracts from being able to call it\n     * @param account target account\n     * @param index target index of storage slot\n     * @return stotage value for the given account at the given index\n     */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n     * @notice check if current call is coming from l1\n     * @return true if the caller of this was called directly from L1\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external view returns (uint);\n\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint indexed uniqueId,\n        uint indexed batchNumber,\n        uint indexInBatch,\n        uint arbBlockNum,\n        uint ethBlockNum,\n        uint timestamp,\n        uint callvalue,\n        bytes data\n    );\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/example/AltTokenUA.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\n\n// An example UA running on Shrapnel using ERC20 as payment token\n// To demonstrate how feeToken payment needs to be atomic with layerzero send\ncontract AltTokenUA is ILayerZeroReceiver {\n    ILayerZeroEndpoint public endpoint;\n    IERC20 public feeToken;\n    address public feeHandler;\n\n    constructor(address _endpoint, address _feeToken, address _feeHandler) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        feeToken = IERC20(_feeToken);\n        feeHandler = _feeHandler;\n    }\n\n    function send(\n        uint16 _dstChainId,\n        address _dstAddress,\n        bytes memory _payload,\n        bytes memory _adapterParams,\n        uint _fee\n    ) public payable {\n        feeToken.transferFrom(msg.sender, feeHandler, _fee);\n\n        bytes memory path = abi.encodePacked(_dstAddress, address(this));\n        endpoint.send(_dstChainId, path, _payload, msg.sender, address(0), _adapterParams);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external virtual override {\n        //do nothing\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/IContractOne.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface IContractOne {\n    function setIt(uint x) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(\n        address _userApplication,\n        uint64 _lastNonce,\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(\n        uint16 _chainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibraryV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\nimport \"./ILayerZeroMessagingLibrary.sol\";\n\ninterface ILayerZeroMessagingLibraryV2 is ILayerZeroMessagingLibrary {\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracle {\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    function getPrice(uint16 _dstChainId, uint16 _outboundProofType) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmations the number of source chain block confirmation needed\n    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroOracleV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroOracleV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address _userApplication\n    ) external returns (uint price);\n\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address _userApplication\n    ) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroPriceFeed {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 10, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^10 = 10 ^ 20.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint16 chainId;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint16 chainId;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    function getPrice(uint16 _dstChainId) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByChain(\n        uint16 _dstChainId,\n        uint _callDataSize,\n        uint _gas\n    ) external view returns (uint fee, uint128 priceRatio);\n\n    function nativeTokenPriceUSD() external view returns (uint128);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroPriceFeedV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\n// copy of \"@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol\"\ninterface ILayerZeroPriceFeedV2 {\n    /**\n     * @dev\n     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR\n     */\n\n    struct Price {\n        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.\n        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.\n        uint32 gasPerByte;\n    }\n\n    struct UpdatePrice {\n        uint32 eid;\n        Price price;\n    }\n\n    /**\n     * @dev\n     *    ArbGasInfo.go:GetPricesInArbGas\n     *\n     */\n    struct ArbitrumPriceExt {\n        uint64 gasPerL2Tx; // L2 overhead\n        uint32 gasPerL1CallDataByte;\n    }\n\n    struct UpdatePriceExt {\n        uint32 eid;\n        Price price;\n        ArbitrumPriceExt extend;\n    }\n\n    function getPrice(uint32 _dstEid) external view returns (Price memory);\n\n    function getPriceRatioDenominator() external view returns (uint128);\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) external view returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayer {\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getPrice(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view returns (uint price);\n\n    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify the data to be relayed\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function notifyRelayer(uint16 _dstChainId, uint16 _outboundProofType, bytes calldata _adapterParams) external;\n\n    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.\n    // @param _address - the address to be checked\n    function isApproved(address _address) external view returns (bool approved);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroRelayerV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroRelayerV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external returns (uint price);\n\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        address _userApplication,\n        uint _payloadSize,\n        bytes calldata _adapterParams\n    ) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroRelayerV2PriceData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\npragma abicoder v2;\n\ninterface ILayerZeroRelayerV2PriceData {\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    function dstPriceLookup(uint16 _chainId) external view returns (DstPrice memory);\n\n    function dstConfigLookup(uint16 _chainId, uint16 _outboundProofType) external view returns (DstConfig memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroTreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroTreasury {\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view returns (uint);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\n\ninterface ILayerZeroUltraLightNodeV1 {\n    // a Relayer can execute the validateTransactionProof()\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes calldata _transactionProof\n    ) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _remoteChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _data) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(uint8 _type, address _owner, address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function oracleQuotedAmount(address _oracle) external view returns (uint);\n\n    function relayerQuotedAmount(address _relayer) external view returns (uint);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroUltraLightNodeV2 {\n    // Relayer functions\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function accruedNativeFee(address _address) external view returns (uint);\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    event HashReceived(\n        uint16 indexed srcChainId,\n        address indexed oracle,\n        bytes32 lookupHash,\n        bytes32 blockData,\n        uint confirmations\n    );\n    event RelayerParams(bytes adapterParams, uint16 outboundProofType);\n    event Packet(bytes payload);\n    event InvalidDst(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event PacketReceived(\n        uint16 indexed srcChainId,\n        bytes srcAddress,\n        address indexed dstAddress,\n        uint64 nonce,\n        bytes32 payloadHash\n    );\n    event AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n    event SetChainAddressSize(uint16 indexed chainId, uint size);\n    event SetDefaultConfigForChainId(\n        uint16 indexed chainId,\n        uint16 inboundProofLib,\n        uint64 inboundBlockConfirm,\n        address relayer,\n        uint16 outboundProofType,\n        uint64 outboundBlockConfirm,\n        address oracle\n    );\n    event SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n    event SetLayerZeroToken(address indexed tokenAddress);\n    event SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n    event SetTreasury(address indexed treasuryAddress);\n    event WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n    event WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroValidationLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface ILayerZeroValidationLibrary {\n    function validateProof(\n        bytes32 blockData,\n        bytes calldata _data,\n        uint _remoteAddressSize\n    ) external returns (LayerZeroPacket.Packet memory packet);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/IValidationLibraryHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\nimport \"./ILayerZeroValidationLibrary.sol\";\n\ninterface IValidationLibraryHelper {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory);\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/IValidationLibraryHelperV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../proof/utility/LayerZeroPacket.sol\";\n\ninterface IValidationLibraryHelperV2 {\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] calldata receiptSlotIndex,\n        uint logIndex,\n        bytes[] calldata proof\n    ) external pure returns (ULNLog memory);\n\n    function getPacket(\n        bytes calldata data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory);\n\n    function getUtilsVersion() external view returns (uint8);\n\n    function getProofType() external view returns (uint8);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/libs/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Copyright 2023 LayerZero Labs Ltd.\n// You may obtain a copy of the License at\n// https://github.com/LayerZero-Labs/license/blob/main/LICENSE-LZBL-1.1\n\npragma solidity ^0.7.6;\n\nlibrary RateLimiter {\n    struct Info {\n        // capacity of the token bucket. This is the maximum number of tokens that the bucket can hold at any given time\n        uint64 capacity;\n        // current number of tokens in the bucket\n        uint64 tokens;\n        // number of tokens refilled per second\n        uint64 rate;\n        // timestamp of last refill\n        uint64 lastRefillTime;\n    }\n\n    function setCapacity(Info storage _self, uint64 _capacity) internal {\n        _self.capacity = _capacity;\n        _self.tokens = _capacity;\n        _self.lastRefillTime = uint64(block.timestamp);\n    }\n\n    function setRate(Info storage _self, uint64 _rate) internal {\n        refill(_self, 0);\n        _self.rate = _rate;\n    }\n\n    function tryConsume(Info storage _self, uint64 _amount) internal returns (uint64) {\n        refill(_self, 0);\n\n        uint64 tokens = _self.tokens;\n        require(tokens >= _amount, \"RelayerV2: out of counters - try again later!\");\n\n        uint64 newTokens = tokens - _amount;\n        _self.tokens = newTokens;\n        return newTokens;\n    }\n\n    function refill(Info storage _self, uint64 _extraTokens) internal {\n        uint newTokens = _extraTokens;\n\n        uint64 currentTime = uint64(block.timestamp);\n        if (currentTime > _self.lastRefillTime) {\n            uint timeElapsedInSeconds = currentTime - _self.lastRefillTime;\n            newTokens += timeElapsedInSeconds * _self.rate;\n        }\n\n        if (newTokens > 0) {\n            newTokens += _self.tokens;\n            _self.tokens = newTokens > _self.capacity ? _self.capacity : uint64(newTokens);\n        }\n\n        _self.lastRefillTime = currentTime;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/ContractOne.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\ncontract ContractOne {\n    uint x;\n\n    function setIt(uint _x) external {\n        x = _x;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/ContractTwo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IContractOne.sol\";\n\ncontract ContractTwo {\n    address contractOne;\n\n    constructor(address _contractOne) {\n        contractOne = _contractOne;\n    }\n\n    function callSetIt(uint _gasLimit) external {\n        IContractOne(contractOne).setIt{gas: _gasLimit}(1);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/GIN.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\ncontract GIN is ILayerZeroReceiver {\n    bool public messageComplete;\n    ILayerZeroEndpoint public endpoint;\n\n    event Message(bytes32 indexed message);\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16, bytes memory /*_fromAddress*/, uint64, bytes memory _payload) external override {\n        require(msg.sender == address(endpoint));\n        bytes32 message;\n        assembly {\n            message := mload(add(_payload, 32))\n        }\n        emit Message(message);\n        messageComplete = true;\n    }\n\n    function sendFirstMessage(\n        uint gasAmountForDst,\n        uint16[] calldata chainIds,\n        bytes[] calldata dstAddresses\n    ) external payable {\n        require(!messageComplete, \"The first message of LayerZero has already been sent\");\n        uint16 version = 1;\n        bytes memory _relayerParams = abi.encodePacked(version, gasAmountForDst);\n\n        bytes32 message = \"GIN\";\n        bytes memory messageString = bytes(abi.encodePacked(message));\n        uint length = chainIds.length;\n        uint fee = msg.value / length;\n        for (uint i = 0; i < length; i++) {\n            endpoint.send{value: fee}(\n                chainIds[i],\n                dstAddresses[i],\n                messageString,\n                msg.sender,\n                address(0x0),\n                _relayerParams\n            );\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\ncontract IsContract {\n    function isAddressContract(address addr) external view returns (bool) {\n        // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n        // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/LayerZeroOracleBadMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n// mock is designed to try and send the msg it just received again to trigger a revert\ncontract LayerZeroOracleBadMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n    ILayerZeroEndpoint public endpoint; // for bad oracles trying to talk to endpoint\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations\n    ) external override {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // owner can set uln\n    function setEndpoint(address endpointAddress) external onlyOwner {\n        endpoint = ILayerZeroEndpoint(endpointAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    // mocked for now\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 /*_outboundProofType*/,\n        uint64 /*_outboundBlockConfirmation*/,\n        address\n    ) external returns (uint price) {\n        // oracle is set to do bad things and try to call send again, this should revert\n        endpoint.send(_dstChainId, \"0x\", \"0x\", address(0), address(0), \"0x\");\n        return 1;\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/LayerZeroOracleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracle.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV1.sol\";\n\ncontract LayerZeroOracleMock is ILayerZeroOracle, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    uint public fee;\n    ILayerZeroUltraLightNodeV1 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    function notifyOracle(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmations\n    ) external override {\n        emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function withdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    // owner can set uln\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV1(ulnAddress);\n    }\n\n    // mock, doesnt do anything\n    function setJob(uint16 _chain, address _oracle, bytes32 _id, uint _fee) public onlyOwner {}\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view override returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function getPrice(uint16 _destinationChainId, uint16 _outboundProofType) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_destinationChainId];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/LayerZeroOracleMockV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroOracleV2.sol\";\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract LayerZeroOracleMockV2 is ILayerZeroOracleV2, Ownable, ReentrancyGuard {\n    mapping(address => bool) public approvedAddresses;\n    mapping(uint16 => mapping(uint16 => uint)) public chainPriceLookup;\n    mapping(uint16 => mapping(uint16 => uint64)) public jobs; // mocked, not used for anything yet\n    uint public fee;\n    ILayerZeroUltraLightNodeV2 public uln; // ultraLightNode instance\n\n    event OracleNotified(uint16 dstChainId, uint16 _outboundProofType, uint blockConfirmations);\n    event Withdraw(address to, uint amount);\n\n    constructor() {\n        approvedAddresses[msg.sender] = true;\n    }\n\n    // mocked for now, will auto accept the job, and return the price at the same time\n    function assignJob(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 _outboundBlockConfirmation,\n        address\n    ) external override returns (uint price) {\n        jobs[_dstChainId][_outboundProofType] = _outboundBlockConfirmation;\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function getFee(\n        uint16 _dstChainId,\n        uint16 _outboundProofType,\n        uint64 /*_outboundBlockConfirmation*/,\n        address\n    ) external view override returns (uint) {\n        return chainPriceLookup[_outboundProofType][_dstChainId];\n    }\n\n    function withdrawFee(address payable _to, uint _amount) public override onlyOwner nonReentrant {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"failed to withdraw\");\n        emit Withdraw(_to, _amount);\n    }\n\n    function updateHash(uint16 _remoteChainId, bytes32 _blockHash, uint _confirmations, bytes32 _data) external {\n        require(approvedAddresses[msg.sender], \"LayerZeroOracleMock: caller must be approved\");\n        uln.updateHash(_remoteChainId, _blockHash, _confirmations, _data);\n    }\n\n    function setUln(address ulnAddress) external onlyOwner {\n        uln = ILayerZeroUltraLightNodeV2(ulnAddress);\n    }\n\n    function setDeliveryAddress(uint16 _dstChainId, address _deliveryAddress) public onlyOwner {}\n\n    function setPrice(uint16 _destinationChainId, uint16 _outboundProofType, uint _price) external onlyOwner {\n        chainPriceLookup[_outboundProofType][_destinationChainId] = _price;\n    }\n\n    function setApprovedAddress(address _oracleAddress, bool _approve) external {\n        approvedAddresses[_oracleAddress] = _approve;\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/LayerZeroTokenMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract LayerZeroTokenMock is ERC20 {\n    constructor() ERC20(\"LayerZeroTokenMock\", \"LZTM\") {\n        _mint(msg.sender, 1_000_000 * 10 ** 18);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// this is a MOCK\ncontract MockToken is ERC20 {\n    // this is a MOCK\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _mint(msg.sender, 1000000000000000000000);\n    }\n\n    // this is a MOCK\n    function mint(address _to, uint _amount) public {\n        _mint(_to, _amount);\n    }\n\n    //Mocked to imitate what happens if a transfer fails\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        require(recipient != address(0x1));\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/OmniCounter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../Relayer.sol\";\n\ncontract OmniCounter is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint;\n\n    // keep track of how many messages have been received from other chains\n    uint public messageCounter;\n    mapping(address => uint) public remoteAddressCounter;\n    // required: the LayerZero endpoint which is passed in the constructor\n    ILayerZeroEndpoint public endpoint;\n    bool public payInZRO;\n\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function getCounter() public view returns (uint) {\n        return messageCounter;\n    }\n\n    // overrides lzReceive function in ILayerZeroReceiver.\n    // automatically invoked on the receiving chain after the source chain calls endpoint.send(...)\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external virtual override {\n        require(msg.sender == address(endpoint));\n        _verifySourceAddress(_srcChainId, _fromAddress);\n\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // used for testing reentrant, retry sending the payload through the relayer before the initial receive has been resolved\n        // ff == '0x6666' on the payload side\n        if (\n            keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes2(\"ff\")))) ||\n            keccak256(abi.encodePacked((_payload))) == keccak256(abi.encodePacked((bytes10(\"ff\"))))\n        ) {\n            endpoint.receivePayload(1, bytes(\"\"), address(0x0), 1, 1, bytes(\"\"));\n        }\n\n        remoteAddressCounter[fromAddress] += 1;\n        messageCounter += 1;\n    }\n\n    function incrementCounter(\n        uint16 _dstChainId,\n        bytes calldata _adapterParams,\n        bytes calldata payload\n    ) public payable {\n        address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n        _incrementCounter(_dstChainId, payload, msg.sender, zroPaymentAddress, _adapterParams);\n    }\n\n    // call send() to multiple destinations in the same transaction!\n    function multiIncrementCounter(\n        uint16[] calldata _dstChainIds,\n        bytes calldata _adapterParams,\n        bytes calldata payload\n    ) public payable {\n        // send() each chainId + dst address pair\n        uint16[] memory dstChainIds = _dstChainIds;\n        bytes memory adapterParams = _adapterParams;\n\n        uint _refund = msg.value;\n        // send() each chainId + dst address pair\n        for (uint i = 0; i < dstChainIds.length; ++i) {\n            (uint valueToSend, ) = endpoint.estimateFees(\n                dstChainIds[i],\n                address(this),\n                payload,\n                payInZRO,\n                adapterParams\n            );\n            _refund = _refund.sub(valueToSend);\n            // a Communicator.sol instance is the 'endpoint'\n            // .send() each payload to the destination chainId + UA destination address\n            address zroPaymentAddress = payInZRO ? address(this) : address(0x0);\n            _incrementCounter(_dstChainIds[i], payload, msg.sender, zroPaymentAddress, adapterParams);\n        }\n        // refund eth if too much was sent into this contract call\n        msg.sender.transfer(_refund);\n    }\n\n    function _incrementCounter(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) public payable {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length > 0, \"*** trustedRemote cant be 0x \");\n        endpoint.send{value: msg.value}(\n            _dstChainId,\n            trustedRemote,\n            _payload,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function setConfig(\n        uint16 /*_version*/,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override {\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), _chainId, _configType, _config);\n    }\n\n    function getConfig(uint16, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function setOutboundBlockConfirmations(uint16 dstChainId, uint64 confirmations) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 6;\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            dstChainId,\n            TYPE_OUTBOUND_BLOCK_CONFIRMATIONS,\n            abi.encodePacked(confirmations)\n        );\n    }\n\n    function getOutboundBlockConfirmations(uint16 remoteChainId) external view returns (bytes memory _confirmations) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), remoteChainId, address(this), 5);\n    }\n\n    // set the Oracle to be used by this UA for LayerZero messages\n    function setOracle(uint16 dstChainId, address oracle) external {\n        // should technically be onlyOwner but this is a mock\n        uint TYPE_ORACLE = 6; // from UltraLightNode\n        // set the Oracle\n        // uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_ORACLE, abi.encode(oracle));\n    }\n\n    // get the configured oracle\n    function getOracle(uint16 remoteChainId) external view returns (address _oracle) {\n        bytes memory bytesOracle = endpoint.getConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            address(this),\n            6\n        );\n        assembly {\n            _oracle := mload(add(bytesOracle, 32))\n        }\n    }\n\n    // set the Relayer to be used by this UA for LayerZero messages\n    function setRelayer(uint16 dstChainId, address relayer) external {\n        uint TYPE_RELAYER = 3;\n        endpoint.setConfig(endpoint.getSendVersion(address(this)), dstChainId, TYPE_RELAYER, abi.encode(relayer));\n    }\n\n    // set the inbound block confirmations\n    function setInboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            2, // CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    // set outbound block confirmations\n    function setOutboundConfirmations(uint16 remoteChainId, uint16 confirmations) external {\n        endpoint.setConfig(\n            endpoint.getSendVersion(address(this)),\n            remoteChainId,\n            5, // CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS\n            abi.encode(confirmations)\n        );\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // ignored for this contract\n    }\n\n    function setPayInZRO(bool _payInZRO) external onlyOwner {\n        payInZRO = _payInZRO;\n    }\n\n    function approveTokenSpender(address token, address spender, uint amount) external onlyOwner {\n        IERC20(token).approve(spender, amount);\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {\n        // Mock the ability to reject payments\n        require(\n            msg.value < 1000 && msg.value != 10,\n            \"Did you mean to send a blocked amount - check receive() / fallback()\"\n        );\n    }\n\n    // allow owner to set it multiple times.\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n    }\n\n    function _verifySourceAddress(uint16 _srcChainId, bytes memory _fromAddress) internal view {\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        require(\n            trustedRemote.length != 0 && keccak256(_fromAddress) == keccak256(trustedRemote),\n            \"source counter is not trusted\"\n        );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/PacketData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\ncontract PacketData {\n    event Packet(uint16 chainId, bytes payload);\n    event Packet(bytes payload);\n\n    function emitPacketV1(\n        uint64 nonce,\n        address ua,\n        uint16 dstChainId,\n        address dstAddress,\n        bytes calldata payload\n    ) public {\n        bytes memory encodedPayload = abi.encodePacked(nonce, ua, dstAddress, payload);\n        emit Packet(dstChainId, encodedPayload);\n    }\n\n    function emitPacketV2(\n        uint64 nonce,\n        uint16 localChainId,\n        address ua,\n        uint16 dstChainId,\n        address dstAddress,\n        bytes calldata payload\n    ) public {\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/PingPong.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n//\n// Note: you will need to fund each deployed contract with gas\n//\n// PingPong sends a LayerZero message back and forth between chains until stopped!\n//\n// Demonstrates:\n//  1. a recursive feature of calling send() from inside lzReceive()\n//  2. how to `estimateFees` for a send()'ing a LayerZero message\n//  3. the contract pays the message fee\n\npragma solidity ^0.7.6;\npragma abicoder v2;\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract PingPong is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    // the LayerZero endpoint calls .send() to send a cross chain message\n    ILayerZeroEndpoint public endpoint;\n    // whether PingPong is ping-ponging\n    bool public pingsEnabled;\n    // event emitted every ping() to keep track of consecutive pings count\n    event Ping(uint pings);\n    // the maxPings before ending the loop\n    uint public maxPings;\n    // keep track of the totalPings sent\n    uint public numPings;\n    bool public isUlnV2;\n\n    // constructor requires the LayerZero endpoint for this chain\n    constructor(address _layerZeroEndpoint, bool _isUlnV2) {\n        pingsEnabled = true;\n        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        maxPings = 5;\n        isUlnV2 = _isUlnV2;\n    }\n\n    // disable ping-ponging\n    function disable() external {\n        pingsEnabled = false;\n    }\n\n    // pings the destination chain, along with the current number of pings sent\n    function ping(\n        uint16 _dstChainId, // send a ping to this destination chainId\n        address _dstPingPongAddr, // destination address of PingPong contract\n        uint pings // the uint to start at. use 0 as a default\n    ) public {\n        require(address(this).balance > 0, \"the balance of this contract is 0. pls send gas for message fees\");\n        require(pingsEnabled, \"pingsEnabled is false. messages stopped\");\n        require(maxPings > pings, \"maxPings has been reached, no more looping\");\n\n        emit Ping(pings);\n\n        // abi.encode() the payload with the number of pings sent\n        bytes memory payload = abi.encode(pings);\n\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint gasForDestinationLzReceive = 350000;\n        bytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\n\n        // get the fees we need to pay to LayerZero + Relayer to cover message delivery\n        // see Communicator.sol's .estimateNativeFees() function for more details.\n        (uint messageFee, ) = endpoint.estimateFees(_dstChainId, address(this), payload, false, adapterParams);\n        require(\n            address(this).balance >= messageFee,\n            \"address(this).balance < messageFee. pls send gas for message fees\"\n        );\n\n        bytes memory path = isUlnV2\n            ? abi.encodePacked(_dstPingPongAddr, address(this))\n            : abi.encodePacked(_dstPingPongAddr);\n\n        // send LayerZero message\n        endpoint.send{value: messageFee}( // {value: messageFee} will be paid out of this contract!\n            _dstChainId, // destination chainId\n            path,\n            payload, // abi.encode()'ed bytes\n            payable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n            address(0x0), // 'zroPaymentAddress' unused for this mock/example\n            adapterParams // 'adapterParams' unused for this mock/example\n        );\n    }\n\n    // receive the bytes payload from the source chain via LayerZero\n    // _srcChainId: the chainId that we are receiving the message from.\n    // _fromAddress: the source PingPong address\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _fromAddress,\n        uint64 /*_nonce*/,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(endpoint)); // boilerplate! lzReceive must be called by the endpoint for security\n\n        // use assembly to extract the address from the bytes memory parameter\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_fromAddress, 20))\n        }\n\n        // decode the number of pings sent thus far\n        uint pings = abi.decode(_payload, (uint));\n\n        // \"recursively\" call ping in order to *pong*     (and increment pings)\n        ++pings;\n        numPings = pings;\n\n        ping(_srcChainId, fromAddress, pings);\n    }\n\n    function setConfig(\n        uint16 /*_version*/,\n        uint16 _dstChainId,\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        endpoint.setConfig(_dstChainId, endpoint.getSendVersion(address(this)), _configType, _config);\n    }\n\n    function getConfig(\n        uint16 /*_dstChainId*/,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(address(this)), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view returns (uint16) {\n        return endpoint.getSendVersion(address(this));\n    }\n\n    function getReceiveVersion() external view returns (uint16) {\n        return endpoint.getReceiveVersion(address(this));\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // do nth\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/PriceFeedV2Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/ILayerZeroPriceFeedV2.sol\";\n\n// copy of \"@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol\"\n// PriceFeed is updated based on v1 eids\n// v2 eids will fall to the convention of v1 eid + 30,000\ncontract PriceFeedV2Mock is ILayerZeroPriceFeedV2, OwnableUpgradeable {\n    uint128 internal PRICE_RATIO_DENOMINATOR;\n\n    // sets pricing\n    mapping(address => bool) public priceUpdater;\n\n    mapping(uint32 => Price) public defaultModelPrice;\n    ArbitrumPriceExt public arbitrumPriceExt;\n\n    uint128 public nativeTokenPriceUSD; // uses PRICE_RATIO_DENOMINATOR\n\n    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression\n    uint128 public ARBITRUM_COMPRESSION_PERCENT;\n\n    // ============================ Constructor ===================================\n\n    function initialize(address _priceUpdater) public initializer {\n        __Ownable_init();\n        priceUpdater[_priceUpdater] = true;\n        PRICE_RATIO_DENOMINATOR = 1e20;\n        ARBITRUM_COMPRESSION_PERCENT = 47;\n    }\n\n    // ============================ Modifier ======================================\n\n    // owner is always approved\n    modifier onlyPriceUpdater() {\n        if (owner() != msg.sender) {\n            require(priceUpdater[msg.sender], \"PriceFeed: not price updater\");\n        }\n        _;\n    }\n\n    // ============================ OnlyOwner =====================================\n\n    function setPriceUpdater(address _addr, bool _active) external onlyOwner {\n        priceUpdater[_addr] = _active;\n    }\n\n    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {\n        PRICE_RATIO_DENOMINATOR = _denominator;\n    }\n\n    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {\n        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;\n    }\n\n    // ============================ OnlyPriceUpdater =====================================\n\n    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {\n        for (uint i = 0; i < _price.length; i++) {\n            UpdatePrice calldata _update = _price[i];\n            _setPrice(_update.eid, _update.price);\n        }\n    }\n\n    function setPriceForArbitrum(UpdatePriceExt calldata _update) external onlyPriceUpdater {\n        _setPrice(_update.eid, _update.price);\n\n        uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;\n        uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;\n\n        arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;\n        arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;\n    }\n\n    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {\n        nativeTokenPriceUSD = _nativeTokenPriceUSD;\n    }\n\n    // ============================ Internal ==========================================\n    function _setPrice(uint32 _dstEid, Price memory _price) internal {\n        uint128 priceRatio = _price.priceRatio;\n        uint64 gasPriceInUnit = _price.gasPriceInUnit;\n        uint32 gasPerByte = _price.gasPerByte;\n        defaultModelPrice[_dstEid] = Price(priceRatio, gasPriceInUnit, gasPerByte);\n    }\n\n    function _getL1LookupId(uint32 _l2Eid) internal pure returns (uint32) {\n        uint32 l2Eid = _l2Eid % 30_000;\n        if (l2Eid == 111) {\n            return 101;\n        } else if (l2Eid == 10132) {\n            return 10121; // ethereum-goerli\n        } else if (l2Eid == 20132) {\n            return 20121; // ethereum-goerli\n        } else {\n            revert(\"PriceFeed: unknown l2 chain id\");\n        }\n    }\n\n    // ============================ View ==========================================\n\n    function getPrice(uint32 _dstEid) external view override returns (Price memory price) {\n        price = defaultModelPrice[_dstEid];\n    }\n\n    function getPriceRatioDenominator() external view override returns (uint128) {\n        return PRICE_RATIO_DENOMINATOR;\n    }\n\n    function estimateFeeByEid(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    )\n        external\n        view\n        override\n        returns (uint fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD)\n    {\n        uint32 dstEid = _dstEid % 30_000;\n        if (dstEid == 110 || dstEid == 10143 || dstEid == 20143) {\n            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);\n        } else if (dstEid == 111 || dstEid == 10132 || dstEid == 20132) {\n            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);\n        } else {\n            (fee, priceRatio) = _estimateFeeWithDefaultModel(dstEid, _callDataSize, _gas);\n        }\n        priceRatioDenominator = PRICE_RATIO_DENOMINATOR;\n        nativePriceUSD = nativeTokenPriceUSD;\n    }\n\n    function _estimateFeeWithDefaultModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        Price storage remotePrice = defaultModelPrice[_dstEid];\n\n        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas\n        uint gasForCallData = _callDataSize * remotePrice.gasPerByte;\n        uint remoteFee = (gasForCallData + _gas) * remotePrice.gasPriceInUnit;\n        return ((remoteFee * remotePrice.priceRatio) / PRICE_RATIO_DENOMINATOR, remotePrice.priceRatio);\n    }\n\n    function _estimateFeeWithOptimismModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        uint32 ethereumId = _getL1LookupId(_dstEid);\n\n        // L1 fee\n        Price storage ethereumPrice = defaultModelPrice[ethereumId];\n        uint gasForL1CallData = (_callDataSize * ethereumPrice.gasPerByte) + 3188; // 2100 + 68 * 16\n        uint l1Fee = gasForL1CallData * ethereumPrice.gasPriceInUnit;\n\n        // L2 fee\n        Price storage optimismPrice = defaultModelPrice[_dstEid];\n        uint gasForL2CallData = _callDataSize * optimismPrice.gasPerByte;\n        uint l2Fee = (gasForL2CallData + _gas) * optimismPrice.gasPriceInUnit;\n\n        uint l1FeeInSrcPrice = (l1Fee * ethereumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint l2FeeInSrcPrice = (l2Fee * optimismPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;\n        uint gasFee = l1FeeInSrcPrice + l2FeeInSrcPrice;\n        return (gasFee, optimismPrice.priceRatio);\n    }\n\n    function _estimateFeeWithArbitrumModel(\n        uint32 _dstEid,\n        uint _callDataSize,\n        uint _gas\n    ) internal view returns (uint fee, uint128 priceRatio) {\n        Price storage arbitrumPrice = defaultModelPrice[_dstEid];\n\n        // L1 fee\n        uint gasForL1CallData = ((_callDataSize * ARBITRUM_COMPRESSION_PERCENT) / 100) *\n            arbitrumPriceExt.gasPerL1CallDataByte;\n        // L2 Fee\n        uint gasForL2CallData = _callDataSize * arbitrumPrice.gasPerByte;\n        uint gasFee = (_gas + arbitrumPriceExt.gasPerL2Tx + gasForL1CallData + gasForL2CallData) *\n            arbitrumPrice.gasPriceInUnit;\n\n        return ((gasFee * arbitrumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR, arbitrumPrice.priceRatio);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/Token.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    event tried();\n    event caught();\n\n    constructor() ERC20(\"test\", \"test\") {\n        _mint(msg.sender, 10_000_000_000 * 10 ** 18);\n    }\n\n    function selfDestruct() public {\n        selfdestruct(address(0x0));\n    }\n\n    function tryCatch(address _tokenAddress) public {\n        try ERC20(_tokenAddress).totalSupply() {\n            emit tried();\n        } catch {\n            emit caught();\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/mocks/UltraLightNodeV2Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract UltraLightNodeV2Mock is ILayerZeroUltraLightNodeV2 {\n    event executed();\n    event paidTo(address _to, uint _amount);\n\n    mapping(address => mapping(uint16 => mapping(bytes32 => mapping(bytes32 => uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -> confirmation\n\n    constructor() {}\n\n    //Mock version of uln for testing the withdraw fee function. If we need to use this again we can expand on it.\n    // Relayer functions\n    function validateTransactionProof(\n        uint16 _srcChainId,\n        address _dstAddress,\n        uint _gasLimit,\n        bytes32 _lookupHash,\n        bytes32 _blockData,\n        bytes calldata _transactionProof\n    ) external override {\n        emit executed();\n    }\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(\n        uint16 _srcChainId,\n        bytes32 _lookupHash,\n        uint _confirmations,\n        bytes32 _blockData\n    ) external override {\n        emit executed();\n    }\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external override {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        emit paidTo(_to, _amount);\n    }\n\n    function withdrawZRO(address _to, uint _amount) external override {\n        emit executed();\n    }\n\n    // view functions\n    function getAppConfig(\n        uint16 _remoteChainId,\n        address _userApplicationAddress\n    ) external view override returns (ApplicationConfiguration memory) {}\n\n    function accruedNativeFee(address _address) external view override returns (uint) {}\n\n    receive() external payable {}\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/PreCrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrime.sol\";\nimport \"./PreCrimeBase.sol\";\n\nabstract contract PreCrime is PreCrimeBase, IPreCrime {\n    bytes4 private constant SIMULATE_REVERT_SELECTOR = bytes4(keccak256(\"SimulateRevert(uint16,bytes)\"));\n\n    /**\n     * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode\n     */\n    uint16 public constant PRECRIME_VERSION = 20001;\n\n    constructor(uint16 _localChainId) PreCrimeBase(_localChainId) {}\n\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return data the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external override returns (uint16 code, bytes memory data) {\n        // params check\n        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);\n        if (code != CODE_SUCCESS) {\n            return (code, data);\n        }\n\n        (bool success, bytes memory result) = address(this).call(\n            abi.encodeWithSelector(this._simulateAndRevert.selector, _packets)\n        );\n        require(!success, \"simulate should never return success\");\n\n        // parse code and data\n        (code, data) = _parseRevertResult(result);\n        if (code == CODE_SUCCESS) {\n            data = abi.encode(localChainId, data); // add localChainId to the header\n        }\n    }\n\n    function _parseRevertResult(bytes memory result) internal pure returns (uint16 code, bytes memory data) {\n        // check revert selector\n        bytes4 selector;\n        assembly {\n            selector := mload(add(result, 0x20)) // skip the length and get bytes4 selector\n        }\n        if (selector != SIMULATE_REVERT_SELECTOR) {\n            // bubble up the internal error\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n\n        // parse code and result\n        assembly {\n            // Slice the sighash. Remove the selector which is the first 4 bytes\n            result := add(result, 0x04)\n        }\n        return abi.decode(result, (uint16, bytes));\n    }\n\n    /**\n     * @dev internal function, no one should call\n     * @param _packets packets\n     */\n    function _simulateAndRevert(Packet[] calldata _packets) external virtual {\n        require(msg.sender == address(this));\n        (uint16 code, bytes memory simulation) = _simulate(_packets);\n        // equal to: revert SimulateRevert(code, result);\n        bytes memory revertData = abi.encodePacked(SIMULATE_REVERT_SELECTOR, abi.encode(code, simulation));\n        assembly {\n            revert(add(revertData, 32), mload(revertData))\n        }\n    }\n\n    /**\n     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.\n     * @param _packets packets\n     * @return code\n     * @return result\n     */\n    function _simulate(Packet[] calldata _packets) internal virtual returns (uint16 code, bytes memory result);\n\n    function version() external pure override returns (uint16) {\n        return PRECRIME_VERSION;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/PreCrimeBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrime.sol\";\n\nabstract contract PreCrimeBase is IPreCrimeBase {\n    uint16 public constant CONFIG_VERSION = 1;\n\n    //---------------- error code ----------------------\n    // --- UA scope code ---\n    uint16 public constant CODE_SUCCESS = 0; // success\n    uint16 public constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found\n\n    // --- protocol scope error code ---\n    // simualte\n    uint16 public constant CODE_PACKETS_OVERSIZE = 2; // packets number bigger then max size\n    uint16 public constant CODE_PACKETS_UNSORTED = 3; // packets are unsorted, need backfill and keep order\n    // precrime\n    uint16 public constant CODE_MISS_SIMULATE_RESULT = 4; // miss simulation result\n\n    uint16 public immutable localChainId;\n    uint64 public maxBatchSize;\n    address public precrimeAdmin;\n\n    modifier onlyPrecrimeAdmin() {\n        require(msg.sender == precrimeAdmin, \"only admin\");\n        _;\n    }\n\n    constructor(uint16 _localChainId) {\n        localChainId = _localChainId;\n        precrimeAdmin = msg.sender;\n    }\n\n    function setPrecrimeAdmin(address _precrimeAdmin) external onlyPrecrimeAdmin {\n        precrimeAdmin = _precrimeAdmin;\n    }\n\n    function setMaxBatchSize(uint64 _maxBatchSize) external onlyPrecrimeAdmin {\n        maxBatchSize = _maxBatchSize;\n    }\n\n    /**\n     * @dev get precrime config,\n     * @param _packets packets\n     * @return configation bytes\n     */\n    function getConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {\n        (uint16[] memory remoteChains, bytes32[] memory remoteAddresses) = _remotePrecrimeAddress(_packets);\n        return\n            abi.encodePacked(\n                CONFIG_VERSION,\n                //---- max packets size for simulate batch ---\n                maxBatchSize,\n                //------------- remote precrimes -------------\n                remoteChains.length,\n                remoteChains,\n                remoteAddresses\n            );\n    }\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code definition\n     * @return reason   error reason\n     */\n    function precrime(\n        Packet[] calldata _packets,\n        bytes[] calldata _simulation\n    ) external view override returns (uint16 code, bytes memory reason) {\n        bytes[] memory originSimulateResult = new bytes[](_simulation.length);\n        uint16[] memory chainIds = new uint16[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            (uint16 chainId, bytes memory simulateResult) = abi.decode(_simulation[i], (uint16, bytes));\n            chainIds[i] = chainId;\n            originSimulateResult[i] = simulateResult;\n        }\n\n        (code, reason) = _checkResultsCompleteness(_packets, chainIds);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        (code, reason) = _precrime(originSimulateResult);\n    }\n\n    function _checkPacketsMaxSizeAndNonceOrder(\n        Packet[] calldata _packets\n    ) internal view returns (uint16 code, bytes memory reason) {\n        if (_packets.length > maxBatchSize) {\n            return (CODE_PACKETS_OVERSIZE, abi.encodePacked(\"packets size exceed limited\"));\n        }\n\n        // check packets nonce, sequence order\n        // packets should group by srcChainId and srcAddress, then sort by nonce ascending\n        if (_packets.length > 0) {\n            uint16 srcChainId;\n            bytes32 srcAddress;\n            uint64 nonce;\n            for (uint256 i = 0; i < _packets.length; i++) {\n                Packet memory packet = _packets[i];\n                // start from a new chain packet or a new source UA\n                if (packet.srcChainId != srcChainId || packet.srcAddress != srcAddress) {\n                    srcChainId = packet.srcChainId;\n                    srcAddress = packet.srcAddress;\n                    nonce = packet.nonce;\n                    uint64 nextInboundNonce = _getInboundNonce(packet) + 1;\n                    // the first packet's nonce must equal to dst InboundNonce+1\n                    if (nonce != nextInboundNonce) {\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\"skipped inboundNonce forbidden\"));\n                    }\n                } else {\n                    // the following packet's nonce add 1 in order\n                    if (packet.nonce != ++nonce) {\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\"unsorted packets\"));\n                    }\n                }\n            }\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _checkResultsCompleteness(\n        Packet[] calldata _packets,\n        uint16[] memory _resultChainIds\n    ) internal view returns (uint16 code, bytes memory reason) {\n        // check if all remote result included\n        if (_packets.length > 0) {\n            (uint16[] memory remoteChains, ) = _remotePrecrimeAddress(_packets);\n            for (uint256 i = 0; i < remoteChains.length; i++) {\n                bool resultChainIdChecked;\n                for (uint256 j = 0; j < _resultChainIds.length; j++) {\n                    if (_resultChainIds[j] == remoteChains[i]) {\n                        resultChainIdChecked = true;\n                        break;\n                    }\n                }\n                if (!resultChainIdChecked) {\n                    return (CODE_MISS_SIMULATE_RESULT, \"missing remote simulation result\");\n                }\n            }\n        }\n        // check if local result included\n        bool localChainIdResultChecked;\n        for (uint256 j = 0; j < _resultChainIds.length; j++) {\n            if (_resultChainIds[j] == localChainId) {\n                localChainIdResultChecked = true;\n                break;\n            }\n        }\n        if (!localChainIdResultChecked) {\n            return (CODE_MISS_SIMULATE_RESULT, \"missing local simulation result\");\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code defination\n     * @return reason   error reason\n     */\n    function _precrime(bytes[] memory _simulation) internal view virtual returns (uint16 code, bytes memory reason);\n\n    /**\n     * @dev UA return trusted remote precrimes by packets\n     * @param _packets packets\n     * @return\n     */\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view virtual returns (uint16[] memory, bytes32[] memory);\n\n    /**\n     * get srcChain & srcAddress InboundNonce by packet\n     */\n    function _getInboundNonce(Packet memory packet) internal view virtual returns (uint64 nonce);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/PreCrimeView.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrimeView.sol\";\nimport \"./PreCrimeBase.sol\";\n\nabstract contract PreCrimeView is PreCrimeBase, IPreCrimeView {\n    /**\n     * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode\n     */\n    uint16 public constant PRECRIME_VERSION = 10001;\n\n    constructor(uint16 _localChainId) PreCrimeBase(_localChainId) {}\n\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return data the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external view override returns (uint16 code, bytes memory data) {\n        // params check\n        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);\n        if (code != CODE_SUCCESS) {\n            return (code, data);\n        }\n\n        (code, data) = _simulate(_packets);\n        if (code == CODE_SUCCESS) {\n            data = abi.encode(localChainId, data); // add localChainId to the header\n        }\n    }\n\n    /**\n     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.\n     * @param _packets packets\n     * @return code\n     * @return result\n     */\n    function _simulate(Packet[] calldata _packets) internal view virtual returns (uint16 code, bytes memory result);\n\n    function version() external pure override returns (uint16) {\n        return PRECRIME_VERSION;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/example/inherit/CounterI.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./CounterPrecrime.sol\";\n\ncontract CounterI is CounterPrecrime {\n    // keep track of how many messages have been received from other chains\n    uint public totalCount;\n    mapping(uint32 => uint) public inboundCount;\n    mapping(uint32 => uint) public outboundCount;\n\n    event Send(uint16 dstChainId);\n    event Receive(uint16 srcChainId);\n\n    uint16 public chainId;\n\n    constructor(uint16 _chainId) CounterPrecrime(_chainId) {\n        chainId = _chainId;\n    }\n\n    function lzReceive(uint16 _srcChainId) public {\n        inboundCount[_srcChainId]++;\n        totalCount++;\n\n        emit Receive(_srcChainId);\n    }\n\n    function increment(uint16 _dstChainId) external {\n        outboundCount[_dstChainId]++;\n\n        emit Send(_dstChainId);\n    }\n\n    function brokeIncrement(uint16 _dstChainId) external {\n        emit Send(_dstChainId);\n    }\n\n    function brokeTotalCount() external {\n        totalCount++;\n    }\n\n    function getInboundNonce(uint32 _chainId) public view returns (uint) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return inboundCount[_chainId];\n    }\n\n    // ------------- precrime -----------------\n    function _lzReceiveByPacket(Packet calldata _packet) internal virtual override {\n        lzReceive(uint16(_packet.srcChainId));\n    }\n\n    function getCountState(uint16[] memory peers) public view virtual override returns (CountState memory) {\n        ChainPathCount[] memory chainPathCounts = new ChainPathCount[](peers.length);\n        for (uint i = 0; i < peers.length; i++) {\n            uint16 peer = peers[i];\n            chainPathCounts[i] = ChainPathCount({\n                eid: peer,\n                inboundCount: inboundCount[peer],\n                outboundCount: outboundCount[peer]\n            });\n        }\n\n        CountState memory countState = CountState({totalCount: totalCount, chainPathCounts: chainPathCounts});\n\n        return countState;\n    }\n\n    function _getInboundNonce(Packet memory packet) internal view override returns (uint64) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return uint64(inboundCount[packet.srcChainId]);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/example/inherit/CounterPrecrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../../PreCrime.sol\";\n\nabstract contract CounterPrecrime is PreCrime {\n    uint16[] public remoteChainIds;\n    bytes32[] public remotePrecrimeAddresses;\n\n    struct SimulationResult {\n        uint16 chainId;\n        CountState countState;\n    }\n\n    struct CountState {\n        uint totalCount;\n        ChainPathCount[] chainPathCounts;\n    }\n\n    struct ChainPathCount {\n        uint16 eid;\n        uint inboundCount;\n        uint outboundCount;\n    }\n\n    constructor(uint16 _localChainId) PreCrime(_localChainId) {\n        maxBatchSize = 10;\n    }\n\n    function setRemotePrecrimeAddresses(\n        uint16[] memory _remoteChainIds,\n        bytes32[] memory _remotePrecrimeAddresses\n    ) public onlyPrecrimeAdmin {\n        require(_remoteChainIds.length == _remotePrecrimeAddresses.length, \"Precrime: invalid size\");\n        remoteChainIds = _remoteChainIds;\n        remotePrecrimeAddresses = _remotePrecrimeAddresses;\n    }\n\n    function _simulate(Packet[] calldata _packets) internal override returns (uint16 code, bytes memory data) {\n        // simulate\n        for (uint256 i = 0; i < _packets.length; i++) {\n            _lzReceiveByPacket(_packets[i]);\n        }\n\n        // return simulation result\n        bytes memory result = abi.encode(\n            SimulationResult({chainId: localChainId, countState: getCountState(remoteChainIds)})\n        );\n        return (CODE_SUCCESS, result);\n    }\n\n    function _precrime(\n        bytes[] memory _simulation\n    ) internal view virtual override returns (uint16 code, bytes memory reason) {\n        (SimulationResult memory localResult, SimulationResult[] memory results) = _getLocalSimulateResult(_simulation);\n\n        uint sumOutboundCount = 0;\n        // for each chainPathCount, find the chainPathCount and check the counts\n        for (uint256 j = 0; j < localResult.countState.chainPathCounts.length; j++) {\n            ChainPathCount memory cpCount = localResult.countState.chainPathCounts[j];\n            // find remote to local count state\n            // should provide all peers simulated results\n            ChainPathCount memory remoteCp = _getRemoteCpCount(results, cpCount.eid);\n            (code, reason) = _assertChainPathCount(cpCount, remoteCp);\n            if (code != CODE_SUCCESS) {\n                return (code, reason);\n            }\n            sumOutboundCount += remoteCp.outboundCount; // remote to local outbound count\n        }\n        (code, reason) = _assertTotalCount(localResult.countState, sumOutboundCount);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _lzReceiveByPacket(Packet calldata _packet) internal virtual;\n\n    /**\n     * @notice Get the count states for a list of peers\n     * @param peers - the list of remote chainId to get counts for\n     * @return counts - the CountState with the total count and the chain path counts\n     */\n    function getCountState(uint16[] memory peers) public view virtual returns (CountState memory);\n\n    function _getRemoteCpCount(\n        SimulationResult[] memory _results,\n        uint16 _remoteId\n    ) internal view returns (ChainPathCount memory) {\n        uint localEid = localChainId;\n        for (uint256 i = 0; i < _results.length; i++) {\n            SimulationResult memory remoteResult = _results[i];\n            if (remoteResult.chainId == _remoteId) {\n                for (uint256 j = 0; j < remoteResult.countState.chainPathCounts.length; j++) {\n                    ChainPathCount memory cpCount = remoteResult.countState.chainPathCounts[j];\n                    if (cpCount.eid == localEid) {\n                        // find to localEid path\n                        return cpCount;\n                    }\n                }\n            }\n        }\n        revert(\"Precrime: countState not found, are you missing a simulation?\");\n    }\n\n    function _getLocalSimulateResult(\n        bytes[] memory _simulation\n    ) internal view returns (SimulationResult memory localResult, SimulationResult[] memory results) {\n        // decode results\n        results = new SimulationResult[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            bytes memory result = _simulation[i];\n            results[i] = abi.decode(result, (SimulationResult));\n            if (results[i].chainId == localChainId) {\n                localResult = results[i];\n            }\n        }\n    }\n\n    function _assertChainPathCount(\n        ChainPathCount memory _localCpCount,\n        ChainPathCount memory _remoteCpCount\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCpCount.inboundCount > _remoteCpCount.outboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: inboundCount > outboundCount\");\n        }\n        if (_localCpCount.outboundCount > _remoteCpCount.inboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: outboundCount > inboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _assertTotalCount(\n        CountState memory _localCount,\n        uint _sumOutbound\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCount.totalCount > _sumOutbound) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: totalCount > sum outboundCount\");\n        }\n    }\n\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view override returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {\n        if (_packets.length == 0) {\n            return (remoteChainIds, remotePrecrimeAddresses);\n        }\n\n        // only return related remotes\n        uint16 size = _getRelatedRemoteSize(_packets);\n        if (size > 0) {\n            chainIds = new uint16[](size);\n            uint256 k = 0;\n            precrimeAddresses = new bytes32[](size);\n            for (uint16 i = 0; i < remoteChainIds.length; i++) {\n                for (uint16 j = 0; j < _packets.length; j++) {\n                    uint16 srcChainId = _packets[j].srcChainId;\n                    if (remoteChainIds[i] == srcChainId) {\n                        chainIds[k] = srcChainId;\n                        precrimeAddresses[k] = remotePrecrimeAddresses[i];\n                        k++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _getRelatedRemoteSize(Packet[] memory _packets) internal view returns (uint16 size) {\n        for (uint16 i = 0; i < remoteChainIds.length; i++) {\n            for (uint16 j = 0; j < _packets.length; j++) {\n                if (remoteChainIds[i] == _packets[j].srcChainId) {\n                    size++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/example/view/CounterPrecrimeView.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../../PreCrimeView.sol\";\nimport \"./CounterView.sol\";\nimport \"./CounterV.sol\";\n\ncontract CounterPrecrimeView is PreCrimeView {\n    CounterView public counterView;\n\n    uint16[] public remoteChainIds;\n    bytes32[] public remotePrecrimeAddresses;\n\n    struct SimulationResult {\n        uint16 chainId;\n        CounterView.CountState countState;\n    }\n\n    constructor(uint16 _localChainId, address _counterView) PreCrimeView(_localChainId) {\n        counterView = CounterView(_counterView);\n        maxBatchSize = 10;\n    }\n\n    function setRemotePrecrimeAddresses(\n        uint16[] memory _remoteChainIds,\n        bytes32[] memory _remotePrecrimeAddresses\n    ) public onlyPrecrimeAdmin {\n        require(_remoteChainIds.length == _remotePrecrimeAddresses.length, \"Precrime: invalid size\");\n        remoteChainIds = _remoteChainIds;\n        remotePrecrimeAddresses = _remotePrecrimeAddresses;\n    }\n\n    function setCounterView(address _counterView) public onlyPrecrimeAdmin {\n        counterView = CounterView(_counterView);\n    }\n\n    function _simulate(Packet[] calldata _packets) internal view override returns (uint16 code, bytes memory data) {\n        // get state from counter\n        CounterView.CountState memory countState = counterView.getCountState(remoteChainIds);\n\n        // simulate\n        for (uint256 i = 0; i < _packets.length; i++) {\n            Packet memory packet = _packets[i];\n            countState = counterView.lzReceive(countState, packet.srcChainId);\n        }\n\n        // return simulation result\n        return (CODE_SUCCESS, abi.encode(SimulationResult({chainId: localChainId, countState: countState})));\n    }\n\n    function _precrime(\n        bytes[] memory _simulation\n    ) internal view virtual override returns (uint16 code, bytes memory reason) {\n        (SimulationResult memory localResult, SimulationResult[] memory results) = _getLocalSimulateResult(_simulation);\n\n        uint sumOutboundCount = 0;\n        // for each chainPathCount, find the chainPathCount and check the counts\n        for (uint256 j = 0; j < localResult.countState.chainPathCounts.length; j++) {\n            CounterView.ChainPathCount memory cpCount = localResult.countState.chainPathCounts[j];\n            // find remote to local count state\n            // should provide all peers simulated results\n            CounterView.ChainPathCount memory remoteCp = _getRemoteCpCount(results, cpCount.eid);\n            (code, reason) = _assertChainPathCount(cpCount, remoteCp);\n            if (code != CODE_SUCCESS) {\n                return (code, reason);\n            }\n            sumOutboundCount += remoteCp.outboundCount; // remote to local outbound count\n        }\n        (code, reason) = _assertTotalCount(localResult.countState, sumOutboundCount);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _getRemoteCpCount(\n        SimulationResult[] memory _results,\n        uint16 _remoteId\n    ) internal view returns (CounterView.ChainPathCount memory) {\n        uint localEid = localChainId;\n        for (uint256 i = 0; i < _results.length; i++) {\n            SimulationResult memory remoteResult = _results[i];\n            if (remoteResult.chainId == _remoteId) {\n                for (uint256 j = 0; j < remoteResult.countState.chainPathCounts.length; j++) {\n                    CounterView.ChainPathCount memory cpCount = remoteResult.countState.chainPathCounts[j];\n                    if (cpCount.eid == localEid) {\n                        // find to localEid path\n                        return cpCount;\n                    }\n                }\n            }\n        }\n        revert(\"Precrime: count state not found\");\n    }\n\n    function _getLocalSimulateResult(\n        bytes[] memory _simulation\n    ) internal view returns (SimulationResult memory localResult, SimulationResult[] memory results) {\n        // decode results\n        results = new SimulationResult[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            results[i] = abi.decode(_simulation[i], (SimulationResult));\n            if (results[i].chainId == localChainId) {\n                localResult = results[i];\n            }\n        }\n    }\n\n    function _assertChainPathCount(\n        CounterView.ChainPathCount memory _localCpCount,\n        CounterView.ChainPathCount memory _remoteCpCount\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCpCount.inboundCount > _remoteCpCount.outboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: inboundCount > outboundCount\");\n        }\n        if (_localCpCount.outboundCount > _remoteCpCount.inboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: outboundCount > inboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _assertTotalCount(\n        CounterView.CountState memory _localCount,\n        uint _sumOutbound\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCount.totalCount > _sumOutbound) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: totalCount > sum outboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view override returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {\n        if (_packets.length == 0) {\n            return (remoteChainIds, remotePrecrimeAddresses);\n        }\n\n        // only return related remotes\n        uint16 size = _getRelatedRemoteSize(_packets);\n        if (size > 0) {\n            chainIds = new uint16[](size);\n            uint256 k = 0;\n            precrimeAddresses = new bytes32[](size);\n            for (uint16 i = 0; i < remoteChainIds.length; i++) {\n                for (uint16 j = 0; j < _packets.length; j++) {\n                    uint16 srcChainId = _packets[j].srcChainId;\n                    if (remoteChainIds[i] == srcChainId) {\n                        chainIds[k] = srcChainId;\n                        precrimeAddresses[k] = remotePrecrimeAddresses[i];\n                        k++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _getRelatedRemoteSize(Packet[] memory _packets) internal view returns (uint16 size) {\n        for (uint16 i = 0; i < remoteChainIds.length; i++) {\n            for (uint16 j = 0; j < _packets.length; j++) {\n                if (remoteChainIds[i] == _packets[j].srcChainId) {\n                    size++;\n                    break;\n                }\n            }\n        }\n    }\n\n    function _getInboundNonce(Packet memory packet) internal view override returns (uint64) {\n        CounterV counter = counterView.counter();\n        return counter.getInboundNonce(packet.srcChainId);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/example/view/CounterV.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ncontract CounterV {\n    // keep track of how many messages have been received from other chains\n    uint public totalCount;\n    mapping(uint32 => uint) public inboundCount;\n    mapping(uint32 => uint) public outboundCount;\n\n    event Send(uint16 dstChainId);\n    event Receive(uint16 srcChainId);\n\n    uint16 public chainId;\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    function lzReceive(uint16 _srcChainId) external {\n        inboundCount[_srcChainId]++;\n        totalCount++;\n\n        emit Receive(_srcChainId);\n    }\n\n    function increment(uint16 _dstChainId) external {\n        outboundCount[_dstChainId]++;\n\n        emit Send(_dstChainId);\n    }\n\n    function brokeIncrement(uint16 _dstChainId) external {\n        emit Send(_dstChainId);\n    }\n\n    function brokeTotalCount() external {\n        totalCount++;\n    }\n\n    function getInboundNonce(uint16 _chainId) public view returns (uint64) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return uint64(inboundCount[_chainId]);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/example/view/CounterView.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./CounterV.sol\";\n\ncontract CounterView {\n    struct CountState {\n        uint totalCount;\n        ChainPathCount[] chainPathCounts;\n    }\n\n    struct ChainPathCount {\n        uint16 eid;\n        uint inboundCount;\n        uint outboundCount;\n    }\n\n    CounterV public counter;\n\n    constructor(address _counter) {\n        counter = CounterV(_counter);\n    }\n\n    function lzReceive(CountState memory countState, uint16 _srcChainId) public pure returns (CountState memory) {\n        // do receive logic\n        for (uint i = 0; i < countState.chainPathCounts.length; i++) {\n            ChainPathCount memory chainPathCount = countState.chainPathCounts[i];\n            if (chainPathCount.eid == _srcChainId) {\n                countState.totalCount++;\n                chainPathCount.inboundCount++;\n                countState.chainPathCounts[i] = chainPathCount;\n                break;\n            }\n        }\n        return countState;\n    }\n\n    /**\n     * @notice Get the count states for a list of peers\n     * @param peers - the list of remote chainId to get counts for\n     * @return counts - the CountState with the total count and the chain path counts\n     */\n    function getCountState(uint16[] calldata peers) public view returns (CountState memory) {\n        ChainPathCount[] memory chainPathCounts = new ChainPathCount[](peers.length);\n\n        for (uint i = 0; i < peers.length; i++) {\n            uint16 peer = peers[i];\n            chainPathCounts[i] = ChainPathCount({\n                eid: peer,\n                inboundCount: counter.inboundCount(peer),\n                outboundCount: counter.outboundCount(peer)\n            });\n        }\n\n        CountState memory countState = CountState({totalCount: counter.totalCount(), chainPathCounts: chainPathCounts});\n\n        return countState;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IPreCrimeBase.sol\";\n\ninterface IPreCrime is IPreCrimeBase {\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return result the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external returns (uint16 code, bytes memory result);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/interfaces/IPreCrimeBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface IPreCrimeBase {\n    struct Packet {\n        uint16 srcChainId; // source chain id\n        bytes32 srcAddress; // srouce UA address\n        uint64 nonce;\n        bytes payload;\n    }\n\n    /**\n     * @dev get precrime config,\n     * @param _packets packets\n     * @return bytes of [maxBatchSize, remotePrecrimes]\n     */\n    function getConfig(Packet[] calldata _packets) external view returns (bytes memory);\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code defination\n     * @return reason   error reason\n     */\n    function precrime(\n        Packet[] calldata _packets,\n        bytes[] calldata _simulation\n    ) external view returns (uint16 code, bytes memory reason);\n\n    /**\n     * @dev protocol version\n     */\n    function version() external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/precrime/interfaces/IPreCrimeView.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IPreCrimeBase.sol\";\n\ninterface IPreCrimeView is IPreCrimeBase {\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return result the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/FPValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract FPValidator is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    uint8 public proofType = 2;\n    uint8 public utilsVersion = 1;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(\n        bytes32 _packetHash,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        // _transactionProof = srcUlnAddress (32 bytes) + lzPacket\n        require(\n            _transactionProof.length > 32 && keccak256(_transactionProof) == _packetHash,\n            \"ProofLib: invalid transaction proof\"\n        );\n\n        bytes memory ulnAddressBytes = bytes(_transactionProof[0:32]);\n        bytes32 ulnAddress;\n        assembly {\n            ulnAddress := mload(add(ulnAddressBytes, 32))\n        }\n        packet = LayerZeroPacket.getPacketV3(_transactionProof[32:], _remoteAddressSize, ulnAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(\n        bytes32,\n        uint[] calldata,\n        uint,\n        bytes[] calldata proof\n    ) external pure override returns (ULNLog memory log) {}\n\n    function getPacket(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV3(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidator is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory pointers, uint receiptIndex, uint logIndex) = abi\n            .decode(_transactionProof, (uint16, bytes[], uint[], uint, uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptIndex, logIndex, proof, pointers);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"LayerZero: packet not recognized\"); //data\n\n        return getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof,\n        uint[] memory pointers\n    ) internal pure returns (ULNLog memory) {\n        // walk and assert the hash links of MPT\n        uint pointer;\n        bytes memory proofBytes;\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"LayerZero: invalid hashlink\");\n            if (i < pointers.length) {\n                pointer = pointers[i];\n                assembly {\n                    hashRoot := mload(add(add(proofBytes, pointer), 32))\n                }\n            }\n        }\n\n        // build the iterator for the proofBytes\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(proofBytes).iterator();\n\n        // get the receipt item from either branch or leaf node\n        RLPDecode.RLPItem memory receiptItem = it.item.getItemByIndex(receiptSlotIndex);\n        // it = targetReceiptIter\n        it = receiptItem.typeOffset().iterator();\n        it.next(); // status\n        it.next(); // gasUsed\n        it.next(); // logBloom\n\n        // it = targetLogIter\n        it = it.next().getItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof,\n        uint[] memory pointers\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof, pointers);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                address(dstAddress),\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidator01.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\nimport \"../interfaces/IValidationLibraryHelperV2.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidator01 is ILayerZeroValidationLibrary, IValidationLibraryHelperV2 {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    uint8 public proofType = 1;\n    uint8 public utilsVersion = 4;\n    bytes32 public constant PACKET_SIGNATURE = 0xe9bded5f24a4168e4f3bf44e00298c993b22376aad8c58c7dda9718a54cbea82;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stargateTokenAddress;\n\n    constructor(address _stargateBridgeAddress, address _stargateTokenAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stargateTokenAddress = _stargateTokenAddress;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory packet) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n        (bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        packet = LayerZeroPacket.getPacketV2(log.data, _remoteAddressSize, log.contractAddress);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stargateTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getProofType() external view override returns (uint8) {\n        return proofType;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return LayerZeroPacket.getPacketV2(data, sizeOfSrcAddress, ulnAddress);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidatorStgV3.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorStgV3 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n    }\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (uint16, bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = _getPacket(\n            log.data,\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                CreditObj memory c,\n                SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, CreditObj, SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidatorV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/Buffer.sol\";\nimport \"../interfaces/ILayerZeroValidationLibrary.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ncontract MPTValidatorV2 is ILayerZeroValidationLibrary {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    struct ULNLog {\n        bytes32 contractAddress;\n        bytes32 topicZeroSig;\n        bytes data;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external pure override returns (LayerZeroPacket.Packet memory packet) {\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(\n            _transactionProof,\n            (uint16, bytes[], uint[], uint)\n        );\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        return _getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    // profiling and test\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure returns (LayerZeroPacket.Packet memory) {\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    function _getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  destination chain id\n        // 32  |  defines bytes array\n        // 64  |\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidatorV4.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV4 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId, address _ulnAddress) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (\n            uint16 remoteChainId,\n            bytes32 blockHash,\n            bytes[] memory proof,\n            uint[] memory receiptSlotIndex,\n            uint logIndex\n        ) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(\n            packet.srcChainId,\n            packet.dstAddress\n        );\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(\n            appConfig.oracle,\n            packet.srcChainId,\n            blockHash\n        );\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(\n            blockData.confirmations >= appConfig.inboundBlockConfirmations,\n            \"ProofLib: not enough block confirmations\"\n        );\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/MPTValidatorV5.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IValidationLibraryHelper.sol\";\nimport \"./utility/LayerZeroPacket.sol\";\nimport \"./utility/UltraLightNodeEVMDecoder.sol\";\n\ninterface IUltraLightNode {\n    struct BlockData {\n        uint confirmations;\n        bytes32 data;\n    }\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    function getAppConfig(\n        uint16 _chainId,\n        address userApplicationAddress\n    ) external view returns (ApplicationConfiguration memory);\n\n    function getBlockHeaderData(\n        address _oracle,\n        uint16 _remoteChainId,\n        bytes32 _lookupHash\n    ) external view returns (BlockData memory blockData);\n}\n\ninterface IStargate {\n    // Stargate objects for abi encoding / decoding\n    struct SwapObj {\n        uint amount;\n        uint eqFee;\n        uint eqReward;\n        uint lpFee;\n        uint protocolFee;\n        uint lkbRemove;\n    }\n\n    struct CreditObj {\n        uint credits;\n        uint idealBalance;\n    }\n}\n\ncontract MPTValidatorV5 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using LayerZeroPacket for bytes;\n\n    uint8 public utilsVersion = 3;\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\n\n    address public immutable stargateBridgeAddress;\n    address public immutable stgTokenAddress;\n    address public immutable relayerAddress;\n    uint16 public immutable localChainId;\n    IUltraLightNode public immutable uln;\n\n    constructor(\n        address _stargateBridgeAddress,\n        address _stgTokenAddress,\n        uint16 _localChainId,\n        address _ulnAddress,\n        address _relayerAddress\n    ) {\n        stargateBridgeAddress = _stargateBridgeAddress;\n        stgTokenAddress = _stgTokenAddress;\n        localChainId = _localChainId;\n        uln = IUltraLightNode(_ulnAddress);\n        relayerAddress = _relayerAddress;\n    }\n\n    function validateProof(\n        bytes32 _receiptsRoot,\n        bytes calldata _transactionProof,\n        uint _remoteAddressSize\n    ) external view override returns (LayerZeroPacket.Packet memory) {\n        require(_remoteAddressSize > 0, \"ProofLib: invalid address size\");\n\n        (\n            uint16 remoteChainId,\n            bytes32 blockHash,\n            bytes[] memory proof,\n            uint[] memory receiptSlotIndex,\n            uint logIndex\n        ) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\n\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\n        require(log.topicZeroSig == PACKET_SIGNATURE, \"ProofLib: packet not recognized\"); //data\n\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(\n            remoteChainId,\n            _remoteAddressSize,\n            log.contractAddress\n        );\n\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\n\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\n\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\n\n        return packet;\n    }\n\n    function _assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) internal view {\n        require(packet.dstChainId == localChainId, \"ProofLib: invalid destination chain ID\");\n\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(\n            packet.srcChainId,\n            packet.dstAddress\n        );\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(\n            appConfig.oracle,\n            packet.srcChainId,\n            blockHash\n        );\n        require(appConfig.relayer == relayerAddress, \"ProofLib: invalid relayer\");\n\n        require(blockData.data == receiptsRoot, \"ProofLib: invalid receipt root\");\n\n        require(\n            blockData.confirmations >= appConfig.inboundBlockConfirmations,\n            \"ProofLib: not enough block confirmations\"\n        );\n    }\n\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\n        (bytes memory toAddressBytes, uint qty) = abi.decode(_payload, (bytes, uint));\n\n        address toAddress = address(0);\n        if (toAddressBytes.length > 0) {\n            assembly {\n                toAddress := mload(add(toAddressBytes, 20))\n            }\n        }\n\n        if (toAddress == address(0)) {\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\n            return abi.encode(newToAddressBytes, qty);\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\n        // functionType is uint8 even though the encoding will take up the side of uint256\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\n        // thus we do not care about the other type functions even if the toAddress is overly long.\n        if (functionType == 1) {\n            // decode the _payload with its types\n            (\n                ,\n                uint srcPoolId,\n                uint dstPoolId,\n                uint dstGasForCall,\n                IStargate.CreditObj memory c,\n                IStargate.SwapObj memory s,\n                bytes memory toAddressBytes,\n                bytes memory contractCallPayload\n            ) = abi.decode(_payload, (uint8, uint, uint, uint, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\n\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\n            if (contractCallPayload.length > 0) {\n                // otherwise, need to check if the payload can be delivered to the toAddress\n                address toAddress = address(0);\n                if (toAddressBytes.length > 0) {\n                    assembly {\n                        toAddress := mload(add(toAddressBytes, 20))\n                    }\n                }\n\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\n                uint size;\n                assembly {\n                    size := extcodesize(toAddress)\n                }\n\n                if (size == 0) {\n                    // size == 0 indicates its not a contract, payload wont be delivered\n                    // secure the _payload to make sure funds can be delivered to the toAddress\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\n                    bytes memory securePayload = abi.encode(\n                        functionType,\n                        srcPoolId,\n                        dstPoolId,\n                        dstGasForCall,\n                        c,\n                        s,\n                        newToAddressBytes,\n                        bytes(\"\")\n                    );\n                    return securePayload;\n                }\n            }\n        }\n\n        // default to return the original payload\n        return _payload;\n    }\n\n    function secureStgTokenPayload(bytes memory _payload) external pure returns (bytes memory) {\n        return _secureStgTokenPayload(_payload);\n    }\n\n    function secureStgPayload(bytes memory _payload) external view returns (bytes memory) {\n        return _secureStgPayload(_payload);\n    }\n\n    function _getVerifiedLog(\n        bytes32 hashRoot,\n        uint[] memory paths,\n        uint logIndex,\n        bytes[] memory proof\n    ) internal pure returns (ULNLog memory) {\n        require(paths.length == proof.length, \"ProofLib: invalid proof size\");\n        require(proof.length > 0, \"ProofLib: proof size must > 0\");\n        RLPDecode.RLPItem memory item;\n        bytes memory proofBytes;\n\n        for (uint i = 0; i < proof.length; i++) {\n            proofBytes = proof[i];\n            require(hashRoot == keccak256(proofBytes), \"ProofLib: invalid hashlink\");\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\n        }\n\n        // burning status + gasUsed + logBloom\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\n        RLPDecode.Iterator memory it = logItem.safeGetItemByIndex(logIndex).iterator();\n        ULNLog memory log;\n        log.contractAddress = bytes32(it.next().toUint());\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\n        log.data = it.next().toBytes();\n\n        return log;\n    }\n\n    function getUtilsVersion() external view override returns (uint8) {\n        return utilsVersion;\n    }\n\n    function getVerifyLog(\n        bytes32 hashRoot,\n        uint[] memory receiptSlotIndex,\n        uint logIndex,\n        bytes[] memory proof\n    ) external pure override returns (ULNLog memory) {\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) external pure override returns (LayerZeroPacket.Packet memory) {\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\n    }\n\n    // profiling and test\n    function assertMessagePath(\n        LayerZeroPacket.Packet memory packet,\n        bytes32 blockHash,\n        bytes32 receiptsRoot\n    ) external view {\n        _assertMessagePath(packet, blockHash, receiptsRoot);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/utility/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/utility/LayerZeroPacket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChainId,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32); // 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize >= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize > 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return\n            LayerZeroPacket.Packet(\n                srcChain,\n                dstChain,\n                nonce,\n                dstAddress,\n                srcAddressBuffer.buf,\n                ulnAddress,\n                payloadBuffer.buf\n            );\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/utility/RLPDecode.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/hamdiallam/solidity-rlp\n\npragma solidity ^0.7.0;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"RLPDecoder iterator has no next\");\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n        // offset the pointer if the first byte\n\n        uint8 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n        uint len = item.length;\n        if (len > 0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self), \"RLPDecoder iterator is not list\");\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid uint RLP item offset size\");\n        return item.len - offset;\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function getItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n        return RLPItem(dataLen, memPtr);\n    }\n\n    /*\n     * @param get the RLP item by index. save gas.\n     */\n    function safeGetItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\n        require(isList(item), \"RLPDecoder iterator is not a list\");\n        require(idx < numItems(item), \"RLP item out of bounds\");\n        uint endPtr = item.memPtr + item.len;\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < idx; i++) {\n            dataLen = _itemLength(memPtr);\n            memPtr = memPtr + dataLen;\n        }\n        dataLen = _itemLength(memPtr);\n\n        require(memPtr + dataLen <= endPtr, \"RLP item overflow\");\n        return RLPItem(dataLen, memPtr);\n    }\n\n    /*\n     * @param offset the receipt bytes item\n     */\n    function typeOffset(RLPItem memory item) internal pure returns (RLPItem memory) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        uint len = item.len;\n        assembly {\n            memPtr := add(memPtr, offset)\n            byte0 := byte(0, mload(memPtr))\n        }\n        if (len > 0 && byte0 < LIST_SHORT_START) {\n            assembly {\n                memPtr := add(memPtr, 0x01)\n            }\n            len -= 1;\n        }\n        return RLPItem(len, memPtr);\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"RLPDecoder toBoolean invalid length\");\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21, \"RLPDecoder toAddress invalid length\");\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33, \"RLPDecoder toUint invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset;\n\n        uint result;\n        uint memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if necessary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33, \"RLPDecoder toUintStrict invalid length\");\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"RLPDecoder toBytes invalid length\");\n\n        uint offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"RLPDecoder: invalid RLP item offset size\");\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proof/utility/UltraLightNodeEVMDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./RLPDecode.sol\";\n\nlibrary UltraLightNodeEVMDecoder {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n\n    struct Log {\n        address contractAddress;\n        bytes32 topicZero;\n        bytes data;\n    }\n\n    function getReceiptLog(bytes memory data, uint logIndex) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 3) {\n                return toReceiptLog(it.next().getItemByIndex(logIndex).toRlpBytes());\n            } else it.next();\n            idx++;\n        }\n        revert(\"no log index in receipt\");\n    }\n\n    function toReceiptLog(bytes memory data) internal pure returns (Log memory) {\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\n        Log memory log;\n\n        uint idx;\n        while (it.hasNext()) {\n            if (idx == 0) {\n                log.contractAddress = it.next().toAddress();\n            } else if (idx == 1) {\n                RLPDecode.RLPItem memory item = it.next().getItemByIndex(0);\n                log.topicZero = bytes32(item.toUint());\n            } else if (idx == 2) log.data = it.next().toBytes();\n            else it.next();\n            idx++;\n        }\n        return log;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proxy/DefaultProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract DefaultProxyAdmin is Ownable {\n    constructor(address initialOwner) {\n        transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-v1-0.7/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { OApp } from \"./OApp.sol\";\n\nabstract contract OAppRead is OApp {\n    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) {}\n\n    // -------------------------------\n    // Only Owner\n    function setReadChannel(uint32 _channelId, bool _active) public virtual onlyOwner {\n        _setPeer(_channelId, _active ? AddressCast.toBytes32(address(this)) : bytes32(0));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroComposer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\";\n\n/**\n * @title IOAppComposer\n * @dev This interface defines the OApp Composer, allowing developers to inherit only the OApp package without the protocol.\n */\n// solhint-disable-next-line no-empty-blocks\ninterface IOAppComposer is ILayerZeroComposer {}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IOAppMapper {\n    function lzMap(bytes calldata _request, bytes calldata _response) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReducer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IOAppReducer {\n    function lzReduce(bytes calldata _cmd, bytes[] calldata _responses) external view returns (bytes memory);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    // /**\n    //  * @dev Adds an executor native drop option to the existing options.\n    //  * @param _options The existing options container.\n    //  * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n    //  * @param _receiver The receiver address for the native drop option.\n    //  * @return options The updated options container.\n    //  *\n    //  * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n    //  */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _size,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _size, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/ReadCodecV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nstruct EVMCallRequestV1 {\n    uint16 appRequestLabel; // Label identifying the application or type of request (can be use in lzCompute)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n    bytes callData; // Calldata for the contract call\n}\n\nstruct EVMCallComputeV1 {\n    uint8 computeSetting; // Compute setting (0 = map only, 1 = reduce only, 2 = map reduce)\n    uint32 targetEid; // Target endpoint ID (representing a target blockchain)\n    bool isBlockNum; // True if the request = block number, false if timestamp\n    uint64 blockNumOrTimestamp; // Block number or timestamp to use in the request\n    uint16 confirmations; // Number of block confirmations on top of the requested block number or timestamp before the view function can be called\n    address to; // Address of the target contract on the target chain\n}\n\nlibrary ReadCodecV1 {\n    using SafeCast for uint256;\n\n    uint16 internal constant CMD_VERSION = 1;\n\n    uint8 internal constant REQUEST_VERSION = 1;\n    uint16 internal constant RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    uint8 internal constant COMPUTE_VERSION = 1;\n    uint16 internal constant COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL = 1;\n\n    error InvalidVersion();\n    error InvalidType();\n\n    function decode(\n        bytes calldata _cmd\n    )\n        internal\n        pure\n        returns (uint16 appCmdLabel, EVMCallRequestV1[] memory evmCallRequests, EVMCallComputeV1 memory compute)\n    {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        appCmdLabel = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n\n        (evmCallRequests, offset) = decodeRequestsV1(_cmd, offset);\n\n        // decode the compute if it exists\n        if (offset < _cmd.length) {\n            (compute, ) = decodeEVMCallComputeV1(_cmd, offset);\n        }\n    }\n\n    function decodeRequestsV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallRequestV1[] memory evmCallRequests, uint256 newOffset) {\n        newOffset = _offset;\n        uint16 requestCount = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n\n        evmCallRequests = new EVMCallRequestV1[](requestCount);\n        for (uint16 i = 0; i < requestCount; i++) {\n            uint8 requestVersion = uint8(_cmd[newOffset]);\n            newOffset += 1;\n            if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n            uint16 appRequestLabel = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            uint16 resolverType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n            newOffset += 2;\n\n            if (resolverType == RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL) {\n                (EVMCallRequestV1 memory request, uint256 nextOffset) = decodeEVMCallRequestV1(\n                    _cmd,\n                    newOffset,\n                    appRequestLabel\n                );\n                newOffset = nextOffset;\n                evmCallRequests[i] = request;\n            } else {\n                revert InvalidType();\n            }\n        }\n    }\n\n    function decodeEVMCallRequestV1(\n        bytes calldata _cmd,\n        uint256 _offset,\n        uint16 _appRequestLabel\n    ) internal pure returns (EVMCallRequestV1 memory request, uint256 newOffset) {\n        newOffset = _offset;\n        request.appRequestLabel = _appRequestLabel;\n\n        uint16 requestSize = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        request.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        request.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        request.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        request.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n        uint16 callDataSize = requestSize - 35;\n        request.callData = _cmd[newOffset:newOffset + callDataSize];\n        newOffset += callDataSize;\n    }\n\n    function decodeEVMCallComputeV1(\n        bytes calldata _cmd,\n        uint256 _offset\n    ) internal pure returns (EVMCallComputeV1 memory compute, uint256 newOffset) {\n        newOffset = _offset;\n        uint8 computeVersion = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        if (computeVersion != COMPUTE_VERSION) revert InvalidVersion();\n        uint16 computeType = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        if (computeType != COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL) revert InvalidType();\n\n        compute.computeSetting = uint8(_cmd[newOffset]);\n        newOffset += 1;\n        compute.targetEid = uint32(bytes4(_cmd[newOffset:newOffset + 4]));\n        newOffset += 4;\n        compute.isBlockNum = uint8(_cmd[newOffset]) == 1;\n        newOffset += 1;\n        compute.blockNumOrTimestamp = uint64(bytes8(_cmd[newOffset:newOffset + 8]));\n        newOffset += 8;\n        compute.confirmations = uint16(bytes2(_cmd[newOffset:newOffset + 2]));\n        newOffset += 2;\n        compute.to = address(bytes20(_cmd[newOffset:newOffset + 20]));\n        newOffset += 20;\n    }\n\n    function decodeCmdAppLabel(bytes calldata _cmd) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint16 cmdVersion = uint16(bytes2(_cmd[offset:offset + 2]));\n        offset += 2;\n        if (cmdVersion != CMD_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_cmd[offset:offset + 2]));\n    }\n\n    function decodeRequestV1AppRequestLabel(bytes calldata _request) internal pure returns (uint16) {\n        uint256 offset = 0;\n        uint8 requestVersion = uint8(_request[offset]);\n        offset += 1;\n        if (requestVersion != REQUEST_VERSION) revert InvalidVersion();\n\n        return uint16(bytes2(_request[offset:offset + 2]));\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests,\n        EVMCallComputeV1 memory _evmCallCompute\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = encode(_appCmdLabel, _evmCallRequests);\n        if (_evmCallCompute.targetEid != 0) {\n            // if eid is 0, it means no compute\n            cmd = appendEVMCallComputeV1(cmd, _evmCallCompute);\n        }\n        return cmd;\n    }\n\n    function encode(\n        uint16 _appCmdLabel,\n        EVMCallRequestV1[] memory _evmCallRequests\n    ) internal pure returns (bytes memory) {\n        bytes memory cmd = abi.encodePacked(CMD_VERSION, _appCmdLabel, _evmCallRequests.length.toUint16());\n        for (uint256 i = 0; i < _evmCallRequests.length; i++) {\n            cmd = appendEVMCallRequestV1(cmd, _evmCallRequests[i]);\n        }\n        return cmd;\n    }\n\n    // todo: optimize this with Buffer\n    function appendEVMCallRequestV1(\n        bytes memory _cmd,\n        EVMCallRequestV1 memory _request\n    ) internal pure returns (bytes memory) {\n        bytes memory newCmd = abi.encodePacked(\n            _cmd,\n            REQUEST_VERSION,\n            _request.appRequestLabel,\n            RESOLVER_TYPE_SINGLE_VIEW_EVM_CALL,\n            (_request.callData.length + 35).toUint16(),\n            _request.targetEid\n        );\n        return\n            abi.encodePacked(\n                newCmd,\n                _request.isBlockNum,\n                _request.blockNumOrTimestamp,\n                _request.confirmations,\n                _request.to,\n                _request.callData\n            );\n    }\n\n    function appendEVMCallComputeV1(\n        bytes memory _cmd,\n        EVMCallComputeV1 memory _compute\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _cmd,\n                COMPUTE_VERSION,\n                COMPUTE_TYPE_SINGLE_VIEW_EVM_CALL,\n                _compute.computeSetting,\n                _compute.targetEid,\n                _compute.isBlockNum,\n                _compute.blockNumOrTimestamp,\n                _compute.confirmations,\n                _compute.to\n            );\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title RateLimiter\n * @dev Abstract contract for implementing rate limiting functionality. This contract provides a basic framework for\n * rate limiting how often a function can be executed. It is designed to be inherited by other contracts requiring rate\n * limiting capabilities to protect resources or services from excessive use.\n * @dev The ordering of transactions within a given block (timestamp) affects the consumed capacity.\n * @dev Carefully consider the minimum window duration for the given blockchain.  For example, on Ethereum, the minimum\n * window duration should be at least 12 seconds.  If a window less than 12 seconds is configured, then the rate limit\n * will effectively reset with each block, rendering rate limiting ineffective.\n * @dev Carefully consider the proportion of the limit to the window.  If the limit is much smaller than the window, the\n * decay function is lossy.  Consider using a limit that is greater than or equal to the window to avoid this.  This is\n * especially important for blockchains with short average block times.\n *\n * Example 1: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         * (After 30 seconds only 50 units in flight)\n *          |           *\n *          |             *\n *          |               *\n *       0  +--|---|---|---|---|-->(After 60 seconds 0 units are in flight)\n *             0  15  30  45  60 (seconds)\n *\n * Example 2: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down\n * allowing for more to be sent. At the 90 second mark, more in flights come in.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         *          * (50 inflight)\n *          |           *          *\n *          |             *          *\n *          |               *          *\n *        0  +--|--|--|--|--|--|--|--|--|--> Time\n *              0 15 30 45 60 75 90 105 120  (seconds)\n *\n * Example 3: Max rate limit reached at beginning of window. At the 15 second mark, the window gets updated to 60\n * seconds and the limit gets updated to 50 units. This scenario shows the direct depiction of \"in flight\" from the\n * previous window affecting the current window.\n *\n * Initial Rate Limit Config: For first 15 seconds\n *   limit: 100 units\n *   window: 30 seconds\n *\n * Updated Rate Limit Config: Updated at 15 second mark\n *   limit: 50 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *      100 - *\n *            |*\n *            | *\n *            |  *\n *            |   *\n *            |    *\n *            |     *\n *       75 - |      *\n *            |       *\n *            |        *\n *            |         *\n *            |          *\n *            |           *\n *            |            *\n *            |             *\n *       50 - |               <--(Slope changes at the 15 second mark because of the update.\n *            |                *      Window extended to 60 seconds and limit reduced to 50 units.\n *            |                    *      Because amountInFlight/lastUpdated do not reset, 50 units are\n *            |                        *      considered in flight from the previous window and the corresponding\n *            |                             *     decay from the previous rate.)\n *            |                                 *\n *       25 - |                                     *\n *            |                                         *\n *            |                                              *\n *            |                                                  *\n *            |                                                      *\n *            |                                                           *\n *            |                                                               *\n *            |                                                                   *\n *        0 - +---|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----> Time\n *            0   5    10   15   20   25   30   35   40   45   50   55   60   65   70   75   80   85   90 (seconds)\n *            [  Initial 30 Second Window  ]\n *                          [ --------------- Extended 60 Second Window --------------- ]\n */\nabstract contract RateLimiter {\n\n    /**\n     * @notice Rate Limit struct.\n     * @param amountInFlight The amount in the current window.\n     * @param lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimit {\n        uint256 amountInFlight;\n        uint256 lastUpdated;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @notice Rate Limit Configuration struct.\n     * @param dstEid The destination endpoint id.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimitConfig {\n        uint32 dstEid;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @dev Mapping from destination endpoint id to RateLimit Configurations.\n     */\n    mapping(uint32 dstEid => RateLimit limit) public rateLimits;\n\n    /**\n     * @notice Emitted when _setRateLimits occurs.\n     * @param rateLimitConfigs An array of `RateLimitConfig` structs representing the rate limit configurations set.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    event RateLimitsChanged(RateLimitConfig[] rateLimitConfigs);\n\n    /**\n     * @notice Error that is thrown when an amount exceeds the rate_limit.\n     */\n    error RateLimitExceeded();\n\n    /**\n     * @notice Get the current amount that can be sent to this destination endpoint id for the given rate limit window.\n     * @param _dstEid The destination endpoint id.\n     * @return currentAmountInFlight The current amount that was sent.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function getAmountCanBeSent(\n        uint32 _dstEid\n    ) external view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        RateLimit memory rl = rateLimits[_dstEid];\n        return _amountCanBeSent(rl.amountInFlight, rl.lastUpdated, rl.limit, rl.window);\n    }\n\n    /**\n     * @notice Sets the Rate Limit.\n     * @param _rateLimitConfigs A `RateLimitConfig` struct representing the rate limit configuration.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    function _setRateLimits(RateLimitConfig[] memory _rateLimitConfigs) internal virtual {\n        unchecked {\n            for (uint256 i = 0; i < _rateLimitConfigs.length; i++) {\n                RateLimit storage rl = rateLimits[_rateLimitConfigs[i].dstEid];\n\n                // @dev Ensure we checkpoint the existing rate limit as to not retroactively apply the new decay rate.\n                _outflow(_rateLimitConfigs[i].dstEid, 0);\n\n                // @dev Does NOT reset the amountInFlight/lastUpdated of an existing rate limit.\n                rl.limit = _rateLimitConfigs[i].limit;\n                rl.window = _rateLimitConfigs[i].window;\n            }\n        }\n        emit RateLimitsChanged(_rateLimitConfigs);\n    }\n\n    /**\n     * @notice Checks current amount in flight and amount that can be sent for a given rate limit window.\n     * @param _amountInFlight The amount in the current window.\n     * @param _lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param _limit This represents the maximum allowed amount within a given window.\n     * @param _window Defines the duration of the rate limiting window.\n     * @return currentAmountInFlight The amount in the current window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function _amountCanBeSent(\n        uint256 _amountInFlight,\n        uint256 _lastUpdated,\n        uint256 _limit,\n        uint256 _window\n    ) internal view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        uint256 timeSinceLastDeposit = block.timestamp - _lastUpdated;\n        // @dev Presumes linear decay.\n        uint256 decay = (_limit * timeSinceLastDeposit) / (_window > 0 ? _window : 1); // prevent division by zero\n        currentAmountInFlight = _amountInFlight <= decay ? 0 : _amountInFlight - decay;\n        // @dev In the event the _limit is lowered, and the 'in-flight' amount is higher than the _limit, set to 0.\n        amountCanBeSent = _limit <= currentAmountInFlight ? 0 : _limit - currentAmountInFlight;\n    }\n\n    /**\n     * @notice Verifies whether the specified amount falls within the rate limit constraints for the targeted\n     * endpoint ID. On successful verification, it updates amountInFlight and lastUpdated. If the amount exceeds\n     * the rate limit, the operation reverts.\n     * @param _dstEid The destination endpoint id.\n     * @param _amount The amount to check for rate limit constraints.\n     */\n    function _outflow(uint32 _dstEid, uint256 _amount) internal virtual {\n        // @dev By default dstEid that have not been explicitly set will return amountCanBeSent == 0.\n        RateLimit storage rl = rateLimits[_dstEid];\n\n        (uint256 currentAmountInFlight, uint256 amountCanBeSent) = _amountCanBeSent(\n            rl.amountInFlight,\n            rl.lastUpdated,\n            rl.limit,\n            rl.window\n        );\n        if (_amount > amountCanBeSent) revert RateLimitExceeded();\n\n        // @dev Update the storage to contain the new amount and current timestamp.\n        rl.amountInFlight = currentAmountInFlight + _amount;\n        rl.lastUpdated = block.timestamp;\n    }\n\n    /**\n     * @notice To be used when you want to calculate your rate limits as a function of net outbound AND inbound.\n     * ie. If you move 150 out, and 100 in, you effective inflight should be 50.\n     * Does not need to update decay values, as the inflow is effective immediately.\n     * @param _srcEid The source endpoint id.\n     * @param _amount The amount to inflow back and deduct from amountInFlight.\n     */\n    function _inflow(uint32 _srcEid, uint256 _amount) internal virtual {\n        RateLimit storage rl = rateLimits[_srcEid];\n        rl.amountInFlight = _amount >= rl.amountInFlight ? 0 : rl.amountInFlight - _amount;\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/PreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IPreCrime, PreCrimePeer } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\nimport { InboundPacket, PacketDecoder } from \"./libs/Packet.sol\";\n\n// @dev WARNING: This preCrime contract is for testing only, it is not secure and should not be used in production.\n// @dev This is not fully implemented/audited/tested\nabstract contract PreCrime is Ownable, IPreCrime {\n    using BytesLib for bytes;\n\n    uint16 internal constant CONFIG_VERSION = 2;\n    address internal constant OFF_CHAIN_CALLER = address(0xDEAD);\n\n    address internal immutable lzEndpoint;\n    address public immutable simulator;\n    address public immutable oApp;\n\n    // preCrime config\n    uint64 public maxBatchSize;\n    PreCrimePeer[] internal preCrimePeers;\n\n    /// @dev getConfig(), simulate() and preCrime() are not view functions because it is more flexible to be able to\n    ///      update state for some complex logic. So onlyOffChain() modifier is to make sure they are only called\n    ///      by the off-chain.\n    modifier onlyOffChain() {\n        if (msg.sender != OFF_CHAIN_CALLER) revert OnlyOffChain();\n        _;\n    }\n\n    constructor(address _endpoint, address _simulator) {\n        lzEndpoint = _endpoint;\n        simulator = _simulator;\n        oApp = IOAppPreCrimeSimulator(_simulator).oApp();\n    }\n\n    function setMaxBatchSize(uint64 _maxBatchSize) external onlyOwner {\n        maxBatchSize = _maxBatchSize;\n    }\n\n    function setPreCrimePeers(PreCrimePeer[] calldata _preCrimePeers) external onlyOwner {\n        delete preCrimePeers;\n        for (uint256 i = 0; i < _preCrimePeers.length; ++i) {\n            preCrimePeers.push(_preCrimePeers[i]);\n        }\n    }\n\n    function getPreCrimePeers() external view returns (PreCrimePeer[] memory) {\n        return preCrimePeers;\n    }\n\n    function getConfig(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external onlyOffChain returns (bytes memory) {\n        bytes memory config = abi.encodePacked(CONFIG_VERSION, maxBatchSize);\n\n        // if no packets, return config with all peers\n        PreCrimePeer[] memory peers = _packets.length == 0\n            ? preCrimePeers\n            : _getPreCrimePeers(PacketDecoder.decode(_packets, _packetMsgValues));\n\n        if (peers.length > 0) {\n            uint16 size = uint16(peers.length);\n            config = abi.encodePacked(config, size);\n\n            for (uint256 i = 0; i < size; ++i) {\n                config = abi.encodePacked(config, peers[i].eid, peers[i].preCrime, peers[i].oApp);\n            }\n        }\n\n        return config;\n    }\n\n    // @dev _packetMsgValues refers to the 'lzReceive' option passed per packet\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable override onlyOffChain returns (bytes memory) {\n        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);\n        _checkPacketSizeAndOrder(packets);\n        return _simulate(packets);\n    }\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external onlyOffChain {\n        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);\n        uint32[] memory eids = new uint32[](_simulations.length);\n        bytes[] memory simulations = new bytes[](_simulations.length);\n\n        for (uint256 i = 0; i < _simulations.length; ++i) {\n            bytes calldata simulation = _simulations[i];\n            eids[i] = uint32(bytes4(simulation[0:4]));\n            simulations[i] = simulation[4:];\n        }\n        _checkResultsCompleteness(packets, eids);\n\n        _preCrime(packets, eids, simulations);\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor) {\n        return (2, 0);\n    }\n\n    function _checkResultsCompleteness(InboundPacket[] memory _packets, uint32[] memory _eids) internal {\n        // check if all peers result included\n        if (_packets.length > 0) {\n            PreCrimePeer[] memory peers = _getPreCrimePeers(_packets);\n            for (uint256 i = 0; i < peers.length; i++) {\n                uint32 expectedEid = peers[i].eid;\n                if (!_isContain(_eids, expectedEid)) revert SimulationResultNotFound(expectedEid);\n            }\n        }\n\n        // check if local result included\n        uint32 localEid = _getLocalEid();\n        if (!_isContain(_eids, localEid)) revert SimulationResultNotFound(localEid);\n    }\n\n    function _isContain(uint32[] memory _array, uint32 _item) internal pure returns (bool) {\n        for (uint256 i = 0; i < _array.length; i++) {\n            if (_array[i] == _item) return true;\n        }\n        return false;\n    }\n\n    function _checkPacketSizeAndOrder(InboundPacket[] memory _packets) internal view {\n        if (_packets.length > maxBatchSize) revert PacketOversize(maxBatchSize, _packets.length);\n\n        // check packets nonce, sequence order\n        // packets should ordered in ascending order by srcEid, sender, nonce\n        if (_packets.length > 0) {\n            uint32 srcEid;\n            bytes32 sender;\n            uint64 nonce;\n            for (uint256 i = 0; i < _packets.length; i++) {\n                InboundPacket memory packet = _packets[i];\n\n                // skip if not from trusted peer\n                if (!IOAppPreCrimeSimulator(simulator).isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n                if (\n                    packet.origin.srcEid < srcEid || (packet.origin.srcEid == srcEid && packet.origin.sender < sender)\n                ) {\n                    revert PacketUnsorted();\n                } else if (packet.origin.srcEid != srcEid || packet.origin.sender != sender) {\n                    // start from a new chain or a new source oApp\n                    srcEid = packet.origin.srcEid;\n                    sender = packet.origin.sender;\n                    nonce = _getInboundNonce(srcEid, sender);\n                }\n                // TODO ??\n                // Wont the nonce order not matter and enforced at the OApp level? the simulation will revert?\n\n                // the following packet's nonce add 1 in order\n                if (packet.origin.nonce != ++nonce) revert PacketUnsorted();\n            }\n        }\n    }\n\n    function _simulate(InboundPacket[] memory _packets) internal virtual returns (bytes memory) {\n        (bool success, bytes memory returnData) = simulator.call{ value: msg.value }(\n            abi.encodeWithSelector(IOAppPreCrimeSimulator.lzReceiveAndRevert.selector, _packets)\n        );\n\n        bytes memory result = _parseRevertResult(success, returnData);\n        return abi.encodePacked(_getLocalEid(), result); // add localEid at the first of the result\n    }\n\n    function _parseRevertResult(bool _success, bytes memory _returnData) internal pure returns (bytes memory result) {\n        // should always revert with LzReceiveRevert\n        if (_success) revert SimulationFailed(\"no revert\");\n\n        // if not expected selector, bubble up error\n        if (bytes4(_returnData) != IOAppPreCrimeSimulator.SimulationResult.selector) {\n            revert SimulationFailed(_returnData);\n        }\n\n        // Slice the sighash. Remove the selector which is the first 4 bytes\n        result = _returnData.slice(4, _returnData.length - 4);\n        result = abi.decode(result, (bytes));\n    }\n\n    // to be compatible with EndpointV1\n    function _getLocalEid() internal view virtual returns (uint32) {\n        return ILayerZeroEndpointV2(lzEndpoint).eid();\n    }\n\n    // to be compatible with EndpointV1\n    function _getInboundNonce(uint32 _srcEid, bytes32 _sender) internal view virtual returns (uint64) {\n        return ILayerZeroEndpointV2(lzEndpoint).inboundNonce(oApp, _srcEid, _sender);\n    }\n\n    // ----------------- to be implemented -----------------\n    function buildSimulationResult() external view virtual override returns (bytes memory);\n\n    function _getPreCrimePeers(InboundPacket[] memory _packets) internal virtual returns (PreCrimePeer[] memory peers);\n\n    function _preCrime(\n        InboundPacket[] memory _packets,\n        uint32[] memory _eids,\n        bytes[] memory _simulations\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/libs/Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/OApp.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20Mock } from \"./mocks/ERC20Mock.sol\";\nimport { OAppMock } from \"./mocks/OAppMock.sol\";\nimport { TestHelperOz5 } from \"@layerzerolabs/test-devtools-evm-foundry/contracts/TestHelperOz5.sol\";\nimport { MessagingParams, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OptionsBuilder } from \"../contracts/oapp/libs/OptionsBuilder.sol\";\nimport { console } from \"forge-std/console.sol\";\n\ncontract OAppTest is TestHelperOz5 {\n    using OptionsBuilder for bytes;\n\n    uint32 private aEid = 1;\n    ERC20Mock nativeTokenMock_A = new ERC20Mock(\"NativeTokens_A\", \"NAT_A\");\n\n    uint32 private bEid = 2;\n    ERC20Mock nativeTokenMock_B = new ERC20Mock(\"NativeTokens_B\", \"NAT_B\");\n\n    OAppMock private aOApp;\n    OAppMock private bOApp;\n\n    address private userA = address(0x1);\n    address private userB = address(0x2);\n    address private refundAddress = address(0x3);\n    \n    uint256 private initialBalance = 100 ether;\n\n    bytes32 receiverB32 = bytes32(uint256(uint160(address(bOApp))));\n    string message = \"Hello world\";\n\n    address endpoint;\n\n    bytes options;\n\n    function setUp() public override {\n        vm.deal(userA, 1000 ether);\n        vm.deal(userB, 1000 ether);\n\n        super.setUp();\n        setUpEndpoints(2, LibraryType.UltraLightNode);\n\n        aOApp = OAppMock(\n            _deployOApp(type(OAppMock).creationCode, abi.encode(address(endpoints[aEid]), address(this)))\n        );\n\n        bOApp = OAppMock(\n            _deployOApp(type(OAppMock).creationCode, abi.encode(address(endpoints[bEid]), address(this)))\n        );\n\n        address[] memory oapps = new address[](2);\n        oapps[0] = address(aOApp);\n        oapps[1] = address(bOApp);\n        this.wireOApps(oapps);\n\n        endpoint = address(aOApp.endpoint());\n        options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);\n    }\n\n    function test_constructor() public {\n        assertEq(aOApp.owner(), address(this));\n        assertEq(bOApp.owner(), address(this));\n\n        assertEq(address(aOApp.endpoint()), address(endpoints[aEid]));\n        assertEq(address(bOApp.endpoint()), address(endpoints[bEid]));\n    }\n    function test_Send() public {\n        vm.startPrank(userA);\n\n        MessagingParams memory msgParams = MessagingParams(bEid, receiverB32, abi.encode(message), options, false);\n\n        uint256 quoteFee = aOApp.endpoint().quote(msgParams, address(this)).nativeFee;\n        uint256 twiceQuoteFee = quoteFee * 2;\n\n        MessagingReceipt memory receipt = aOApp.endpoint().send{value: twiceQuoteFee}(msgParams, refundAddress);\n\n        assertEq(receipt.fee.nativeFee, quoteFee);\n        assertEq(receipt.fee.lzTokenFee, 0);\n\n        assertEq(address(endpoint).balance, 0);\n        assertEq(refundAddress.balance, quoteFee);\n        assertEq((endpointSetup.sendLibs[0]).balance, quoteFee);\n    }\n\n    function test_OAppSend() public {\n        vm.startPrank(userA);\n\n        uint256 quoteFee = aOApp.quote(bEid, message, options, false).nativeFee;\n        uint256 twiceQuoteFee = quoteFee * 2;\n\n        MessagingReceipt memory receipt = aOApp.send{value: twiceQuoteFee}(bEid, message, options, twiceQuoteFee);\n        verifyPackets(bEid, addressToBytes32(address(bOApp)));\n\n        assertEq(receipt.fee.nativeFee, quoteFee);\n        assertEq(receipt.fee.lzTokenFee, 0);\n\n        assertEq(address(endpoint).balance, 0);\n        assertEq((endpointSetup.sendLibs[0]).balance, quoteFee);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/PreCrimeV2.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.15;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\nimport { IPreCrime, PreCrimePeer } from \"../contracts/precrime/interfaces/IPreCrime.sol\";\nimport { InboundPacket } from \"../contracts/precrime/libs/Packet.sol\";\n\nimport { TestHelperOz5 } from \"@layerzerolabs/test-devtools-evm-foundry/contracts/TestHelperOz5.sol\";\nimport { PreCrimeV2Mock } from \"./mocks/PreCrimeV2Mock.sol\";\nimport { PreCrimeV2SimulatorMock } from \"./mocks/PreCrimeV2SimulatorMock.sol\";\n\ncontract PreCrimeV2Test is TestHelperOz5 {\n    uint8 constant DEFAULT_NUM_PEERS = 3;\n    uint64 constant DEFAULT_MAX_BATCH_SIZE = 4;\n\n    uint32 constant EID_B = 2;\n    uint32 constant EID_C = 3;\n    bytes32 constant SENDER_B = 0x0000000000000000000000000000000000000000000000000000000000000002;\n    bytes32 constant SENDER_C = 0x0000000000000000000000000000000000000000000000000000000000000003;\n\n    uint32 constant DST_EID = 1;\n\n    uint16 constant CONFIG_VERSION = 2;\n    uint64 constant MAX_BATCH_SIZE = 4;\n    address constant OFF_CHAIN = address(0xDEAD);\n\n    PreCrimeV2Mock preCrime;\n    PreCrimeV2SimulatorMock simulator;\n\n    PreCrimePeer[] preCrimePeers;\n\n    function setUpPreCrime(uint8 _numPeers, uint64 _maxBatchSize) private {\n        setUpEndpoints(_numPeers, LibraryType.SimpleMessageLib);\n\n        simulator = new PreCrimeV2SimulatorMock(address(this));\n        preCrime = new PreCrimeV2Mock(address(endpoints[DST_EID]), address(simulator), address(this));\n\n        for (uint8 i = 2; i <= _numPeers; i++) {\n            preCrimePeers.push(PreCrimePeer(uint32(i), bytes32(uint256(i)), bytes32(uint256(i))));\n        }\n\n        preCrime.setPreCrimePeers(preCrimePeers);\n        preCrime.setMaxBatchSize(_maxBatchSize);\n    }\n\n    function checkPreCrimeParams(uint8 _numPeers, uint64 _maxBatchSize) private pure {\n        vm.assume(_numPeers > 0 && _numPeers <= 10);\n        vm.assume(_maxBatchSize >= 1 && _maxBatchSize <= 50);\n    }\n\n    function checkAndSetupPreCrime(uint8 _numPeers, uint64 _maxBatchSize) private {\n        checkPreCrimeParams(_numPeers, _maxBatchSize);\n        setUpPreCrime(_numPeers, _maxBatchSize);\n    }\n\n    function setUpDefaultPreCrime() private {\n        setUpPreCrime(DEFAULT_NUM_PEERS, DEFAULT_MAX_BATCH_SIZE);\n    }\n\n    function test_getConfig_no_packets(uint256[] calldata _packetMsgValues) public {\n        setUpDefaultPreCrime();\n\n        // return config with all peers if no packet\n        vm.startPrank(OFF_CHAIN);\n        bytes memory config = preCrime.getConfig(new bytes[](0), _packetMsgValues);\n        bytes memory expectedConfig = abi.encodePacked(CONFIG_VERSION, MAX_BATCH_SIZE, _encodePeers(preCrimePeers));\n        assertEq(config, expectedConfig);\n    }\n\n    function test_getConfig_untrusted_peer(uint8 _numPeers, uint64 _maxBatchSize, bytes32 _untrustedPeer) public {\n        checkAndSetupPreCrime(_numPeers, _maxBatchSize);\n        // ensure the fuzzed address is not a multiple of ADDRESS_MULTIPLIER\n        vm.assume(uint256(_untrustedPeer) == 0 || uint256(_untrustedPeer) > _numPeers);\n\n        // return config without peers if packet from untrusted peer\n        bytes[] memory packets = _buildPacket(2, _untrustedPeer, 1, 1); // untrusted peer\n        vm.startPrank(OFF_CHAIN);\n        bytes memory config = preCrime.getConfig(packets, new uint256[](1));\n        bytes memory expectedConfig = abi.encodePacked(CONFIG_VERSION, _maxBatchSize);\n        assertEq(config, expectedConfig);\n    }\n\n    function test_getConfig_trusted_peer(uint8 _numPeers, uint64 _maxBatchSize) public {\n        vm.assume(_numPeers > 1);\n        checkAndSetupPreCrime(_numPeers, _maxBatchSize);\n\n        // return config with peers if packet from trusted peer\n        for (uint8 i = 2; i <= _numPeers; i++) {\n            bytes[] memory packets = _buildPacket(i, bytes32(uint256(i)), 1, 1); // trusted peer\n            vm.startPrank(OFF_CHAIN);\n            bytes memory config = preCrime.getConfig(packets, new uint256[](1));\n            bytes memory expectedConfig = abi.encodePacked(CONFIG_VERSION, _maxBatchSize, _encodePeers(preCrimePeers));\n            assertEq(config, expectedConfig);\n        }\n    }\n\n    function test_simulate_packetOverSize(uint64 _batchSize) public {\n        vm.assume(_batchSize > 0 && _batchSize < 1000);\n        setUpPreCrime(DEFAULT_NUM_PEERS, _batchSize);\n\n        uint256[] memory packetMsgValues = new uint256[](_batchSize + 1);\n        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, _batchSize + 1); // too many packets\n        vm.startPrank(OFF_CHAIN);\n        bytes memory expectedError = abi.encodeWithSelector(\n            IPreCrime.PacketOversize.selector,\n            _batchSize,\n            _batchSize + 1\n        );\n        vm.expectRevert(expectedError);\n        preCrime.simulate(packets, packetMsgValues);\n    }\n\n    // Sets up a test scenario to ensure input packets are ordered and not interleaved. There are 4 peers:\n    // A: dstEid = 1\n    // B: srcEid = 2, sender = 0x0000000000000000000000000000000000000000000000000000000000000002\n    // C: srcEid = 3, sender = 0x0000000000000000000000000000000000000000000000000000000000000003\n    // The test then calls simulate() with:\n    // 1. numPacketsB from B to A starting at startingNonceB\n    // 2. numPacketsC from C to A starting at startingNonceC\n    // 3. One packet from B to A starting at startingNonceB + numPacketsB + 1\n    // PacketUnsorted is expected.\n    function test_simulate_packetUnsorted_interleaving_peers(\n        uint8 _numPacketsB,\n        uint64 _startingNonceB,\n        uint8 _numPacketsC,\n        uint64 _startingNonceC\n    ) public {\n        // numPacketsA and numPacketsB must be positive in order to cause interleaving\n        vm.assume(_numPacketsB > 0);\n        vm.assume(_numPacketsC > 0);\n\n        // calculate the last nonce sent by B and C, ensuring that the container does not overflow\n        uint128 endingNonceB = (uint128(_startingNonceB) + uint128(_numPacketsB));\n        uint128 endingNonceC = (uint128(_startingNonceC) + uint128(_numPacketsC));\n        vm.assume(endingNonceB < type(uint64).max);\n        vm.assume(endingNonceC < type(uint64).max);\n\n        uint64 totalPackets = uint64(_numPacketsB) + uint64(_numPacketsC) + 1; // 1 extra for the interleave at the end\n\n        setUpPreCrime(DEFAULT_NUM_PEERS, totalPackets);\n\n        uint256[] memory packetMsgValues = new uint256[](totalPackets);\n        bytes[] memory unsortedPackets = new bytes[](totalPackets);\n\n        // B -> A\n        bytes[] memory sortedPacketsB = _buildPacket(EID_B, SENDER_B, _startingNonceB, _numPacketsB);\n        assertEq(sortedPacketsB.length, _numPacketsB);\n        uint256 j = 0;\n        for (uint256 i = 0; i < _numPacketsB; i++) {\n            unsortedPackets[j++] = sortedPacketsB[i];\n        }\n        // C -> A\n        bytes[] memory sortedPacketsC = _buildPacket(EID_C, SENDER_C, _startingNonceC, _numPacketsC);\n        assertEq(sortedPacketsC.length, _numPacketsC);\n        for (uint256 i = 0; i < _numPacketsC; i++) {\n            unsortedPackets[j++] = sortedPacketsC[i];\n        }\n        // B -> A (interleaved)\n        unsortedPackets[j++] = _buildPacket(EID_B, SENDER_B, _startingNonceB + _numPacketsB + 1, 1)[0]; // unsorted\n\n        vm.startPrank(OFF_CHAIN);\n        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.PacketUnsorted.selector);\n        vm.expectRevert(expectedError);\n        preCrime.simulate(unsortedPackets, packetMsgValues);\n    }\n\n    function test_simulate_packetUnsorted_one_unordered_peer(\n        uint8 _numPacketsB,\n        uint64 _startingNonceB,\n        uint8 _replaceIndexOffset // added to _startingNonceB to get the index of the packet to replace\n    ) public {\n        // 1. numPacketsB must be at least 3 to ensure that the replaceIndex is within bounds\n        // 2. replaceIndexOffset must be less than numPacketsB to ensure that the replaceIndex is within bounds\n        vm.assume(_numPacketsB >= 3);\n        vm.assume(_replaceIndexOffset < _numPacketsB - 2);\n        // 3. calculate the last nonce sent by B and C, ensuring that the container does not overflow\n        uint128 endingNonceB = (uint128(_startingNonceB) + uint128(_numPacketsB));\n        vm.assume(endingNonceB < type(uint64).max);\n        // 4. calculate the index of the packet to replace\n        uint64 replaceIndex = _replaceIndexOffset + _startingNonceB;\n        vm.assume(replaceIndex > _startingNonceB && replaceIndex < endingNonceB - 2);\n\n        setUpPreCrime(DEFAULT_NUM_PEERS, _numPacketsB);\n\n        uint256[] memory packetMsgValues = new uint256[](_numPacketsB);\n        bytes[] memory unsortedPackets = _buildPacket(EID_B, SENDER_B, _startingNonceB, _numPacketsB);\n        unsortedPackets[replaceIndex - _startingNonceB] = _encodePacket(\n            InboundPacket(\n                Origin(EID_B, SENDER_B, 0),\n                DST_EID,\n                address(uint160(uint256(SENDER_B))), //preCrime.oApp(),\n                bytes32(0), // guid\n                0, // value\n                address(0), // executor\n                \"\", // message\n                \"\" // extraData\n            )\n        );\n\n        vm.startPrank(OFF_CHAIN);\n        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.PacketUnsorted.selector);\n        vm.expectRevert(expectedError);\n        preCrime.simulate(unsortedPackets, packetMsgValues);\n    }\n\n    function test_simulate_failed() public {\n        uint32 invalidPeerEid = 0; // see PrecrimeV2SimulatorMock, which hardcodes eid=0 as InvalidEid\n        setUpDefaultPreCrime();\n\n        // empty packetMsgValues to be reused\n        uint256[] memory packetMsgValues = new uint256[](1);\n        bytes[] memory packets = _buildPacket(invalidPeerEid, bytes32(0), 1, 1); // invalid packet and simulation failed\n        vm.startPrank(OFF_CHAIN);\n        bytes memory expectedError = abi.encodeWithSelector(\n            IPreCrime.SimulationFailed.selector,\n            abi.encodeWithSelector(PreCrimeV2SimulatorMock.InvalidEid.selector)\n        );\n        vm.expectRevert(expectedError);\n        preCrime.simulate(packets, packetMsgValues);\n    }\n\n    function test_simulate(uint8 _numPacketsB, uint8 _numPacketsC) public {\n        vm.assume(_numPacketsB > 0 && _numPacketsC > 0);\n        uint64 totalPackets = uint32(_numPacketsB) + uint32(_numPacketsC);\n        setUpPreCrime(DEFAULT_NUM_PEERS, totalPackets);\n\n        uint256[] memory packetMsgValues = new uint256[](totalPackets);\n        bytes[] memory packets = _buildPacket(EID_B, SENDER_B, 1, _numPacketsB);\n        packets = _appendPackets(packets, _buildPacket(EID_C, SENDER_C, 1, _numPacketsC));\n        assertEq(packets.length, totalPackets);\n\n        vm.startPrank(OFF_CHAIN);\n        bytes memory result = preCrime.simulate(packets, packetMsgValues);\n        bytes memory expectedResult = abi.encodePacked(DST_EID, uint256(totalPackets));\n        assertEq(result, expectedResult);\n    }\n\n    function test_preCrime_simulationResultNotFound() public {\n        setUpDefaultPreCrime();\n\n        uint256[] memory packetMsgValues = new uint256[](1);\n        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 1);\n\n        // result of eid 3 not found\n        bytes[] memory results = new bytes[](2);\n        results[0] = abi.encodePacked(uint32(1), uint256(1));\n        results[1] = abi.encodePacked(uint32(2), uint256(1));\n\n        vm.startPrank(OFF_CHAIN);\n        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.SimulationResultNotFound.selector, 3);\n        vm.expectRevert(expectedError);\n        preCrime.preCrime(packets, packetMsgValues, results);\n\n        // result of eid 1 (local result) not found\n        results[0] = abi.encodePacked(uint32(2), uint256(1));\n        results[1] = abi.encodePacked(uint32(3), uint256(1));\n\n        expectedError = abi.encodeWithSelector(IPreCrime.SimulationResultNotFound.selector, 1);\n        vm.expectRevert(expectedError);\n        preCrime.preCrime(packets, packetMsgValues, results);\n    }\n\n    function test_preCrime() public {\n        setUpDefaultPreCrime();\n\n        uint256[] memory packetMsgValues = new uint256[](1);\n        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 1);\n\n        bytes[] memory results = new bytes[](3);\n        results[0] = abi.encodePacked(uint32(1), uint256(1));\n        results[1] = abi.encodePacked(uint32(2), uint256(2));\n        results[2] = abi.encodePacked(uint32(3), uint256(3));\n\n        vm.startPrank(OFF_CHAIN);\n        preCrime.preCrime(packets, packetMsgValues, results);\n\n        // check internal state of preCrime\n        assertEq(preCrime.eids(0), 1);\n        assertEq(preCrime.eids(1), 2);\n        assertEq(preCrime.eids(2), 3);\n        assertEq(preCrime.results(0), abi.encode(1));\n        assertEq(preCrime.results(1), abi.encode(2));\n        assertEq(preCrime.results(2), abi.encode(3));\n    }\n\n    function _buildPacket(\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        uint256 _numPackets\n    ) internal view returns (bytes[] memory) {\n        bytes[] memory packets = new bytes[](_numPackets);\n        for (uint256 i = 0; i < _numPackets; ++i) {\n            InboundPacket memory packet = InboundPacket(\n                Origin(_srcEid, _sender, _nonce + uint64(i)),\n                DST_EID,\n                preCrime.oApp(),\n                bytes32(0), // guid\n                0, // value\n                address(0), // executor\n                \"\", // message\n                \"\" // extraData\n            );\n            packets[i] = _encodePacket(packet);\n        }\n        return packets;\n    }\n\n    function _encodePacket(InboundPacket memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            uint8(1),\n            _packet.origin.nonce,\n            _packet.origin.srcEid,\n            _packet.origin.sender,\n            _packet.dstEid,\n            bytes32(uint256(uint160(_packet.receiver))),\n            _packet.guid,\n            _packet.value,\n            _packet.message\n        );\n    }\n\n    function _appendPackets(\n        bytes[] memory _packets,\n        bytes[] memory _newPackets\n    ) internal pure returns (bytes[] memory) {\n        bytes[] memory packets = new bytes[](_packets.length + _newPackets.length);\n        for (uint256 i = 0; i < _packets.length; ++i) {\n            packets[i] = _packets[i];\n        }\n        for (uint256 i = 0; i < _newPackets.length; ++i) {\n            packets[_packets.length + i] = _newPackets[i];\n        }\n        return packets;\n    }\n\n    function _encodePeers(PreCrimePeer[] memory _peers) internal pure returns (bytes memory) {\n        bytes memory peers = abi.encodePacked(uint16(_peers.length));\n        for (uint256 i = 0; i < _peers.length; ++i) {\n            peers = abi.encodePacked(peers, _peers[i].eid, _peers[i].preCrime, _peers[i].oApp);\n        }\n        return peers;\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/RateLimiter.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport \"../contracts/oapp/utils/RateLimiter.sol\";\n\ncontract RateLimiterImpl is RateLimiter {\n    constructor() {}\n\n    function setRateLimits(RateLimitConfig[] memory _rateLimitConfigs) external {\n        _setRateLimits(_rateLimitConfigs);\n    }\n\n    function outflow(uint32 _dstEid, uint256 _amount) external {\n        _outflow(_dstEid, _amount);\n    }\n\n    function inflow(uint32 _srcEid, uint256 _amount) external {\n        _inflow(_srcEid, _amount);\n    }\n}\n\ncontract RateLimiterTest is RateLimiterImpl, Test {\n    uint32 dstEid = 1;\n    uint256 sendLimit = 100 ether;\n    uint256 window = 1 hours;\n    uint256 amountInFlight;\n    uint256 amountCanBeSent;\n    RateLimiterImpl rateLimiterImpl;\n\n    function setUp() public virtual {\n        vm.warp(0);\n        RateLimiter.RateLimitConfig[] memory rateLimitConfigs = new RateLimiter.RateLimitConfig[](1);\n        rateLimitConfigs[0] = RateLimiter.RateLimitConfig(dstEid, sendLimit, window);\n\n        rateLimiterImpl = new RateLimiterImpl();\n        rateLimiterImpl.setRateLimits(rateLimitConfigs);\n    }\n\n    function test_max_rate_limit() public {\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n    }\n\n    function _setRateLimit(uint32 _dstEid, uint256 _limit, uint256 _window) internal {\n        RateLimiter.RateLimitConfig[] memory rateLimitConfigs = new RateLimiter.RateLimitConfig[](1);\n        rateLimitConfigs[0] = RateLimiter.RateLimitConfig(_dstEid, _limit, _window);\n        rateLimiterImpl.setRateLimits(rateLimitConfigs);\n    }\n\n    function test_inflights_during_window_reduction() public {\n        _setRateLimit(dstEid, 100, 100);\n        rateLimiterImpl.outflow(dstEid, 100);\n        _setRateLimit(dstEid, 40, 60);\n\n        vm.warp(60 seconds);\n\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, 60);\n        assertEq(amountCanBeSent, 0);\n    }\n\n    function test_over_max_rate_limit() public {\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, 101 ether);\n    }\n\n    function test_rate_limit_resets_after_window() public {\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n        vm.warp(block.timestamp + 1 hours + 1 seconds);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n    }\n\n    function test_rate_limit_inflow_deducts_from_outflow() public {\n        // Send max limit\n        vm.warp(0);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n\n        // Verify max in flight\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit);\n        assertEq(amountCanBeSent, 0);\n\n        // Inflow some amount\n        rateLimiterImpl.inflow(dstEid, sendLimit / 2);\n\n        // Verify amountInFlight/amountCanBeSent is half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, sendLimit / 2);\n    }\n\n    function test_rate_limit_inflow_deducts_from_outflow_exceeds_amount_in_flight() public {\n        // Send max limit\n        vm.warp(0);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n\n        // Verify max in flight\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit);\n        assertEq(amountCanBeSent, 0);\n\n        // Inflow some amount that exceeds the current amount in flight\n        rateLimiterImpl.inflow(dstEid, sendLimit + 1);\n\n        // Verify amount in flight reset to 0\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, 0);\n        assertEq(amountCanBeSent, sendLimit);\n    }\n\n    function test_multiple_rate_limit_windows() public {\n        uint16[10] memory times = [1, 11, 233, 440, 666, 667, 778, 999, 1000, 3600];\n        uint256 decay = 0;\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n        for (uint256 i = 0; i < 10; i++) {\n            decay = (sendLimit * times[i]) / window;\n            vm.warp(times[i]);\n            (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n            assertEq(amountInFlight, decay < sendLimit ? sendLimit - decay : 0);\n            assertEq(amountCanBeSent, decay < sendLimit ? decay : sendLimit);\n        }\n    }\n\n    function test_rate_change_mid_window() public {\n        // Make sure you can send max limit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, 0);\n        assertEq(amountCanBeSent, sendLimit);\n\n        // Send max limit\n        vm.warp(0);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n\n        // Verify max in flight\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit);\n        assertEq(amountCanBeSent, 0);\n\n        // Expect revert when max in flight\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n\n        // Advance halfway through window\n        vm.warp(1800);\n\n        // Verify amountInFlight/amountCanBeSent is half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, sendLimit / 2);\n\n        // update sendLimit to 2x\n        uint256 newLimit = 200 ether;\n        RateLimiter.RateLimitConfig[] memory rateLimitConfigs = new RateLimiter.RateLimitConfig[](1);\n        rateLimitConfigs[0] = RateLimiter.RateLimitConfig(dstEid, newLimit, window);\n        rateLimiterImpl.setRateLimits(rateLimitConfigs);\n\n        // Verify amountInFlight is still half the sendLimit\n        // Verify amountCanBeSent is the newLimit - half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, newLimit - sendLimit / 2);\n\n        // Advance rest of the window\n        vm.warp(3600);\n\n        // Verify new max limit can be sent\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Expect revert when max in flight\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, 1 ether);\n    }\n\n    function test_window_change_mid_window() public {\n        // Send max limit\n        vm.warp(0);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit);\n        assertEq(amountCanBeSent, 0);\n\n        // Advance 30 mins\n        vm.warp(1800);\n\n        // Verify amountInFlight/amountCanBeSent is half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, sendLimit / 2);\n\n        // Update window to be 2x longer.\n        uint256 newWindow = 2 hours;\n        RateLimiter.RateLimitConfig[] memory rateLimitConfigs = new RateLimiter.RateLimitConfig[](1);\n        rateLimitConfigs[0] = RateLimiter.RateLimitConfig(dstEid, sendLimit, newWindow);\n        rateLimiterImpl.setRateLimits(rateLimitConfigs);\n\n        // Verify amountInFlight/amountCanBeSent is still half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, sendLimit / 2);\n\n        // Expect anything more that half the sendLimit to revert\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, sendLimit / 2 + 1 ether);\n\n        // Advance another 30 mins\n        vm.warp(3600);\n\n        // Verify amountInFlight is still 1/4 the sendLimit\n        // Verify amountCanBeSent is 3/4 the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 4);\n        assertEq(amountCanBeSent, sendLimit - sendLimit / 4);\n\n        // Advance another past the window\n        vm.warp(5400);\n\n        // Verify max limit can be sent\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n\n        // Advance old window and make sure you cant send max limit because of newly set window\n        vm.warp(9000);\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n    }\n\n    function test_rate_and_window_change_mid_window() public {\n        // Send max limit\n        vm.warp(0);\n        rateLimiterImpl.outflow(dstEid, sendLimit);\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit);\n        assertEq(amountCanBeSent, 0);\n\n        // Advance 30 mins\n        vm.warp(1800);\n\n        // Verify amountInFlight/amountCanBeSent is half the sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, sendLimit / 2);\n        assertEq(amountCanBeSent, sendLimit / 2);\n\n        // Update limit to 2x and window to 4x.\n        uint256 newLimit = 200 ether;\n        uint256 newWindow = 4 hours;\n        RateLimiter.RateLimitConfig[] memory rateLimitConfigs = new RateLimiter.RateLimitConfig[](1);\n        rateLimitConfigs[0] = RateLimiter.RateLimitConfig(dstEid, newLimit, newWindow);\n        rateLimiterImpl.setRateLimits(rateLimitConfigs);\n\n        // The amountInFlight should be a 1/4 of the newLimit because the new rate limit provides capacity for 50 ETH/hour\n        // We sent 100 ETH an hour before the update. So one hour after the update, half of this capacity (50 ETH) is considered still in use\n\n        // Verify amountInFlight is still half the sendLimit\n        // Verify amountCanBeSent is the newLimit - half the sendLimit\n        uint amountInFlightBeforeUpdate = sendLimit / 2;\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, amountInFlightBeforeUpdate);\n        assertEq(amountCanBeSent, newLimit - amountInFlightBeforeUpdate);\n\n        // Advance another 30 mins\n        vm.warp(3600);\n\n        // Verify amountInFlight is 1/4 the old sendLimit\n        // Verify amountCanBeSent is newLimit - 1/4 the old sendLimit\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        assertEq(amountInFlight, amountInFlightBeforeUpdate / 2);\n        assertEq(amountCanBeSent, newLimit - amountInFlightBeforeUpdate / 2);\n\n        // Advance another 30 mins\n        vm.warp(5400);\n        // Verify new max limit can be sent\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Verify max amount cant be sent for the rest of the window (4 hours left in window)\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Advance another 60 mins\n        vm.warp(9000);\n        // Verify max amount cant be sent for the rest of the window (3 hours left in window)\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Advance another 60 mins\n        vm.warp(12600);\n        // Verify max amount cant be sent for the rest of the window (2 hours left in window)\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Advance another 60 mins\n        vm.warp(16200);\n        // Verify max amount cant be sent for the rest of the window (1 hours left in window)\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Advance another 60 mins\n        vm.warp(19800);\n        (amountInFlight, amountCanBeSent) = rateLimiterImpl.getAmountCanBeSent(dstEid);\n        // Verify max amount can be sent when new window starts\n        rateLimiterImpl.outflow(dstEid, newLimit);\n\n        // Verify max inflight and cant send anymore at this point in time\n        vm.expectRevert(abi.encodeWithSelector(RateLimiter.RateLimitExceeded.selector));\n        rateLimiterImpl.outflow(dstEid, 1 ether);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/lib/OAppOptionsType3.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.22;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { OptionsType3Mock } from \"./mock/OptionsType3Mock.sol\";\nimport { OptionsBuilder } from \"../../contracts/oapp/libs/OptionsBuilder.sol\";\nimport { IOAppOptionsType3 } from \"../../contracts/oapp/interfaces/IOAppOptionsType3.sol\";\n\ncontract OAppOptionsType3Test is Test {\n    using OptionsBuilder for bytes;\n\n    function test_constructor(uint128 lzReceiveGas, uint128 lzReceiveValue) public {\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(lzReceiveGas, lzReceiveValue);\n        OptionsType3Mock mock = new OptionsType3Mock(options, true, address(this));\n        bytes memory actualOptions = mock.enforcedOptions(1, 1);\n        assertEq(actualOptions, options, \"OptionsType3Mock constructor should set enforced options\");\n    }\n\n    function test_assertOptionsType3(uint128 lzReceiveGas, uint128 lzReceiveValue) public {\n        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(lzReceiveGas, lzReceiveValue);\n        OptionsType3Mock mock = new OptionsType3Mock(options, false, address(this));\n        mock.assertOptionsType3(options);\n    }\n\n    function test_assertOptionsType3_fails(uint16 prefix, bytes memory remaining) public {\n        vm.assume(prefix != 3);\n        bytes memory options = abi.encodePacked(bytes2(prefix), remaining);\n        OptionsType3Mock mock = new OptionsType3Mock(options, false, address(this));\n        vm.expectRevert(abi.encodeWithSelector(IOAppOptionsType3.InvalidOptions.selector, options));\n        mock.assertOptionsType3(options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/lib/mock/OptionsType3Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { OAppOptionsType3 } from \"../../../contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { EnforcedOptionParam } from \"../../../contracts/oapp/interfaces/IOAppOptionsType3.sol\";\n\ncontract OptionsType3Mock is OAppOptionsType3 {\n\n    constructor(bytes memory options, bool applyEnforcedOptions, address _owner) Ownable(_owner) {\n        if (applyEnforcedOptions) {\n            EnforcedOptionParam[] memory params = new EnforcedOptionParam[](1);\n            params[0] = EnforcedOptionParam(1, 1, options);\n            _setEnforcedOptions(params); // ensure enforced options can be set in the constructor\n        }\n    }\n\n    function assertOptionsType3(bytes calldata options) public pure {\n        _assertOptionsType3(options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/mocks/OAppMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { OApp, MessagingFee, Origin } from \"../../contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\ncontract OAppMock is OApp {\n    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) Ownable(_delegate) {}\n\n    string public data = \"Nothing received yet.\";\n\n    /**\n     * @notice Sends a message from the source chain to a destination chain.\n     * @param _dstEid The endpoint ID of the destination chain.\n     * @param _message The message string to be sent.\n     * @param _options Additional options for message execution.\n     * @dev Encodes the message as bytes and sends it using the `_lzSend` internal function.\n     * @return receipt A `MessagingReceipt` struct containing details of the message sent.\n     */\n    function send(\n        uint32 _dstEid,\n        string memory _message,\n        bytes calldata _options,\n        uint256 _nativeFee\n    ) external payable returns (MessagingReceipt memory receipt) {\n        bytes memory _payload = abi.encode(_message);\n        receipt = _lzSend(_dstEid, _payload, _options, MessagingFee(_nativeFee, 0), payable(msg.sender));\n    }\n\n    /**\n     * @notice Quotes the gas needed to pay for the full omnichain transaction in native gas or ZRO token.\n     * @param _dstEid Destination chain's endpoint ID.\n     * @param _message The message.\n     * @param _options Message execution options (e.g., for sending gas to destination).\n     * @param _payInLzToken Whether to return fee in ZRO token.\n     * @return fee A `MessagingFee` struct containing the calculated gas fee in either the native token or ZRO token.\n     */\n    function quote(\n        uint32 _dstEid,\n        string memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) public view returns (MessagingFee memory fee) {\n        bytes memory payload = abi.encode(_message);\n        fee = _quote(_dstEid, payload, _options, _payInLzToken);\n    }\n\n    /**\n     * @dev Internal function override to handle incoming messages from another chain.\n     * @dev _origin A struct containing information about the message sender.\n     * @dev _guid A unique global packet identifier for the message.\n     * @param payload The encoded message payload being received.\n     *\n     * @dev The following params are unused in the current implementation of the OApp.\n     * @dev _executor The address of the Executor responsible for processing the message.\n     * @dev _extraData Arbitrary data appended by the Executor to the message.\n     *\n     * Decodes the received payload and processes it as per the business logic defined in the function.\n     */\n    function _lzReceive(\n        Origin calldata /*_origin*/,\n        bytes32 /*_guid*/,\n        bytes calldata payload,\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) internal override {\n        data = abi.decode(payload, (string));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/mocks/PreCrimeV2Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { PreCrimePeer } from \"../../contracts/precrime/interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator } from \"../../contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol\";\nimport { PreCrime } from \"../../contracts/precrime/PreCrime.sol\";\nimport { InboundPacket } from \"../../contracts/precrime/libs/Packet.sol\";\n\nimport { PreCrimeV2SimulatorMock } from \"./PreCrimeV2SimulatorMock.sol\";\n\ncontract PreCrimeV2Mock is PreCrime {\n    uint32[] public eids;\n    bytes[] public results;\n\n    constructor(\n        address _endpoint,\n        address _simulator,\n        address _owner\n    ) PreCrime(_endpoint, _simulator) Ownable(_owner) {}\n\n    function buildSimulationResult() external view override returns (bytes memory) {\n        return abi.encode(PreCrimeV2SimulatorMock(simulator).count());\n    }\n\n    function _getPreCrimePeers(\n        InboundPacket[] memory _packets\n    ) internal view override returns (PreCrimePeer[] memory peers) {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket memory packet = _packets[i];\n            if (IOAppPreCrimeSimulator(simulator).isPeer(packet.origin.srcEid, packet.origin.sender)) {\n                return preCrimePeers;\n            }\n        }\n        return (new PreCrimePeer[](0));\n    }\n\n    function _preCrime(InboundPacket[] memory, uint32[] memory _eids, bytes[] memory _results) internal override {\n        eids = _eids;\n        results = _results;\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/test/mocks/PreCrimeV2SimulatorMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { OAppPreCrimeSimulator } from \"../../contracts/precrime/OAppPreCrimeSimulator.sol\";\n\ncontract PreCrimeV2SimulatorMock is OAppPreCrimeSimulator {\n    uint256 public count;\n\n    error InvalidEid();\n\n    constructor(address _owner) Ownable(_owner) {}\n\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 /*_guid*/,\n        bytes calldata /*_message*/,\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) internal override {\n        if (_origin.srcEid == 0) revert InvalidEid();\n        count++;\n    }\n\n    function isPeer(uint32 _eid, bytes32 _peer) public pure override returns (bool) {\n        return bytes32(uint256(_eid)) == _peer;\n    }\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/libs/ONFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\n/**\n * @title ONFT Composed Message Codec\n * @notice Library for encoding and decoding ONFT composed messages.\n */\nlibrary ONFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant COMPOSE_FROM_OFFSET = 44;\n\n    /**\n     * @dev Encodes a ONFT721 composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source LayerZero endpoint ID.\n     * @param _composeMsg The composed message.\n     * @return The encoded payload, including the composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_nonce, _srcEid, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce for the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source LayerZero endpoint ID for the composed message.\n     * @param _msg The message.\n     * @return The source LayerZero endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value as bytes32.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[SRC_EID_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/ONFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { ONFT721Core } from \"./ONFT721Core.sol\";\n\n/**\n * @title ONFT721 Contract\n * @dev ONFT721 is an ERC-721 token that extends the functionality of the ONFT721Core contract.\n */\nabstract contract ONFT721 is ONFT721Core, ERC721 {\n    string internal baseTokenURI;\n\n    event BaseURISet(string baseURI);\n\n    /**\n     * @dev Constructor for the ONFT721 contract.\n     * @param _name The name of the ONFT.\n     * @param _symbol The symbol of the ONFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC721(_name, _symbol) ONFT721Core(_lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the address of the underlying ERC721 implementation (ie. this contract).\n     */\n    function token() external view returns (address) {\n        return address(this);\n    }\n\n    function setBaseURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n        emit BaseURISet(baseTokenURI);\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @notice Indicates whether the ONFT721 contract requires approval of the 'token()' to send.\n     * @dev In the case of ONFT where the contract IS the token, approval is NOT required.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    function _debit(address _from, uint256 _tokenId, uint32 /*_dstEid*/) internal virtual override {\n        if (_from != ERC721.ownerOf(_tokenId)) revert OnlyNFTOwner(_from, ERC721.ownerOf(_tokenId));\n        _burn(_tokenId);\n    }\n\n    function _credit(address _to, uint256 _tokenId, uint32 /*_srcEid*/) internal virtual override {\n        _mint(_to, _tokenId);\n    }\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/ONFT721Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { ONFT721Core } from \"./ONFT721Core.sol\";\n\n/**\n * @title ONFT721Adapter Contract\n * @dev ONFT721Adapter is a wrapper used to enable cross-chain transferring of an existing ERC721 token.\n * @dev ERC721 NFTs from extensions which revert certain transactions, such as ones from blocked wallets or soulbound\n * @dev tokens, may still be bridgeable.\n */\nabstract contract ONFT721Adapter is ONFT721Core {\n    IERC721 internal immutable innerToken;\n\n    /**\n     * @dev Constructor for the ONFT721 contract.\n     * @param _token The underlying ERC721 token address this adapts\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _token, address _lzEndpoint, address _delegate) ONFT721Core(_lzEndpoint, _delegate) {\n        innerToken = IERC721(_token);\n    }\n\n    /**\n     * @notice Retrieves the address of the underlying ERC721 implementation (ie. external contract).\n     */\n    function token() external view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the ONFT721 contract requires approval of the 'token()' to send.\n     * @dev In the case of ONFT where the contract IS the token, approval is NOT required.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return true;\n    }\n\n    function _debit(address _from, uint256 _tokenId, uint32 /*_dstEid*/) internal virtual override {\n        // @dev Dont need to check onERC721Received() when moving into this contract, ie. no 'safeTransferFrom' required\n        innerToken.transferFrom(_from, address(this), _tokenId);\n    }\n\n    function _credit(address _toAddress, uint256 _tokenId, uint32 /*_srcEid*/) internal virtual override {\n        // @dev Do not need to check onERC721Received() when moving out of this contract, ie. no 'safeTransferFrom'\n        // required\n        // @dev The default implementation does not implement IERC721Receiver as 'safeTransferFrom' is not used.\n        // @dev If IERC721Receiver is required, ensure proper re-entrancy protection is implemented.\n        innerToken.transferFrom(address(this), _toAddress, _tokenId);\n    }\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/ONFT721Core.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { OApp, Origin } from \"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport { OAppPreCrimeSimulator } from \"@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IONFT721, MessagingFee, MessagingReceipt, SendParam } from \"./interfaces/IONFT721.sol\";\nimport { ONFT721MsgCodec } from \"./libs/ONFT721MsgCodec.sol\";\nimport { ONFTComposeMsgCodec } from \"../libs/ONFTComposeMsgCodec.sol\";\n\n/**\n * @title ONFT721Core\n * @dev Abstract contract for an ONFT721 token.\n */\nabstract contract ONFT721Core is IONFT721, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using ONFT721MsgCodec for bytes;\n    using ONFT721MsgCodec for bytes32;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_COMPOSE = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _lzEndpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _lzEndpoint, address _delegate) Ownable(_delegate) OApp(_lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves interfaceID and the version of the ONFT.\n     * @return interfaceId The interface ID (0x23e18da6).\n     * @return version The version.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other ONFTs.\n     * @dev If a new feature is added to the ONFT cross-chain msg encoding, the version will be incremented.\n     * @dev ie. localONFT version(x,1) CAN send messages to remoteONFT version(x,1)\n     */\n    function onftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IONFT721).interfaceId, 1);\n    }\n\n    /**\n     * @notice Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam);\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt) {\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam);\n\n        // @dev Sends the message to the LayerZero Endpoint, returning the MessagingReceipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        emit ONFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, _sendParam.tokenId);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam memory _sendParam\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        if (_sendParam.to == bytes32(0)) revert InvalidReceiver();\n        bool hasCompose;\n        (message, hasCompose) = ONFT721MsgCodec.encode(_sendParam.to, _sendParam.tokenId, _sendParam.composeMsg);\n        uint16 msgType = hasCompose ? SEND_AND_COMPOSE : SEND;\n\n        options = this.combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        address inspector = msgInspector; // caches the msgInspector to avoid potential double storage read\n        if (inspector != address(0)) IOAppMsgInspector(inspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        uint256 tokenId = _message.tokenId();\n\n        _credit(toAddress, tokenId, _origin.srcEid);\n\n        if (_message.isComposed()) {\n            bytes memory composeMsg = ONFTComposeMsgCodec.encode(_origin.nonce, _origin.srcEid, _message.composeMsg());\n            // @dev As batching is not implemented, the compose index is always 0.\n            // @dev If batching is added, the index will need to be tracked.\n            endpoint.sendCompose(toAddress, _guid, 0 /* the index of composed message*/, composeMsg);\n        }\n\n        emit ONFTReceived(_guid, _origin.srcEid, toAddress, tokenId);\n    }\n\n    /*\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    function _debit(address /*_from*/, uint256 /*_tokenId*/, uint32 /*_dstEid*/) internal virtual;\n\n    function _credit(address /*_to*/, uint256 /*_tokenId*/, uint32 /*_srcEid*/) internal virtual;\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/ONFT721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { ERC721Enumerable, ERC721 } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\nimport { ONFT721Core } from \"./ONFT721Core.sol\";\n\n/**\n * @title ONFT721Enumerable Contract\n * @dev ONFT721 is an ERC-721 token that extends the functionality of the ONFT721Core contract.\n */\nabstract contract ONFT721Enumerable is ONFT721Core, ERC721Enumerable {\n    string internal baseTokenURI;\n\n    event BaseURISet(string baseURI);\n\n    /**\n     * @dev Constructor for the ONFT721 contract.\n     * @param _name The name of the ONFT.\n     * @param _symbol The symbol of the ONFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC721(_name, _symbol) ONFT721Core(_lzEndpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the address of the underlying ERC721 implementation (ie. this contract).\n     */\n    function token() external view returns (address) {\n        return address(this);\n    }\n\n    function setBaseURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n        emit BaseURISet(baseTokenURI);\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @notice Indicates whether the ONFT721 contract requires approval of the 'token()' to send.\n     * @dev In the case of ONFT where the contract IS the token, approval is NOT required.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    function _debit(address _from, uint256 _tokenId, uint32 /*_dstEid*/) internal virtual override {\n        if (_from != ERC721.ownerOf(_tokenId)) revert OnlyNFTOwner(_from, ERC721.ownerOf(_tokenId));\n        _burn(_tokenId);\n    }\n\n    function _credit(address _to, uint256 _tokenId, uint32 /*_srcEid*/) internal virtual override {\n        _mint(_to, _tokenId);\n    }\n}"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/interfaces/IONFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { MessagingFee, MessagingReceipt } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the ONFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination LayerZero EndpointV2 ID.\n    bytes32 to; // Recipient address.\n    uint256 tokenId;\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes onftCmd; // The ONFT command to be executed, unused in default ONFT implementations.\n}\n\n/**\n * @title IONFT\n * @dev Interface for the ONFT721 token.\n * @dev Does not inherit ERC721 to accommodate usage by OFT721Adapter.\n */\ninterface IONFT721 {\n    // Custom error messages\n    error InvalidReceiver();\n    error OnlyNFTOwner(address caller, address owner);\n\n    // Events\n    event ONFTSent(\n        bytes32 indexed guid, // GUID of the ONFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 tokenId // ONFT ID sent.\n    );\n\n    event ONFTReceived(\n        bytes32 indexed guid, // GUID of the ONFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 tokenId // ONFT ID received.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the ONFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     * @dev interfaceId: This specific interface ID is '0x94642228'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other ONFTs.\n     * @dev If a new feature is added to the ONFT cross-chain msg encoding, the version will be incremented.\n     * ie. localONFT version(x,1) CAN send messages to remoteONFT version(x,1)\n     */\n    function onftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the ONFT.\n     * @return token The address of the ERC721 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the ONFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n}\n"
    },
    "@layerzerolabs/onft-evm/contracts/onft721/libs/ONFT721MsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\n/**\n * @title ONFT721MsgCodec\n * @notice Library for encoding and decoding ONFT721 LayerZero messages.\n */\nlibrary ONFT721MsgCodec {\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant TOKEN_ID_OFFSET = 64;\n\n    /**\n     * @dev Encodes an ONFT721 LayerZero message payload.\n     * @param _sendTo The recipient address.\n     * @param _tokenId The ID of the token to transfer.\n     * @param _composeMsg The composed payload.\n     * @return payload The encoded message payload.\n     * @return hasCompose A boolean indicating whether the message payload contains a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint256 _tokenId,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory payload, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        payload = hasCompose\n            ? abi.encodePacked(_sendTo, _tokenId, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _tokenId);\n    }\n\n    /**\n     * @dev Decodes sendTo from the ONFT LayerZero message.\n     * @param _msg The message.\n     * @return The recipient address in bytes32 format.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Decodes tokenId from the ONFT LayerZero message.\n     * @param _msg The message.\n     * @return The ID of the tokens to transfer.\n     */\n    function tokenId(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SEND_TO_OFFSET:TOKEN_ID_OFFSET]));\n    }\n\n    /**\n     * @dev Decodes whether there is a composed payload.\n     * @param _msg The message.\n     * @return A boolean indicating whether the message has a composed payload.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > TOKEN_ID_OFFSET;\n    }\n\n    /**\n     * @dev Decodes the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[TOKEN_ID_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "OmniNadsMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport \"@layerzerolabs/onft-evm/contracts/onft721/ONFT721.sol\";\nimport \"./interfaces/IOmniNadsMinter.sol\";\nimport \"./libs/DynamicONFT.sol\";\n\n\ncontract OmniNadsMinter is IOmniNadsMinter, ONFT721 {\n\n\n    DynamicONFT.MintInfo public mintInfo;\n    mapping(uint => DynamicONFT.TokenState) public tokenState;\n    mapping(address => bool) private _hasMinted;\n    mapping(address => bool) private _isWhitelisted;\n    \n\n\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate,\n        uint16 _maxSupply,\n        address[] memory _whitelistedAddresses\n    ) ONFT721(_name, _symbol, _lzEndpoint, _delegate) {\n\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n        mintInfo._maxSupply = _maxSupply;\n        mintInfo._totalSupply = 0;\n\n        for (uint i = 0; i < _whitelistedAddresses.length; ) {\n            _isWhitelisted[_whitelistedAddresses[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    modifier isNotSmartContract() {\n        require(\n            msg.sender.code.length == 0,\n            \"Smart contract mint is not allowed!\"\n        );\n        _;\n    }\n\n    function nextPhase() external onlyOwner {\n        require(\n            mintInfo._phase != DynamicONFT.MintPhase.PUBLIC,\n            \"Already in last phase!\"\n        );\n        mintInfo._phase = DynamicONFT.MintPhase(uint8(mintInfo._phase) + 1);\n\n        if (mintInfo._phase == DynamicONFT.MintPhase.WHITELIST) {\n            emit DynamicONFT.WhitelistPhaseStarted();\n        } else {\n            emit DynamicONFT.PublicPhaseStarted();\n        }\n    }\n\n    function emergencyDisableMint() external onlyOwner {\n        mintInfo._phase = DynamicONFT.MintPhase.DISABLED;\n    }\n\n    function addToWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = true;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function removeFromWhitelist(address _address) external override onlyOwner {\n        _isWhitelisted[_address] = false;\n        emit DynamicONFT.WhitelistUpdated();\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        _requireOwned(tokenId);\n\n        return\n            string(\n                abi.encodePacked(baseTokenURI, tokenState[tokenId],\"/omni-nad-\", tokenId, \".json\")\n            );\n    }\n\n    function _mint() internal {\n        require(\n            mintInfo._maxSupply >= mintInfo._totalSupply,\n            \"Max supply reached!\"\n        );\n        require(!_hasMinted[msg.sender], \"User already minted!\");\n\n        unchecked {\n            ++mintInfo._totalSupply;\n        }\n\n        _hasMinted[msg.sender] = true;\n        tokenState[mintInfo._totalSupply] = DynamicONFT.TokenState.MINTED;\n        \n        _mint(msg.sender, mintInfo._totalSupply);\n    }\n\n    function publicMint() external isNotSmartContract {\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.PUBLIC,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.PublicMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function whitelistMint() external isNotSmartContract {\n        require(_isWhitelisted[msg.sender], \"User is not whitelisted!\");\n        require(\n            mintInfo._phase == DynamicONFT.MintPhase.WHITELIST,\n            \"Not in whitelist phase!\"\n        );\n        _mint();\n        emit DynamicONFT.WhitelistMint(mintInfo._totalSupply, msg.sender);\n    }\n\n    function send(\n        SendParam memory _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable override returns (MessagingReceipt memory msgReceipt) {\n\n        _debit(msg.sender, _sendParam.tokenId, _sendParam.dstEid);\n\n        _sendParam.tokenId = DynamicONFT.encodeTokenInfo(\n            _sendParam.tokenId,\n            tokenState[_sendParam.tokenId]\n        );\n        delete tokenState[_sendParam.tokenId];\n\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(\n            _sendParam\n        );\n\n        msgReceipt = _lzSend(\n            _sendParam.dstEid,\n            message,\n            options,\n            _fee,\n            _refundAddress\n        );\n\n        emit ONFTSent(\n            msgReceipt.guid,\n            _sendParam.dstEid,\n            msg.sender,\n            _sendParam.tokenId\n        );\n    }\n\n    function _credit(\n        address _to,\n        uint256 _encodedTokenInfo,\n        uint32 /*_srcEid*/\n    ) internal override {\n        \n        (uint256 _tokenId, DynamicONFT.TokenState _receivedState) = DynamicONFT.decodeTokenInfo(\n            _encodedTokenInfo\n        );\n        uint8 _evolvedState = uint8(_receivedState);\n\n        if(_evolvedState < 3)\n        {\n            _evolvedState += 1;\n            emit DynamicONFT.TokenEvolved(_tokenId, _evolvedState);\n        }\n\n        tokenState[_tokenId] = DynamicONFT.TokenState(_evolvedState);\n\n        _mint(_to, _tokenId);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {}
  }
}